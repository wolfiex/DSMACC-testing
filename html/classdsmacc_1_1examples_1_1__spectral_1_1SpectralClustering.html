<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DSMACC: dsmacc.examples._spectral.SpectralClustering Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">DSMACC
   &#160;<span id="projectnumber">2019</span>
   </div>
   <div id="projectbrief">Changes to DSMACC for the thesis of Daniel Ellis</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>dsmacc</b></li><li class="navelem"><b>examples</b></li><li class="navelem"><b>_spectral</b></li><li class="navelem"><a class="el" href="classdsmacc_1_1examples_1_1__spectral_1_1SpectralClustering.html">SpectralClustering</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="classdsmacc_1_1examples_1_1__spectral_1_1SpectralClustering-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">dsmacc.examples._spectral.SpectralClustering Class Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Inheritance diagram for dsmacc.examples._spectral.SpectralClustering:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classdsmacc_1_1examples_1_1__spectral_1_1SpectralClustering.png" usemap="#dsmacc.examples._5Fspectral.SpectralClustering_map" alt=""/>
  <map id="dsmacc.examples._5Fspectral.SpectralClustering_map" name="dsmacc.examples._5Fspectral.SpectralClustering_map">
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a850315e1678fb3638054fd7e3db1de60"><td class="memItemLeft" align="right" valign="top"><a id="a850315e1678fb3638054fd7e3db1de60"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><b>__init__</b> (self, n_clusters=8, eigen_solver=None, n_components=None, random_state=None, n_init=10, gamma=1., affinity='rbf', n_neighbors=10, eigen_tol=0.0, assign_labels='kmeans', degree=3, coef0=1, kernel_params=None, n_jobs=None)</td></tr>
<tr class="separator:a850315e1678fb3638054fd7e3db1de60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5af13c6812bd105744f4682a0f084511"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdsmacc_1_1examples_1_1__spectral_1_1SpectralClustering.html#a5af13c6812bd105744f4682a0f084511">fit</a> (self, X, y=None)</td></tr>
<tr class="separator:a5af13c6812bd105744f4682a0f084511"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2199033bd2458f93914ca1a1ad26ca23"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdsmacc_1_1examples_1_1__spectral_1_1SpectralClustering.html#a2199033bd2458f93914ca1a1ad26ca23">fit_predict</a> (self, X, y=None)</td></tr>
<tr class="separator:a2199033bd2458f93914ca1a1ad26ca23"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:aa5bf2b5cac4103f9837f50dfac13e1c6"><td class="memItemLeft" align="right" valign="top"><a id="aa5bf2b5cac4103f9837f50dfac13e1c6"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>n_clusters</b></td></tr>
<tr class="separator:aa5bf2b5cac4103f9837f50dfac13e1c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba12ac3e483a35b287709872664a4ebc"><td class="memItemLeft" align="right" valign="top"><a id="aba12ac3e483a35b287709872664a4ebc"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>eigen_solver</b></td></tr>
<tr class="separator:aba12ac3e483a35b287709872664a4ebc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b47d41f0a09f3349091539ec9947d3b"><td class="memItemLeft" align="right" valign="top"><a id="a6b47d41f0a09f3349091539ec9947d3b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>n_components</b></td></tr>
<tr class="separator:a6b47d41f0a09f3349091539ec9947d3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abea0baa6809240593656bcf0936913c5"><td class="memItemLeft" align="right" valign="top"><a id="abea0baa6809240593656bcf0936913c5"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>random_state</b></td></tr>
<tr class="separator:abea0baa6809240593656bcf0936913c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78f94706fca848791697e809c978da5d"><td class="memItemLeft" align="right" valign="top"><a id="a78f94706fca848791697e809c978da5d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>n_init</b></td></tr>
<tr class="separator:a78f94706fca848791697e809c978da5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23dc7f166fed307997567d8f1974b1cf"><td class="memItemLeft" align="right" valign="top"><a id="a23dc7f166fed307997567d8f1974b1cf"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>gamma</b></td></tr>
<tr class="separator:a23dc7f166fed307997567d8f1974b1cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e59c078b139bdb5926704652b20ed84"><td class="memItemLeft" align="right" valign="top"><a id="a8e59c078b139bdb5926704652b20ed84"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>affinity</b></td></tr>
<tr class="separator:a8e59c078b139bdb5926704652b20ed84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a697d0e9c49ece85db9183cb7920d1c5d"><td class="memItemLeft" align="right" valign="top"><a id="a697d0e9c49ece85db9183cb7920d1c5d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>n_neighbors</b></td></tr>
<tr class="separator:a697d0e9c49ece85db9183cb7920d1c5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5e9631e6a8e9ffa65735a59d06e9ef4"><td class="memItemLeft" align="right" valign="top"><a id="aa5e9631e6a8e9ffa65735a59d06e9ef4"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>eigen_tol</b></td></tr>
<tr class="separator:aa5e9631e6a8e9ffa65735a59d06e9ef4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94b0921d29987261844f3a00341f4cfe"><td class="memItemLeft" align="right" valign="top"><a id="a94b0921d29987261844f3a00341f4cfe"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>assign_labels</b></td></tr>
<tr class="separator:a94b0921d29987261844f3a00341f4cfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8ec8f3855e335b5d246914d80112468"><td class="memItemLeft" align="right" valign="top"><a id="ae8ec8f3855e335b5d246914d80112468"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>degree</b></td></tr>
<tr class="separator:ae8ec8f3855e335b5d246914d80112468"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd77a122fba25696e63b265ef89d89e8"><td class="memItemLeft" align="right" valign="top"><a id="acd77a122fba25696e63b265ef89d89e8"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>coef0</b></td></tr>
<tr class="separator:acd77a122fba25696e63b265ef89d89e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dfa3f4606cc0e7bd50bf346e745aebf"><td class="memItemLeft" align="right" valign="top"><a id="a1dfa3f4606cc0e7bd50bf346e745aebf"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>kernel_params</b></td></tr>
<tr class="separator:a1dfa3f4606cc0e7bd50bf346e745aebf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a139a5d2dee1a79c5a4a8a9afdda22b36"><td class="memItemLeft" align="right" valign="top"><a id="a139a5d2dee1a79c5a4a8a9afdda22b36"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>n_jobs</b></td></tr>
<tr class="separator:a139a5d2dee1a79c5a4a8a9afdda22b36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ef3a45e4b2af7f8addecf187fa409b1"><td class="memItemLeft" align="right" valign="top"><a id="a7ef3a45e4b2af7f8addecf187fa409b1"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>affinity_matrix_</b></td></tr>
<tr class="separator:a7ef3a45e4b2af7f8addecf187fa409b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae73c7ce7d73f1cfc4220c9bb0b130cb4"><td class="memItemLeft" align="right" valign="top"><a id="ae73c7ce7d73f1cfc4220c9bb0b130cb4"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>labels_</b></td></tr>
<tr class="separator:ae73c7ce7d73f1cfc4220c9bb0b130cb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment">Apply clustering to a projection of the normalized Laplacian.

In practice Spectral Clustering is very useful when the structure of
the individual clusters is highly non-convex or more generally when
a measure of the center and spread of the cluster is not a suitable
description of the complete cluster. For instance when clusters are
nested circles on the 2D plane.

If affinity is the adjacency matrix of a graph, this method can be
used to find normalized graph cuts.

When calling ``fit``, an affinity matrix is constructed using either
kernel function such the Gaussian (aka RBF) kernel of the euclidean
distanced ``d(X, X)``::

        np.exp(-gamma * d(X,X) ** 2)

or a k-nearest neighbors connectivity matrix.

Alternatively, using ``precomputed``, a user-provided affinity
matrix can be used.

Read more in the :ref:`User Guide &lt;spectral_clustering&gt;`.

Parameters
----------
n_clusters : integer, optional
    The dimension of the projection subspace.

eigen_solver : {None, 'arpack', 'lobpcg', or 'amg'}
    The eigenvalue decomposition strategy to use. AMG requires pyamg
    to be installed. It can be faster on very large, sparse problems,
    but may also lead to instabilities.

n_components : integer, optional, default=n_clusters
    Number of eigen vectors to use for the spectral embedding

random_state : int, RandomState instance or None (default)
    A pseudo random number generator used for the initialization of the
    lobpcg eigen vectors decomposition when ``eigen_solver='amg'`` and by
    the K-Means initialization. Use an int to make the randomness
    deterministic.
    See :term:`Glossary &lt;random_state&gt;`.

n_init : int, optional, default: 10
    Number of time the k-means algorithm will be run with different
    centroid seeds. The final results will be the best output of
    n_init consecutive runs in terms of inertia.

gamma : float, default=1.0
    Kernel coefficient for rbf, poly, sigmoid, laplacian and chi2 kernels.
    Ignored for ``affinity='nearest_neighbors'``.

affinity : string or callable, default 'rbf'
    How to construct the affinity matrix.
     - 'nearest_neighbors' : construct the affinity matrix by computing a
       graph of nearest neighbors.
     - 'rbf' : construct the affinity matrix using a radial basis function
       (RBF) kernel.
     - 'precomputed' : interpret ``X`` as a precomputed affinity matrix.
     - 'precomputed_nearest_neighbors' : interpret ``X`` as a sparse graph
       of precomputed nearest neighbors, and constructs the affinity matrix
       by selecting the ``n_neighbors`` nearest neighbors.
     - one of the kernels supported by
       :func:`~sklearn.metrics.pairwise_kernels`.

    Only kernels that produce similarity scores (non-negative values that
    increase with similarity) should be used. This property is not checked
    by the clustering algorithm.

n_neighbors : integer
    Number of neighbors to use when constructing the affinity matrix using
    the nearest neighbors method. Ignored for ``affinity='rbf'``.

eigen_tol : float, optional, default: 0.0
    Stopping criterion for eigendecomposition of the Laplacian matrix
    when ``eigen_solver='arpack'``.

assign_labels : {'kmeans', 'discretize'}, default: 'kmeans'
    The strategy to use to assign labels in the embedding
    space. There are two ways to assign labels after the laplacian
    embedding. k-means can be applied and is a popular choice. But it can
    also be sensitive to initialization. Discretization is another approach
    which is less sensitive to random initialization.

degree : float, default=3
    Degree of the polynomial kernel. Ignored by other kernels.

coef0 : float, default=1
    Zero coefficient for polynomial and sigmoid kernels.
    Ignored by other kernels.

kernel_params : dictionary of string to any, optional
    Parameters (keyword arguments) and values for kernel passed as
    callable object. Ignored by other kernels.

n_jobs : int or None, optional (default=None)
    The number of parallel jobs to run.
    ``None`` means 1 unless in a :obj:`joblib.parallel_backend` context.
    ``-1`` means using all processors. See :term:`Glossary &lt;n_jobs&gt;`
    for more details.

Attributes
----------
affinity_matrix_ : array-like, shape (n_samples, n_samples)
    Affinity matrix used for clustering. Available only if after calling
    ``fit``.

labels_ : array, shape (n_samples,)
    Labels of each point

Examples
--------
&gt;&gt;&gt; from sklearn.cluster import SpectralClustering
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; X = np.array([[1, 1], [2, 1], [1, 0],
...               [4, 7], [3, 5], [3, 6]])
&gt;&gt;&gt; clustering = SpectralClustering(n_clusters=2,
...         assign_labels="discretize",
...         random_state=0).fit(X)
&gt;&gt;&gt; clustering.labels_
array([1, 1, 1, 0, 0, 0])
&gt;&gt;&gt; clustering
SpectralClustering(assign_labels='discretize', n_clusters=2,
    random_state=0)

Notes
-----
If you have an affinity matrix, such as a distance matrix,
for which 0 means identical elements, and high values means
very dissimilar elements, it can be transformed in a
similarity matrix that is well suited for the algorithm by
applying the Gaussian (RBF, heat) kernel::

    np.exp(- dist_matrix ** 2 / (2. * delta ** 2))

Where ``delta`` is a free parameter representing the width of the Gaussian
kernel.

Another alternative is to take a symmetric version of the k
nearest neighbors connectivity matrix of the points.

If the pyamg package is installed, it is used: this greatly
speeds up computation.

References
----------

- Normalized cuts and image segmentation, 2000
  Jianbo Shi, Jitendra Malik
  http://citeseer.ist.psu.edu/viewdoc/summary?doi=10.1.1.160.2324

- A Tutorial on Spectral Clustering, 2007
  Ulrike von Luxburg
  http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.165.9323

- Multiclass spectral clustering, 2003
  Stella X. Yu, Jianbo Shi
  https://www1.icsi.berkeley.edu/~stellayu/publication/doc/2003kwayICCV.pdf
</pre> </div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a5af13c6812bd105744f4682a0f084511"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5af13c6812bd105744f4682a0f084511">&#9670;&nbsp;</a></span>fit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def dsmacc.examples._spectral.SpectralClustering.fit </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>y</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Perform spectral clustering from features, or affinity matrix.

Parameters
----------
X : array-like or sparse matrix, shape (n_samples, n_features), or \
    array-like, shape (n_samples, n_samples)
    Training instances to cluster, or similarities / affinities between
    instances if ``affinity='precomputed'``. If a sparse matrix is
    provided in a format other than ``csr_matrix``, ``csc_matrix``,
    or ``coo_matrix``, it will be converted into a sparse
    ``csr_matrix``.

y : Ignored
    Not used, present here for API consistency by convention.

Returns
-------
self</pre> <div class="fragment"><div class="line"><a name="l00459"></a><span class="lineno">  459</span>&#160;    <span class="keyword">def </span>fit(self, X, y=None):</div><div class="line"><a name="l00460"></a><span class="lineno">  460</span>&#160;        <span class="stringliteral">&quot;&quot;&quot;Perform spectral clustering from features, or affinity matrix.</span></div><div class="line"><a name="l00461"></a><span class="lineno">  461</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l00462"></a><span class="lineno">  462</span>&#160;<span class="stringliteral">        Parameters</span></div><div class="line"><a name="l00463"></a><span class="lineno">  463</span>&#160;<span class="stringliteral">        ----------</span></div><div class="line"><a name="l00464"></a><span class="lineno">  464</span>&#160;<span class="stringliteral">        X : array-like or sparse matrix, shape (n_samples, n_features), or \</span></div><div class="line"><a name="l00465"></a><span class="lineno">  465</span>&#160;<span class="stringliteral">            array-like, shape (n_samples, n_samples)</span></div><div class="line"><a name="l00466"></a><span class="lineno">  466</span>&#160;<span class="stringliteral">            Training instances to cluster, or similarities / affinities between</span></div><div class="line"><a name="l00467"></a><span class="lineno">  467</span>&#160;<span class="stringliteral">            instances if ``affinity=&#39;precomputed&#39;``. If a sparse matrix is</span></div><div class="line"><a name="l00468"></a><span class="lineno">  468</span>&#160;<span class="stringliteral">            provided in a format other than ``csr_matrix``, ``csc_matrix``,</span></div><div class="line"><a name="l00469"></a><span class="lineno">  469</span>&#160;<span class="stringliteral">            or ``coo_matrix``, it will be converted into a sparse</span></div><div class="line"><a name="l00470"></a><span class="lineno">  470</span>&#160;<span class="stringliteral">            ``csr_matrix``.</span></div><div class="line"><a name="l00471"></a><span class="lineno">  471</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l00472"></a><span class="lineno">  472</span>&#160;<span class="stringliteral">        y : Ignored</span></div><div class="line"><a name="l00473"></a><span class="lineno">  473</span>&#160;<span class="stringliteral">            Not used, present here for API consistency by convention.</span></div><div class="line"><a name="l00474"></a><span class="lineno">  474</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l00475"></a><span class="lineno">  475</span>&#160;<span class="stringliteral">        Returns</span></div><div class="line"><a name="l00476"></a><span class="lineno">  476</span>&#160;<span class="stringliteral">        -------</span></div><div class="line"><a name="l00477"></a><span class="lineno">  477</span>&#160;<span class="stringliteral">        self</span></div><div class="line"><a name="l00478"></a><span class="lineno">  478</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l00479"></a><span class="lineno">  479</span>&#160;<span class="stringliteral">        &quot;&quot;&quot;</span></div><div class="line"><a name="l00480"></a><span class="lineno">  480</span>&#160;        X = check_array(X, accept_sparse=[<span class="stringliteral">&#39;csr&#39;</span>, <span class="stringliteral">&#39;csc&#39;</span>, <span class="stringliteral">&#39;coo&#39;</span>],</div><div class="line"><a name="l00481"></a><span class="lineno">  481</span>&#160;                        dtype=np.float64, ensure_min_samples=2)</div><div class="line"><a name="l00482"></a><span class="lineno">  482</span>&#160;        allow_squared = self.affinity <span class="keywordflow">in</span> [<span class="stringliteral">&quot;precomputed&quot;</span>,</div><div class="line"><a name="l00483"></a><span class="lineno">  483</span>&#160;                                          <span class="stringliteral">&quot;precomputed_nearest_neighbors&quot;</span>]</div><div class="line"><a name="l00484"></a><span class="lineno">  484</span>&#160;        <span class="keywordflow">if</span> X.shape[0] == X.shape[1] <span class="keywordflow">and</span> <span class="keywordflow">not</span> allow_squared:</div><div class="line"><a name="l00485"></a><span class="lineno">  485</span>&#160;            warnings.warn(<span class="stringliteral">&quot;The spectral clustering API has changed. ``fit``&quot;</span></div><div class="line"><a name="l00486"></a><span class="lineno">  486</span>&#160;                          <span class="stringliteral">&quot;now constructs an affinity matrix from data. To use&quot;</span></div><div class="line"><a name="l00487"></a><span class="lineno">  487</span>&#160;                          <span class="stringliteral">&quot; a custom affinity matrix, &quot;</span></div><div class="line"><a name="l00488"></a><span class="lineno">  488</span>&#160;                          <span class="stringliteral">&quot;set ``affinity=precomputed``.&quot;</span>)</div><div class="line"><a name="l00489"></a><span class="lineno">  489</span>&#160;</div><div class="line"><a name="l00490"></a><span class="lineno">  490</span>&#160;        <span class="keywordflow">if</span> self.affinity == <span class="stringliteral">&#39;nearest_neighbors&#39;</span>:</div><div class="line"><a name="l00491"></a><span class="lineno">  491</span>&#160;            connectivity = kneighbors_graph(X, n_neighbors=self.n_neighbors,</div><div class="line"><a name="l00492"></a><span class="lineno">  492</span>&#160;                                            include_self=<span class="keyword">True</span>,</div><div class="line"><a name="l00493"></a><span class="lineno">  493</span>&#160;                                            n_jobs=self.n_jobs)</div><div class="line"><a name="l00494"></a><span class="lineno">  494</span>&#160;            self.affinity_matrix_ = 0.5 * (connectivity + connectivity.T)</div><div class="line"><a name="l00495"></a><span class="lineno">  495</span>&#160;        <span class="keywordflow">elif</span> self.affinity == <span class="stringliteral">&#39;precomputed_nearest_neighbors&#39;</span>:</div><div class="line"><a name="l00496"></a><span class="lineno">  496</span>&#160;            estimator = NearestNeighbors(n_neighbors=self.n_neighbors,</div><div class="line"><a name="l00497"></a><span class="lineno">  497</span>&#160;                                         n_jobs=self.n_jobs,</div><div class="line"><a name="l00498"></a><span class="lineno">  498</span>&#160;                                         metric=<span class="stringliteral">&quot;precomputed&quot;</span>).fit(X)</div><div class="line"><a name="l00499"></a><span class="lineno">  499</span>&#160;            connectivity = estimator.kneighbors_graph(X=X, mode=<span class="stringliteral">&#39;connectivity&#39;</span>)</div><div class="line"><a name="l00500"></a><span class="lineno">  500</span>&#160;            self.affinity_matrix_ = 0.5 * (connectivity + connectivity.T)</div><div class="line"><a name="l00501"></a><span class="lineno">  501</span>&#160;        <span class="keywordflow">elif</span> self.affinity == <span class="stringliteral">&#39;precomputed&#39;</span>:</div><div class="line"><a name="l00502"></a><span class="lineno">  502</span>&#160;            self.affinity_matrix_ = X</div><div class="line"><a name="l00503"></a><span class="lineno">  503</span>&#160;        <span class="keywordflow">else</span>:</div><div class="line"><a name="l00504"></a><span class="lineno">  504</span>&#160;            params = self.kernel_params</div><div class="line"><a name="l00505"></a><span class="lineno">  505</span>&#160;            <span class="keywordflow">if</span> params <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div><div class="line"><a name="l00506"></a><span class="lineno">  506</span>&#160;                params = {}</div><div class="line"><a name="l00507"></a><span class="lineno">  507</span>&#160;            <span class="keywordflow">if</span> <span class="keywordflow">not</span> callable(self.affinity):</div><div class="line"><a name="l00508"></a><span class="lineno">  508</span>&#160;                params[<span class="stringliteral">&#39;gamma&#39;</span>] = self.gamma</div><div class="line"><a name="l00509"></a><span class="lineno">  509</span>&#160;                params[<span class="stringliteral">&#39;degree&#39;</span>] = self.degree</div><div class="line"><a name="l00510"></a><span class="lineno">  510</span>&#160;                params[<span class="stringliteral">&#39;coef0&#39;</span>] = self.coef0</div><div class="line"><a name="l00511"></a><span class="lineno">  511</span>&#160;            self.affinity_matrix_ = pairwise_kernels(X, metric=self.affinity,</div><div class="line"><a name="l00512"></a><span class="lineno">  512</span>&#160;                                                     filter_params=<span class="keyword">True</span>,</div><div class="line"><a name="l00513"></a><span class="lineno">  513</span>&#160;                                                     **params)</div><div class="line"><a name="l00514"></a><span class="lineno">  514</span>&#160;</div><div class="line"><a name="l00515"></a><span class="lineno">  515</span>&#160;        random_state = check_random_state(self.random_state)</div><div class="line"><a name="l00516"></a><span class="lineno">  516</span>&#160;        self.labels_ = spectral_clustering(self.affinity_matrix_,</div><div class="line"><a name="l00517"></a><span class="lineno">  517</span>&#160;                                           n_clusters=self.n_clusters,</div><div class="line"><a name="l00518"></a><span class="lineno">  518</span>&#160;                                           n_components=self.n_components,</div><div class="line"><a name="l00519"></a><span class="lineno">  519</span>&#160;                                           eigen_solver=self.eigen_solver,</div><div class="line"><a name="l00520"></a><span class="lineno">  520</span>&#160;                                           random_state=random_state,</div><div class="line"><a name="l00521"></a><span class="lineno">  521</span>&#160;                                           n_init=self.n_init,</div><div class="line"><a name="l00522"></a><span class="lineno">  522</span>&#160;                                           eigen_tol=self.eigen_tol,</div><div class="line"><a name="l00523"></a><span class="lineno">  523</span>&#160;                                           assign_labels=self.assign_labels)</div><div class="line"><a name="l00524"></a><span class="lineno">  524</span>&#160;        <span class="keywordflow">return</span> self</div><div class="line"><a name="l00525"></a><span class="lineno">  525</span>&#160;</div></div><!-- fragment -->
</div>
</div>
<a id="a2199033bd2458f93914ca1a1ad26ca23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2199033bd2458f93914ca1a1ad26ca23">&#9670;&nbsp;</a></span>fit_predict()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def dsmacc.examples._spectral.SpectralClustering.fit_predict </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>y</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Perform spectral clustering from features, or affinity matrix,
and return cluster labels.

Parameters
----------
X : array-like or sparse matrix, shape (n_samples, n_features), or \
    array-like, shape (n_samples, n_samples)
    Training instances to cluster, or similarities / affinities between
    instances if ``affinity='precomputed'``. If a sparse matrix is
    provided in a format other than ``csr_matrix``, ``csc_matrix``,
    or ``coo_matrix``, it will be converted into a sparse
    ``csr_matrix``.

y : Ignored
    Not used, present here for API consistency by convention.

Returns
-------
labels : ndarray, shape (n_samples,)
    Cluster labels.
</pre> <div class="fragment"><div class="line"><a name="l00526"></a><span class="lineno">  526</span>&#160;    <span class="keyword">def </span>fit_predict(self, X, y=None):</div><div class="line"><a name="l00527"></a><span class="lineno">  527</span>&#160;        <span class="stringliteral">&quot;&quot;&quot;Perform spectral clustering from features, or affinity matrix,</span></div><div class="line"><a name="l00528"></a><span class="lineno">  528</span>&#160;<span class="stringliteral">        and return cluster labels.</span></div><div class="line"><a name="l00529"></a><span class="lineno">  529</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l00530"></a><span class="lineno">  530</span>&#160;<span class="stringliteral">        Parameters</span></div><div class="line"><a name="l00531"></a><span class="lineno">  531</span>&#160;<span class="stringliteral">        ----------</span></div><div class="line"><a name="l00532"></a><span class="lineno">  532</span>&#160;<span class="stringliteral">        X : array-like or sparse matrix, shape (n_samples, n_features), or \</span></div><div class="line"><a name="l00533"></a><span class="lineno">  533</span>&#160;<span class="stringliteral">            array-like, shape (n_samples, n_samples)</span></div><div class="line"><a name="l00534"></a><span class="lineno">  534</span>&#160;<span class="stringliteral">            Training instances to cluster, or similarities / affinities between</span></div><div class="line"><a name="l00535"></a><span class="lineno">  535</span>&#160;<span class="stringliteral">            instances if ``affinity=&#39;precomputed&#39;``. If a sparse matrix is</span></div><div class="line"><a name="l00536"></a><span class="lineno">  536</span>&#160;<span class="stringliteral">            provided in a format other than ``csr_matrix``, ``csc_matrix``,</span></div><div class="line"><a name="l00537"></a><span class="lineno">  537</span>&#160;<span class="stringliteral">            or ``coo_matrix``, it will be converted into a sparse</span></div><div class="line"><a name="l00538"></a><span class="lineno">  538</span>&#160;<span class="stringliteral">            ``csr_matrix``.</span></div><div class="line"><a name="l00539"></a><span class="lineno">  539</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l00540"></a><span class="lineno">  540</span>&#160;<span class="stringliteral">        y : Ignored</span></div><div class="line"><a name="l00541"></a><span class="lineno">  541</span>&#160;<span class="stringliteral">            Not used, present here for API consistency by convention.</span></div><div class="line"><a name="l00542"></a><span class="lineno">  542</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l00543"></a><span class="lineno">  543</span>&#160;<span class="stringliteral">        Returns</span></div><div class="line"><a name="l00544"></a><span class="lineno">  544</span>&#160;<span class="stringliteral">        -------</span></div><div class="line"><a name="l00545"></a><span class="lineno">  545</span>&#160;<span class="stringliteral">        labels : ndarray, shape (n_samples,)</span></div><div class="line"><a name="l00546"></a><span class="lineno">  546</span>&#160;<span class="stringliteral">            Cluster labels.</span></div><div class="line"><a name="l00547"></a><span class="lineno">  547</span>&#160;<span class="stringliteral">        &quot;&quot;&quot;</span></div><div class="line"><a name="l00548"></a><span class="lineno">  548</span>&#160;        <span class="keywordflow">return</span> super().fit_predict(X, y)</div><div class="line"><a name="l00549"></a><span class="lineno">  549</span>&#160;</div></div><!-- fragment -->
</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>dsmacc/examples/_spectral.py</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
