<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DSMACC: Network Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">DSMACC
   &#160;<span id="projectnumber">2019</span>
   </div>
   <div id="projectbrief">Changes to DSMACC for the thesis of Daniel Ellis</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classNetwork-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Network Class Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Inheritance diagram for Network:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classNetwork.png" usemap="#Network_map" alt=""/>
  <map id="Network_map" name="Network_map">
<area href="classMemNetwork.html" alt="MemNetwork" shape="rect" coords="0,56,108,80"/>
<area href="classMultiplexNetwork.html" alt="MultiplexNetwork" shape="rect" coords="0,112,108,136"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:abde5619c679349a346350d7c703ef0fb"><td class="memItemLeft" align="right" valign="top"><a id="abde5619c679349a346350d7c703ef0fb"></a>
typedef std::map&lt; unsigned int, std::map&lt; unsigned int, double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>LinkMap</b></td></tr>
<tr class="separator:abde5619c679349a346350d7c703ef0fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a3b0508eeaf582f7dd2f0b1a2a13ce450"><td class="memItemLeft" align="right" valign="top"><a id="a3b0508eeaf582f7dd2f0b1a2a13ce450"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Network</b> (const <a class="el" href="structConfig.html">Config</a> &amp;config)</td></tr>
<tr class="separator:a3b0508eeaf582f7dd2f0b1a2a13ce450"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c725e5f622a1720e3b3c66d93b0ad9d"><td class="memItemLeft" align="right" valign="top"><a id="a9c725e5f622a1720e3b3c66d93b0ad9d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Network</b> (const <a class="el" href="classNetwork.html">Network</a> &amp;other)</td></tr>
<tr class="separator:a9c725e5f622a1720e3b3c66d93b0ad9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2a7d8b707e10e925b56e3e66fda5122"><td class="memItemLeft" align="right" valign="top"><a id="ad2a7d8b707e10e925b56e3e66fda5122"></a>
<a class="el" href="classNetwork.html">Network</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classNetwork.html">Network</a> &amp;other)</td></tr>
<tr class="separator:ad2a7d8b707e10e925b56e3e66fda5122"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ca91774ee60af9aa81cb5de33cc948f"><td class="memItemLeft" align="right" valign="top"><a id="a0ca91774ee60af9aa81cb5de33cc948f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>setConfig</b> (const <a class="el" href="structConfig.html">Config</a> &amp;config)</td></tr>
<tr class="separator:a0ca91774ee60af9aa81cb5de33cc948f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafccd84af6d788277c2f24654d9516c3"><td class="memItemLeft" align="right" valign="top"><a id="aafccd84af6d788277c2f24654d9516c3"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>readInputData</b> (std::string filename=&quot;&quot;)</td></tr>
<tr class="separator:aafccd84af6d788277c2f24654d9516c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a260ae396166c4c241494dc30924c3b9d"><td class="memItemLeft" align="right" valign="top"><a id="a260ae396166c4c241494dc30924c3b9d"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>addNodes</b> (const std::vector&lt; std::string &gt; &amp;names)</td></tr>
<tr class="separator:a260ae396166c4c241494dc30924c3b9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cca2d066f46f2ddf995d813b9239d95"><td class="memItemLeft" align="right" valign="top"><a id="a3cca2d066f46f2ddf995d813b9239d95"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>addNode</b> (unsigned int nodeIndex)</td></tr>
<tr class="separator:a3cca2d066f46f2ddf995d813b9239d95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a234269b2addadc7c79f8c0cc43b0b960"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNetwork.html#a234269b2addadc7c79f8c0cc43b0b960">addLink</a> (unsigned int n1, unsigned int n2, double weight=1.0)</td></tr>
<tr class="separator:a234269b2addadc7c79f8c0cc43b0b960"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a548fca981d51677d90d447cdbf9468d4"><td class="memItemLeft" align="right" valign="top"><a id="a548fca981d51677d90d447cdbf9468d4"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>addBipartiteLink</b> (unsigned int n1, unsigned int n2, double weight=1.0)</td></tr>
<tr class="separator:a548fca981d51677d90d447cdbf9468d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e22b758aa97e5031f1af043572bfd00"><td class="memItemLeft" align="right" valign="top"><a id="a7e22b758aa97e5031f1af043572bfd00"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>addBipartiteLink</b> (unsigned int featureNode, unsigned int <a class="el" href="structnode.html">node</a>, bool swapOrder, double weight=1.0)</td></tr>
<tr class="separator:a7e22b758aa97e5031f1af043572bfd00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ebe3a5e948fc60e81fb94df08ca4358"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNetwork.html#a7ebe3a5e948fc60e81fb94df08ca4358">setBipartiteNodesFrom</a> (unsigned int bipartiteStartIndex)</td></tr>
<tr class="separator:a7ebe3a5e948fc60e81fb94df08ca4358"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2e5a12947f9983b6193d593ec329a5f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNetwork.html#ac2e5a12947f9983b6193d593ec329a5f">finalizeAndCheckNetwork</a> (bool printSummary=true, unsigned int desiredNumberOfNodes=0)</td></tr>
<tr class="separator:ac2e5a12947f9983b6193d593ec329a5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abba53293f1ec45c5e701427e106a8ae4"><td class="memItemLeft" align="right" valign="top"><a id="abba53293f1ec45c5e701427e106a8ae4"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>printParsingResult</b> (bool onlySummary=false)</td></tr>
<tr class="separator:abba53293f1ec45c5e701427e106a8ae4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa469da1457cd376313eac5e30cb16b95"><td class="memItemLeft" align="right" valign="top"><a id="aa469da1457cd376313eac5e30cb16b95"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>getParsingResultSummary</b> ()</td></tr>
<tr class="separator:aa469da1457cd376313eac5e30cb16b95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf286e55a24a445669b5b08ffbc76951"><td class="memItemLeft" align="right" valign="top"><a id="abf286e55a24a445669b5b08ffbc76951"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>printNetworkAsPajek</b> (std::string filename) const</td></tr>
<tr class="separator:abf286e55a24a445669b5b08ffbc76951"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59cc353c1629bbf374db045d19ebd4f1"><td class="memItemLeft" align="right" valign="top"><a id="a59cc353c1629bbf374db045d19ebd4f1"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>printStateNetwork</b> (std::string filename) const</td></tr>
<tr class="separator:a59cc353c1629bbf374db045d19ebd4f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4585dd1f2500f16d729096878228942"><td class="memItemLeft" align="right" valign="top"><a id="ab4585dd1f2500f16d729096878228942"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>numNodes</b> () const</td></tr>
<tr class="separator:ab4585dd1f2500f16d729096878228942"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21976797f095a6de32ee40b6c7e39fe6"><td class="memItemLeft" align="right" valign="top"><a id="a21976797f095a6de32ee40b6c7e39fe6"></a>
const std::vector&lt; std::string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>nodeNames</b> () const</td></tr>
<tr class="separator:a21976797f095a6de32ee40b6c7e39fe6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a169fbca9d6d0bf7be4afcef36906d197"><td class="memItemLeft" align="right" valign="top"><a id="a169fbca9d6d0bf7be4afcef36906d197"></a>
const std::vector&lt; double &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>nodeWeights</b> () const</td></tr>
<tr class="separator:a169fbca9d6d0bf7be4afcef36906d197"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70506aeb202e073077967e9090fc7c70"><td class="memItemLeft" align="right" valign="top"><a id="a70506aeb202e073077967e9090fc7c70"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>sumNodeWeights</b> () const</td></tr>
<tr class="separator:a70506aeb202e073077967e9090fc7c70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96d7528557fc09561891eeda76499063"><td class="memItemLeft" align="right" valign="top"><a id="a96d7528557fc09561891eeda76499063"></a>
const std::vector&lt; double &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>outDegree</b> () const</td></tr>
<tr class="separator:a96d7528557fc09561891eeda76499063"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad0c228dcbdb36d0bd14ca518bab268b"><td class="memItemLeft" align="right" valign="top"><a id="aad0c228dcbdb36d0bd14ca518bab268b"></a>
const std::vector&lt; double &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>sumLinkOutWeight</b> () const</td></tr>
<tr class="separator:aad0c228dcbdb36d0bd14ca518bab268b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed19d67bf781dc9f8d2420111c1160b6"><td class="memItemLeft" align="right" valign="top"><a id="aed19d67bf781dc9f8d2420111c1160b6"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>haveNode</b> (unsigned int nodeIndex) const</td></tr>
<tr class="separator:aed19d67bf781dc9f8d2420111c1160b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13284a11be1a37744f1c8014f940cd35"><td class="memItemLeft" align="right" valign="top"><a id="a13284a11be1a37744f1c8014f940cd35"></a>
const LinkMap &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>linkMap</b> () const</td></tr>
<tr class="separator:a13284a11be1a37744f1c8014f940cd35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae88d213dc2567782a7c32b2d7649f465"><td class="memItemLeft" align="right" valign="top"><a id="ae88d213dc2567782a7c32b2d7649f465"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>numLinks</b> () const</td></tr>
<tr class="separator:ae88d213dc2567782a7c32b2d7649f465"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c0e2b1a5f11881052da39e53c4dce8c"><td class="memItemLeft" align="right" valign="top"><a id="a8c0e2b1a5f11881052da39e53c4dce8c"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>totalLinkWeight</b> () const</td></tr>
<tr class="separator:a8c0e2b1a5f11881052da39e53c4dce8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e9a8b0aa41a75037868cf05af24e5c7"><td class="memItemLeft" align="right" valign="top"><a id="a8e9a8b0aa41a75037868cf05af24e5c7"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>totalSelfLinkWeight</b> () const</td></tr>
<tr class="separator:a8e9a8b0aa41a75037868cf05af24e5c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae605ef1109ddf7f13dcd94b1f03a4a68"><td class="memItemLeft" align="right" valign="top"><a id="ae605ef1109ddf7f13dcd94b1f03a4a68"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isBipartite</b> () const</td></tr>
<tr class="separator:ae605ef1109ddf7f13dcd94b1f03a4a68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99580240387afa26f4c4f8eab12d2122"><td class="memItemLeft" align="right" valign="top"><a id="a99580240387afa26f4c4f8eab12d2122"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>numBipartiteNodes</b> () const</td></tr>
<tr class="separator:a99580240387afa26f4c4f8eab12d2122"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa36b11b8e6ae0f7e123f299a5c18dd6"><td class="memItemLeft" align="right" valign="top"><a id="afa36b11b8e6ae0f7e123f299a5c18dd6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>initNodeNames</b> ()</td></tr>
<tr class="separator:afa36b11b8e6ae0f7e123f299a5c18dd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48972511b804b9f3e24e5acef580d149"><td class="memItemLeft" align="right" valign="top"><a id="a48972511b804b9f3e24e5acef580d149"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>swapNodeNames</b> (std::vector&lt; std::string &gt; &amp;target)</td></tr>
<tr class="separator:a48972511b804b9f3e24e5acef580d149"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a202d38d6cbd9f06cbd9cdddec14c7680"><td class="memItemLeft" align="right" valign="top"><a id="a202d38d6cbd9f06cbd9cdddec14c7680"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>generateOppositeLinkMap</b> (LinkMap &amp;oppositeLinks)</td></tr>
<tr class="separator:a202d38d6cbd9f06cbd9cdddec14c7680"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a608f4113f8e7558bcf7a7991b9c61f18"><td class="memItemLeft" align="right" valign="top"><a id="a608f4113f8e7558bcf7a7991b9c61f18"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>disposeLinks</b> ()</td></tr>
<tr class="separator:a608f4113f8e7558bcf7a7991b9c61f18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47390453870914536a44d2404e0b9b85"><td class="memItemLeft" align="right" valign="top"><a id="a47390453870914536a44d2404e0b9b85"></a>
const <a class="el" href="structConfig.html">Config</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>config</b> ()</td></tr>
<tr class="separator:a47390453870914536a44d2404e0b9b85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93b6b65d803d62bd019e830fc1d074a7"><td class="memItemLeft" align="right" valign="top"><a id="a93b6b65d803d62bd019e830fc1d074a7"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isFinalized</b> ()</td></tr>
<tr class="separator:a93b6b65d803d62bd019e830fc1d074a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a0ac4e9ce5d7fc30ded0b85792e3b0da5"><td class="memItemLeft" align="right" valign="top"><a id="a0ac4e9ce5d7fc30ded0b85792e3b0da5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>parsePajekNetwork</b> (std::string filename)</td></tr>
<tr class="separator:a0ac4e9ce5d7fc30ded0b85792e3b0da5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0dcaf8e7724f3f18bc163e6024faa96"><td class="memItemLeft" align="right" valign="top"><a id="aa0dcaf8e7724f3f18bc163e6024faa96"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>parseLinkList</b> (std::string filename)</td></tr>
<tr class="separator:aa0dcaf8e7724f3f18bc163e6024faa96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae503c3447d73184ca5a29bc93be66d31"><td class="memItemLeft" align="right" valign="top"><a id="ae503c3447d73184ca5a29bc93be66d31"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>parseSparseLinkList</b> (std::string filename)</td></tr>
<tr class="separator:ae503c3447d73184ca5a29bc93be66d31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4eb401b096fb37813afb56c150301be2"><td class="memItemLeft" align="right" valign="top"><a id="a4eb401b096fb37813afb56c150301be2"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>parsePajekNetworkWithoutIOStreams</b> (std::string filename)</td></tr>
<tr class="separator:a4eb401b096fb37813afb56c150301be2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56904b5b0171dc6d61be8900b2e7bcbd"><td class="memItemLeft" align="right" valign="top"><a id="a56904b5b0171dc6d61be8900b2e7bcbd"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>parseLinkListWithoutIOStreams</b> (std::string filename)</td></tr>
<tr class="separator:a56904b5b0171dc6d61be8900b2e7bcbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a641c8ebdfeb4f1db5102624fb46cd6b1"><td class="memItemLeft" align="right" valign="top"><a id="a641c8ebdfeb4f1db5102624fb46cd6b1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>parseGeneralNetwork</b> (std::string filename)</td></tr>
<tr class="separator:a641c8ebdfeb4f1db5102624fb46cd6b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47aeb2ec640e9d27dcff357711a704ee"><td class="memItemLeft" align="right" valign="top"><a id="a47aeb2ec640e9d27dcff357711a704ee"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>parseBipartiteNetwork</b> (std::string filename)</td></tr>
<tr class="separator:a47aeb2ec640e9d27dcff357711a704ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeedd55311935f1f4b7f7b0c523b46a6b"><td class="memItemLeft" align="right" valign="top"><a id="aeedd55311935f1f4b7f7b0c523b46a6b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>zoom</b> ()</td></tr>
<tr class="separator:aeedd55311935f1f4b7f7b0c523b46a6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cec3dfb346c1e29a48704ec32dedf9c"><td class="memItemLeft" align="right" valign="top"><a id="a8cec3dfb346c1e29a48704ec32dedf9c"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>parseLinks</b> (std::ifstream &amp;file)</td></tr>
<tr class="separator:a8cec3dfb346c1e29a48704ec32dedf9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00c9f0be21dfae4626b7e0f36ae30618"><td class="memItemLeft" align="right" valign="top"><a id="a00c9f0be21dfae4626b7e0f36ae30618"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>parseBipartiteLinks</b> (std::ifstream &amp;file)</td></tr>
<tr class="separator:a00c9f0be21dfae4626b7e0f36ae30618"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06e77b2e70073abda5ef39bdb2e0680a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNetwork.html#a06e77b2e70073abda5ef39bdb2e0680a">parseLink</a> (const std::string &amp;line, unsigned int &amp;n1, unsigned int &amp;n2, double &amp;weight)</td></tr>
<tr class="separator:a06e77b2e70073abda5ef39bdb2e0680a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a507153c3021412d7d4484b02cd5eeac2"><td class="memItemLeft" align="right" valign="top"><a id="a507153c3021412d7d4484b02cd5eeac2"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>parseLink</b> (char line[], unsigned int &amp;n1, unsigned int &amp;n2, double &amp;weight)</td></tr>
<tr class="separator:a507153c3021412d7d4484b02cd5eeac2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73f3d0596eabc17748ce76ef276317d3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNetwork.html#a73f3d0596eabc17748ce76ef276317d3">parseBipartiteLink</a> (const std::string &amp;line, unsigned int &amp;featureNode, unsigned int &amp;<a class="el" href="structnode.html">node</a>, double &amp;weight)</td></tr>
<tr class="separator:a73f3d0596eabc17748ce76ef276317d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace5fa3249715ed1b840fa733976aa57b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNetwork.html#ace5fa3249715ed1b840fa733976aa57b">insertLink</a> (unsigned int n1, unsigned int n2, double weight)</td></tr>
<tr class="separator:ace5fa3249715ed1b840fa733976aa57b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a121d0db867b29c99e6e95ef960fcd56f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNetwork.html#a121d0db867b29c99e6e95ef960fcd56f">insertNode</a> (unsigned int nodeIndex)</td></tr>
<tr class="separator:a121d0db867b29c99e6e95ef960fcd56f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67a802002ffc608d226d65b9f68b651e"><td class="memItemLeft" align="right" valign="top"><a id="a67a802002ffc608d226d65b9f68b651e"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>initNodeDegrees</b> ()</td></tr>
<tr class="separator:a67a802002ffc608d226d65b9f68b651e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd458fbfc07fc12e8ca3d6ec4e6a7291"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNetwork.html#afd458fbfc07fc12e8ca3d6ec4e6a7291">skipUntilHeader</a> (std::ifstream &amp;file)</td></tr>
<tr class="separator:afd458fbfc07fc12e8ca3d6ec4e6a7291"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57b99ecccedc6200838163fa3b1ad252"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNetwork.html#a57b99ecccedc6200838163fa3b1ad252">parseVertices</a> (std::ifstream &amp;file, bool required=true)</td></tr>
<tr class="separator:a57b99ecccedc6200838163fa3b1ad252"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cec6b6daa66f112a70bc97c9c28fbc0"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNetwork.html#a5cec6b6daa66f112a70bc97c9c28fbc0">parseVertices</a> (std::ifstream &amp;file, std::string heading, bool required=true)</td></tr>
<tr class="separator:a5cec6b6daa66f112a70bc97c9c28fbc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a4e804bbdb49f3d6b61424da9d2631668"><td class="memItemLeft" align="right" valign="top"><a id="a4e804bbdb49f3d6b61424da9d2631668"></a>
<a class="el" href="structConfig.html">Config</a>&#160;</td><td class="memItemRight" valign="bottom"><b>m_config</b></td></tr>
<tr class="separator:a4e804bbdb49f3d6b61424da9d2631668"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b78eccd117b8dad6b09cccec682a4d8"><td class="memItemLeft" align="right" valign="top"><a id="a6b78eccd117b8dad6b09cccec682a4d8"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>m_numNodesFound</b></td></tr>
<tr class="separator:a6b78eccd117b8dad6b09cccec682a4d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae539ca2af09a33f50a645862f3d45066"><td class="memItemLeft" align="right" valign="top"><a id="ae539ca2af09a33f50a645862f3d45066"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>m_numNodes</b></td></tr>
<tr class="separator:ae539ca2af09a33f50a645862f3d45066"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a889a68a5d059237119d6fea176b56da8"><td class="memItemLeft" align="right" valign="top"><a id="a889a68a5d059237119d6fea176b56da8"></a>
std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>m_nodeNames</b></td></tr>
<tr class="separator:a889a68a5d059237119d6fea176b56da8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac00cd6865db2dce075af1e46df45cefc"><td class="memItemLeft" align="right" valign="top"><a id="ac00cd6865db2dce075af1e46df45cefc"></a>
std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>m_nodeWeights</b></td></tr>
<tr class="separator:ac00cd6865db2dce075af1e46df45cefc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10f2a6a98453c5e3a8aaadbfdbd7f99d"><td class="memItemLeft" align="right" valign="top"><a id="a10f2a6a98453c5e3a8aaadbfdbd7f99d"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>m_sumNodeWeights</b></td></tr>
<tr class="separator:a10f2a6a98453c5e3a8aaadbfdbd7f99d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbb0d2ba1256d2059c9d33b695a7656a"><td class="memItemLeft" align="right" valign="top"><a id="adbb0d2ba1256d2059c9d33b695a7656a"></a>
std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>m_outDegree</b></td></tr>
<tr class="separator:adbb0d2ba1256d2059c9d33b695a7656a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b7d73fd01e7c6f99365cd4e0fe56ba0"><td class="memItemLeft" align="right" valign="top"><a id="a9b7d73fd01e7c6f99365cd4e0fe56ba0"></a>
std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>m_sumLinkOutWeight</b></td></tr>
<tr class="separator:a9b7d73fd01e7c6f99365cd4e0fe56ba0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01a423d5d1bb3d5d76121394b54f1597"><td class="memItemLeft" align="right" valign="top"><a id="a01a423d5d1bb3d5d76121394b54f1597"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>m_numDanglingNodes</b></td></tr>
<tr class="separator:a01a423d5d1bb3d5d76121394b54f1597"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1bcf1f8cdee488a9d081a05b5fb40ea"><td class="memItemLeft" align="right" valign="top"><a id="aa1bcf1f8cdee488a9d081a05b5fb40ea"></a>
std::set&lt; unsigned int &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>m_nodes</b></td></tr>
<tr class="separator:aa1bcf1f8cdee488a9d081a05b5fb40ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a405b5ada50d270ae69d1db7fd276406a"><td class="memItemLeft" align="right" valign="top"><a id="a405b5ada50d270ae69d1db7fd276406a"></a>
LinkMap&#160;</td><td class="memItemRight" valign="bottom"><b>m_links</b></td></tr>
<tr class="separator:a405b5ada50d270ae69d1db7fd276406a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7c780d54802ce7e157809aa8845b987"><td class="memItemLeft" align="right" valign="top"><a id="ab7c780d54802ce7e157809aa8845b987"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>m_numLinksFound</b></td></tr>
<tr class="separator:ab7c780d54802ce7e157809aa8845b987"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36519dd304e83f04ecb94acf4fcd5c94"><td class="memItemLeft" align="right" valign="top"><a id="a36519dd304e83f04ecb94acf4fcd5c94"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>m_numLinks</b></td></tr>
<tr class="separator:a36519dd304e83f04ecb94acf4fcd5c94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9318381e49235c2e97e4712a48558f4b"><td class="memItemLeft" align="right" valign="top"><a id="a9318381e49235c2e97e4712a48558f4b"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>m_totalLinkWeight</b></td></tr>
<tr class="separator:a9318381e49235c2e97e4712a48558f4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae75baccb62375113dfdfbfeb4632c9d8"><td class="memItemLeft" align="right" valign="top"><a id="ae75baccb62375113dfdfbfeb4632c9d8"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>m_numAggregatedLinks</b></td></tr>
<tr class="separator:ae75baccb62375113dfdfbfeb4632c9d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add43682b04697124c2037a877c75569e"><td class="memItemLeft" align="right" valign="top"><a id="add43682b04697124c2037a877c75569e"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>m_numSelfLinks</b></td></tr>
<tr class="separator:add43682b04697124c2037a877c75569e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a261b839d65cc6f451b89331b81cfe4"><td class="memItemLeft" align="right" valign="top"><a id="a5a261b839d65cc6f451b89331b81cfe4"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>m_numSelfLinksFound</b></td></tr>
<tr class="separator:a5a261b839d65cc6f451b89331b81cfe4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefa3790d78ab7b69a0bdb764d3e832ed"><td class="memItemLeft" align="right" valign="top"><a id="aefa3790d78ab7b69a0bdb764d3e832ed"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>m_totalSelfLinkWeight</b></td></tr>
<tr class="separator:aefa3790d78ab7b69a0bdb764d3e832ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57fbd8f3f1b0d134a978a75284a1f415"><td class="memItemLeft" align="right" valign="top"><a id="a57fbd8f3f1b0d134a978a75284a1f415"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>m_numLinksIgnoredByWeightThreshold</b></td></tr>
<tr class="separator:a57fbd8f3f1b0d134a978a75284a1f415"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a709c9d7e3a4d27bfe4ac20ce322ef8e9"><td class="memItemLeft" align="right" valign="top"><a id="a709c9d7e3a4d27bfe4ac20ce322ef8e9"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>m_totalLinkWeightIgnored</b></td></tr>
<tr class="separator:a709c9d7e3a4d27bfe4ac20ce322ef8e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab76c0603719b376a0ea1ed7653725bc6"><td class="memItemLeft" align="right" valign="top"><a id="ab76c0603719b376a0ea1ed7653725bc6"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>m_addSelfLinks</b></td></tr>
<tr class="separator:ab76c0603719b376a0ea1ed7653725bc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56f2ad06a21236bfdbd0c97cacbfbefa"><td class="memItemLeft" align="right" valign="top"><a id="a56f2ad06a21236bfdbd0c97cacbfbefa"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>m_numAdditionalLinks</b></td></tr>
<tr class="separator:a56f2ad06a21236bfdbd0c97cacbfbefa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bc3ebc1347d25d3ea6d81d858d7b670"><td class="memItemLeft" align="right" valign="top"><a id="a4bc3ebc1347d25d3ea6d81d858d7b670"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>m_sumAdditionalLinkWeight</b></td></tr>
<tr class="separator:a4bc3ebc1347d25d3ea6d81d858d7b670"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5de3bef1bba7450b72a17f556aaaa1b4"><td class="memItemLeft" align="right" valign="top"><a id="a5de3bef1bba7450b72a17f556aaaa1b4"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>m_maxNodeIndex</b></td></tr>
<tr class="separator:a5de3bef1bba7450b72a17f556aaaa1b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39c79f64f435a5ee02ebd6585d7658fe"><td class="memItemLeft" align="right" valign="top"><a id="a39c79f64f435a5ee02ebd6585d7658fe"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>m_minNodeIndex</b></td></tr>
<tr class="separator:a39c79f64f435a5ee02ebd6585d7658fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3233fe41d3c488944b724c125549480a"><td class="memItemLeft" align="right" valign="top"><a id="a3233fe41d3c488944b724c125549480a"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>m_minFeatureIndex</b></td></tr>
<tr class="separator:a3233fe41d3c488944b724c125549480a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2597b393fbfad6333d51ed9f6464ea93"><td class="memItemLeft" align="right" valign="top"><a id="a2597b393fbfad6333d51ed9f6464ea93"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>m_bipartiteStartIndex</b></td></tr>
<tr class="separator:a2597b393fbfad6333d51ed9f6464ea93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c09a5df251f92e45420a852ff0408a5"><td class="memItemLeft" align="right" valign="top"><a id="a6c09a5df251f92e45420a852ff0408a5"></a>
std::istringstream&#160;</td><td class="memItemRight" valign="bottom"><b>m_extractor</b></td></tr>
<tr class="separator:a6c09a5df251f92e45420a852ff0408a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9576e46072b091e3a97d4e5303512e72"><td class="memItemLeft" align="right" valign="top"><a id="a9576e46072b091e3a97d4e5303512e72"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>m_indexOffset</b></td></tr>
<tr class="separator:a9576e46072b091e3a97d4e5303512e72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0889972bee522f5b3a8f39fc0769f29f"><td class="memItemLeft" align="right" valign="top"><a id="a0889972bee522f5b3a8f39fc0769f29f"></a>
std::map&lt; <a class="el" href="structBipartiteLink.html">BipartiteLink</a>, <a class="el" href="structWeight.html">Weight</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>m_bipartiteLinks</b></td></tr>
<tr class="separator:a0889972bee522f5b3a8f39fc0769f29f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a088ea8185bc99389e16725dc405a483f"><td class="memItemLeft" align="right" valign="top"><a id="a088ea8185bc99389e16725dc405a483f"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>m_numBipartiteNodes</b></td></tr>
<tr class="separator:a088ea8185bc99389e16725dc405a483f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7536a6430df2349c3b3775bd4407be96"><td class="memItemLeft" align="right" valign="top"><a id="a7536a6430df2349c3b3775bd4407be96"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>m_isFinalized</b></td></tr>
<tr class="separator:a7536a6430df2349c3b3775bd4407be96"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a234269b2addadc7c79f8c0cc43b0b960"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a234269b2addadc7c79f8c0cc43b0b960">&#9670;&nbsp;</a></span>addLink()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Network::addLink </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>weight</em> = <code>1.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add a weighted link between two nodes. </p><dl class="section return"><dt>Returns</dt><dd>true if a new link was inserted, false if skipped due to cutoff limit or aggregated to existing link </dd></dl>
<div class="fragment"><div class="line"><a name="l00643"></a><span class="lineno">  643</span>&#160;{</div><div class="line"><a name="l00644"></a><span class="lineno">  644</span>&#160;    <span class="keywordflow">if</span> (isBipartite()) {</div><div class="line"><a name="l00645"></a><span class="lineno">  645</span>&#160;        <span class="keywordflow">return</span> addBipartiteLink(n1, n2, weight);</div><div class="line"><a name="l00646"></a><span class="lineno">  646</span>&#160;    }</div><div class="line"><a name="l00647"></a><span class="lineno">  647</span>&#160;    ++m_numLinksFound;</div><div class="line"><a name="l00648"></a><span class="lineno">  648</span>&#160;</div><div class="line"><a name="l00649"></a><span class="lineno">  649</span>&#160;    <span class="keywordflow">if</span> (m_config.nodeLimit &gt; 0 &amp;&amp; (n1 &gt;= m_config.nodeLimit || n2 &gt;= m_config.nodeLimit))</div><div class="line"><a name="l00650"></a><span class="lineno">  650</span>&#160;        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l00651"></a><span class="lineno">  651</span>&#160;    </div><div class="line"><a name="l00652"></a><span class="lineno">  652</span>&#160;    <span class="keywordflow">if</span> (weight &lt; m_config.weightThreshold) {</div><div class="line"><a name="l00653"></a><span class="lineno">  653</span>&#160;        ++m_numLinksIgnoredByWeightThreshold;</div><div class="line"><a name="l00654"></a><span class="lineno">  654</span>&#160;        m_totalLinkWeightIgnored += weight;</div><div class="line"><a name="l00655"></a><span class="lineno">  655</span>&#160;        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l00656"></a><span class="lineno">  656</span>&#160;    }</div><div class="line"><a name="l00657"></a><span class="lineno">  657</span>&#160;</div><div class="line"><a name="l00658"></a><span class="lineno">  658</span>&#160;    <span class="keywordflow">if</span> (n2 == n1)</div><div class="line"><a name="l00659"></a><span class="lineno">  659</span>&#160;    {</div><div class="line"><a name="l00660"></a><span class="lineno">  660</span>&#160;        ++m_numSelfLinksFound;</div><div class="line"><a name="l00661"></a><span class="lineno">  661</span>&#160;        <span class="keywordflow">if</span> (!m_config.includeSelfLinks)</div><div class="line"><a name="l00662"></a><span class="lineno">  662</span>&#160;            <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l00663"></a><span class="lineno">  663</span>&#160;        ++m_numSelfLinks;</div><div class="line"><a name="l00664"></a><span class="lineno">  664</span>&#160;        m_totalSelfLinkWeight += weight;</div><div class="line"><a name="l00665"></a><span class="lineno">  665</span>&#160;    }</div><div class="line"><a name="l00666"></a><span class="lineno">  666</span>&#160;    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (m_config.parseAsUndirected() &amp;&amp; n2 &lt; n1) <span class="comment">// minimize number of links</span></div><div class="line"><a name="l00667"></a><span class="lineno">  667</span>&#160;        std::swap(n1, n2);</div><div class="line"><a name="l00668"></a><span class="lineno">  668</span>&#160;</div><div class="line"><a name="l00669"></a><span class="lineno">  669</span>&#160;    m_maxNodeIndex = std::max(m_maxNodeIndex, std::max(n1, n2));</div><div class="line"><a name="l00670"></a><span class="lineno">  670</span>&#160;    m_minNodeIndex = std::min(m_minNodeIndex, std::min(n1, n2));</div><div class="line"><a name="l00671"></a><span class="lineno">  671</span>&#160;</div><div class="line"><a name="l00672"></a><span class="lineno">  672</span>&#160;    <a class="code" href="classNetwork.html#ace5fa3249715ed1b840fa733976aa57b">insertLink</a>(n1, n2, weight);</div><div class="line"><a name="l00673"></a><span class="lineno">  673</span>&#160;</div><div class="line"><a name="l00674"></a><span class="lineno">  674</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line"><a name="l00675"></a><span class="lineno">  675</span>&#160;}</div><div class="ttc" id="classNetwork_html_ace5fa3249715ed1b840fa733976aa57b"><div class="ttname"><a href="classNetwork.html#ace5fa3249715ed1b840fa733976aa57b">Network::insertLink</a></div><div class="ttdeci">bool insertLink(unsigned int n1, unsigned int n2, double weight)</div><div class="ttdef"><b>Definition:</b> Network.cpp:713</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ac2e5a12947f9983b6193d593ec329a5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2e5a12947f9983b6193d593ec329a5f">&#9670;&nbsp;</a></span>finalizeAndCheckNetwork()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Network::finalizeAndCheckNetwork </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>printSummary</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>desiredNumberOfNodes</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Run after adding links to check for non-feasible values and set the node count if not specified in the network, and outDegree and sumLinkOutWeight. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">desiredNumberOfNodes</td><td>Set the desired number of nodes, or leave at zero to set it automatically to match the highest node number defined on the links. </td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><a name="l00747"></a><span class="lineno">  747</span>&#160;{</div><div class="line"><a name="l00748"></a><span class="lineno">  748</span>&#160;    m_isFinalized = <span class="keyword">true</span>;</div><div class="line"><a name="l00749"></a><span class="lineno">  749</span>&#160;    <span class="comment">// If no nodes defined</span></div><div class="line"><a name="l00750"></a><span class="lineno">  750</span>&#160;    <span class="keywordflow">if</span> (m_numNodes == 0)</div><div class="line"><a name="l00751"></a><span class="lineno">  751</span>&#160;        m_numNodes = m_numNodesFound = m_maxNodeIndex + 1;</div><div class="line"><a name="l00752"></a><span class="lineno">  752</span>&#160;</div><div class="line"><a name="l00753"></a><span class="lineno">  753</span>&#160;    <span class="keywordflow">if</span> (desiredNumberOfNodes != 0)</div><div class="line"><a name="l00754"></a><span class="lineno">  754</span>&#160;    {</div><div class="line"><a name="l00755"></a><span class="lineno">  755</span>&#160;        <span class="keywordflow">if</span> (!m_nodeNames.empty() &amp;&amp; desiredNumberOfNodes != m_nodeNames.size()) {</div><div class="line"><a name="l00756"></a><span class="lineno">  756</span>&#160;            <span class="comment">// throw InputDomainError(&quot;Can&#39;t change the number of nodes in networks with a specified number of nodes.&quot;);</span></div><div class="line"><a name="l00757"></a><span class="lineno">  757</span>&#160;            m_nodeNames.reserve(desiredNumberOfNodes);</div><div class="line"><a name="l00758"></a><span class="lineno">  758</span>&#160;            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = m_nodeNames.size(); i &lt; desiredNumberOfNodes; ++i) {</div><div class="line"><a name="l00759"></a><span class="lineno">  759</span>&#160;                m_nodeNames.push_back(<a class="code" href="classio_1_1Str.html">io::Str</a>() &lt;&lt; <span class="stringliteral">&quot;_completion_node_&quot;</span> &lt;&lt; (i + 1));</div><div class="line"><a name="l00760"></a><span class="lineno">  760</span>&#160;            }</div><div class="line"><a name="l00761"></a><span class="lineno">  761</span>&#160;        }</div><div class="line"><a name="l00762"></a><span class="lineno">  762</span>&#160;        m_numNodes = desiredNumberOfNodes;</div><div class="line"><a name="l00763"></a><span class="lineno">  763</span>&#160;    }</div><div class="line"><a name="l00764"></a><span class="lineno">  764</span>&#160;</div><div class="line"><a name="l00765"></a><span class="lineno">  765</span>&#160;    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> zeroMinusOne = 0;</div><div class="line"><a name="l00766"></a><span class="lineno">  766</span>&#160;    --zeroMinusOne;</div><div class="line"><a name="l00767"></a><span class="lineno">  767</span>&#160;    <span class="keywordflow">if</span> (m_maxNodeIndex == zeroMinusOne)</div><div class="line"><a name="l00768"></a><span class="lineno">  768</span>&#160;        <span class="keywordflow">throw</span> <a class="code" href="classInputDomainError.html">InputDomainError</a>(<a class="code" href="classio_1_1Str.html">io::Str</a>() &lt;&lt; <span class="stringliteral">&quot;Integer overflow, be sure to use zero-based node numbering if the node numbers start from zero.&quot;</span>);</div><div class="line"><a name="l00769"></a><span class="lineno">  769</span>&#160;    <span class="keywordflow">if</span> (m_maxNodeIndex &gt;= m_numNodes)</div><div class="line"><a name="l00770"></a><span class="lineno">  770</span>&#160;        <span class="keywordflow">throw</span> <a class="code" href="classInputDomainError.html">InputDomainError</a>(<a class="code" href="classio_1_1Str.html">io::Str</a>() &lt;&lt; <span class="stringliteral">&quot;At least one link is defined with node numbers that exceeds the number of nodes.&quot;</span>);</div><div class="line"><a name="l00771"></a><span class="lineno">  771</span>&#160;    <span class="keywordflow">if</span> (m_minNodeIndex == 1 &amp;&amp; m_config.zeroBasedNodeNumbers)</div><div class="line"><a name="l00772"></a><span class="lineno">  772</span>&#160;        <a class="code" href="classLog.html">Log</a>() &lt;&lt; <span class="stringliteral">&quot;(Warning: minimum link index is one, check that you don&#39;t use zero based numbering if it&#39;s not true.) &quot;</span>;</div><div class="line"><a name="l00773"></a><span class="lineno">  773</span>&#160;</div><div class="line"><a name="l00774"></a><span class="lineno">  774</span>&#160;    <span class="keywordflow">if</span> (!m_bipartiteLinks.empty())</div><div class="line"><a name="l00775"></a><span class="lineno">  775</span>&#160;    {</div><div class="line"><a name="l00776"></a><span class="lineno">  776</span>&#160;        <span class="keywordflow">if</span> (m_numLinks &gt; 0)</div><div class="line"><a name="l00777"></a><span class="lineno">  777</span>&#160;            <span class="keywordflow">throw</span> <a class="code" href="classInputDomainError.html">InputDomainError</a>(<span class="stringliteral">&quot;Can&#39;t add bipartite links together with ordinary links.&quot;</span>);</div><div class="line"><a name="l00778"></a><span class="lineno">  778</span>&#160;        <span class="keywordflow">if</span> (m_bipartiteStartIndex == std::numeric_limits&lt;unsigned int&gt;::max())</div><div class="line"><a name="l00779"></a><span class="lineno">  779</span>&#160;            m_bipartiteStartIndex = m_maxNodeIndex + 1;</div><div class="line"><a name="l00780"></a><span class="lineno">  780</span>&#160;        <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> featureIndexOffset = 0;</div><div class="line"><a name="l00781"></a><span class="lineno">  781</span>&#160;        <span class="keywordflow">if</span> (m_minFeatureIndex &lt; m_bipartiteStartIndex) {</div><div class="line"><a name="l00782"></a><span class="lineno">  782</span>&#160;            featureIndexOffset = m_bipartiteStartIndex;</div><div class="line"><a name="l00783"></a><span class="lineno">  783</span>&#160;        }</div><div class="line"><a name="l00784"></a><span class="lineno">  784</span>&#160;        <span class="keywordflow">for</span> (std::map&lt;BipartiteLink, Weight&gt;::iterator it(m_bipartiteLinks.begin()); it != m_bipartiteLinks.end(); ++it)</div><div class="line"><a name="l00785"></a><span class="lineno">  785</span>&#160;        {</div><div class="line"><a name="l00786"></a><span class="lineno">  786</span>&#160;            <span class="keyword">const</span> <a class="code" href="structBipartiteLink.html">BipartiteLink</a>&amp; link = it-&gt;first;</div><div class="line"><a name="l00787"></a><span class="lineno">  787</span>&#160;            <span class="comment">// Offset feature nodes by the number of ordinary nodes to make them unique</span></div><div class="line"><a name="l00788"></a><span class="lineno">  788</span>&#160;            <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> featureNodeIndex = link.featureNode + featureIndexOffset;</div><div class="line"><a name="l00789"></a><span class="lineno">  789</span>&#160;            m_maxNodeIndex = std::max(m_maxNodeIndex, featureNodeIndex);</div><div class="line"><a name="l00790"></a><span class="lineno">  790</span>&#160;            <span class="keywordflow">if</span> (link.swapOrder)</div><div class="line"><a name="l00791"></a><span class="lineno">  791</span>&#160;                <a class="code" href="classNetwork.html#ace5fa3249715ed1b840fa733976aa57b">insertLink</a>(link.node, featureNodeIndex, it-&gt;second.weight);</div><div class="line"><a name="l00792"></a><span class="lineno">  792</span>&#160;            <span class="keywordflow">else</span></div><div class="line"><a name="l00793"></a><span class="lineno">  793</span>&#160;                <a class="code" href="classNetwork.html#ace5fa3249715ed1b840fa733976aa57b">insertLink</a>(featureNodeIndex, link.node, it-&gt;second.weight);</div><div class="line"><a name="l00794"></a><span class="lineno">  794</span>&#160;        }</div><div class="line"><a name="l00795"></a><span class="lineno">  795</span>&#160;        m_numBipartiteNodes = m_maxNodeIndex + 1 - m_numNodes;</div><div class="line"><a name="l00796"></a><span class="lineno">  796</span>&#160;        m_numNodes += m_numBipartiteNodes;</div><div class="line"><a name="l00797"></a><span class="lineno">  797</span>&#160;    }</div><div class="line"><a name="l00798"></a><span class="lineno">  798</span>&#160;</div><div class="line"><a name="l00799"></a><span class="lineno">  799</span>&#160;    <span class="keywordflow">if</span> (m_links.empty())</div><div class="line"><a name="l00800"></a><span class="lineno">  800</span>&#160;        <span class="keywordflow">throw</span> <a class="code" href="classInputDomainError.html">InputDomainError</a>(<span class="stringliteral">&quot;No links added!&quot;</span>);</div><div class="line"><a name="l00801"></a><span class="lineno">  801</span>&#160;</div><div class="line"><a name="l00802"></a><span class="lineno">  802</span>&#160;    <span class="keywordflow">if</span> (m_addSelfLinks)</div><div class="line"><a name="l00803"></a><span class="lineno">  803</span>&#160;        zoom();</div><div class="line"><a name="l00804"></a><span class="lineno">  804</span>&#160;</div><div class="line"><a name="l00805"></a><span class="lineno">  805</span>&#160;    initNodeDegrees();</div><div class="line"><a name="l00806"></a><span class="lineno">  806</span>&#160;</div><div class="line"><a name="l00807"></a><span class="lineno">  807</span>&#160;    <span class="keywordflow">if</span> (printSummary)</div><div class="line"><a name="l00808"></a><span class="lineno">  808</span>&#160;        printParsingResult();</div><div class="line"><a name="l00809"></a><span class="lineno">  809</span>&#160;}</div><div class="ttc" id="classLog_html"><div class="ttname"><a href="classLog.html">Log</a></div><div class="ttdef"><b>Definition:</b> Logger.h:45</div></div>
<div class="ttc" id="classInputDomainError_html"><div class="ttname"><a href="classInputDomainError.html">InputDomainError</a></div><div class="ttdef"><b>Definition:</b> convert.h:61</div></div>
<div class="ttc" id="structBipartiteLink_html"><div class="ttname"><a href="structBipartiteLink.html">BipartiteLink</a></div><div class="ttdef"><b>Definition:</b> Network.h:358</div></div>
<div class="ttc" id="classNetwork_html_ace5fa3249715ed1b840fa733976aa57b"><div class="ttname"><a href="classNetwork.html#ace5fa3249715ed1b840fa733976aa57b">Network::insertLink</a></div><div class="ttdeci">bool insertLink(unsigned int n1, unsigned int n2, double weight)</div><div class="ttdef"><b>Definition:</b> Network.cpp:713</div></div>
<div class="ttc" id="classio_1_1Str_html"><div class="ttname"><a href="classio_1_1Str.html">io::Str</a></div><div class="ttdef"><b>Definition:</b> convert.h:165</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ace5fa3249715ed1b840fa733976aa57b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace5fa3249715ed1b840fa733976aa57b">&#9670;&nbsp;</a></span>insertLink()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Network::insertLink </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>weight</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Insert ordinary link, indexed on first node and aggregated if exist </p><dl class="section note"><dt>Note</dt><dd>Called by addLink </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>true if a new link was inserted, false if aggregated </dd></dl>
<div class="fragment"><div class="line"><a name="l00714"></a><span class="lineno">  714</span>&#160;{</div><div class="line"><a name="l00715"></a><span class="lineno">  715</span>&#160;    ++m_numLinks;</div><div class="line"><a name="l00716"></a><span class="lineno">  716</span>&#160;    m_totalLinkWeight += weight;</div><div class="line"><a name="l00717"></a><span class="lineno">  717</span>&#160;    <a class="code" href="classNetwork.html#a121d0db867b29c99e6e95ef960fcd56f">insertNode</a>(n1);</div><div class="line"><a name="l00718"></a><span class="lineno">  718</span>&#160;    <a class="code" href="classNetwork.html#a121d0db867b29c99e6e95ef960fcd56f">insertNode</a>(n2);</div><div class="line"><a name="l00719"></a><span class="lineno">  719</span>&#160;</div><div class="line"><a name="l00720"></a><span class="lineno">  720</span>&#160;    <span class="comment">// Aggregate link weights if they are definied more than once</span></div><div class="line"><a name="l00721"></a><span class="lineno">  721</span>&#160;    LinkMap::iterator firstIt = m_links.lower_bound(n1);</div><div class="line"><a name="l00722"></a><span class="lineno">  722</span>&#160;    <span class="keywordflow">if</span> (firstIt != m_links.end() &amp;&amp; firstIt-&gt;first == n1) <span class="comment">// First linkEnd already exists, check second linkEnd</span></div><div class="line"><a name="l00723"></a><span class="lineno">  723</span>&#160;    {</div><div class="line"><a name="l00724"></a><span class="lineno">  724</span>&#160;        std::pair&lt;std::map&lt;unsigned int, double&gt;::iterator, <span class="keywordtype">bool</span>&gt; ret2 = firstIt-&gt;second.insert(std::make_pair(n2, weight));</div><div class="line"><a name="l00725"></a><span class="lineno">  725</span>&#160;        <span class="keywordflow">if</span> (!ret2.second)</div><div class="line"><a name="l00726"></a><span class="lineno">  726</span>&#160;        {</div><div class="line"><a name="l00727"></a><span class="lineno">  727</span>&#160;            ret2.first-&gt;second += weight;</div><div class="line"><a name="l00728"></a><span class="lineno">  728</span>&#160;            ++m_numAggregatedLinks;</div><div class="line"><a name="l00729"></a><span class="lineno">  729</span>&#160;            --m_numLinks;</div><div class="line"><a name="l00730"></a><span class="lineno">  730</span>&#160;            <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l00731"></a><span class="lineno">  731</span>&#160;        }</div><div class="line"><a name="l00732"></a><span class="lineno">  732</span>&#160;    }</div><div class="line"><a name="l00733"></a><span class="lineno">  733</span>&#160;    <span class="keywordflow">else</span></div><div class="line"><a name="l00734"></a><span class="lineno">  734</span>&#160;    {</div><div class="line"><a name="l00735"></a><span class="lineno">  735</span>&#160;        m_links.insert(firstIt, std::make_pair(n1, std::map&lt;unsigned int, double&gt;()))-&gt;second.insert(std::make_pair(n2, weight));</div><div class="line"><a name="l00736"></a><span class="lineno">  736</span>&#160;    }</div><div class="line"><a name="l00737"></a><span class="lineno">  737</span>&#160;</div><div class="line"><a name="l00738"></a><span class="lineno">  738</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line"><a name="l00739"></a><span class="lineno">  739</span>&#160;}</div><div class="ttc" id="classNetwork_html_a121d0db867b29c99e6e95ef960fcd56f"><div class="ttname"><a href="classNetwork.html#a121d0db867b29c99e6e95ef960fcd56f">Network::insertNode</a></div><div class="ttdeci">bool insertNode(unsigned int nodeIndex)</div><div class="ttdef"><b>Definition:</b> Network.cpp:741</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a121d0db867b29c99e6e95ef960fcd56f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a121d0db867b29c99e6e95ef960fcd56f">&#9670;&nbsp;</a></span>insertNode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Network::insertNode </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>nodeIndex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Insert node if not exist </p>
<div class="fragment"><div class="line"><a name="l00742"></a><span class="lineno">  742</span>&#160;{</div><div class="line"><a name="l00743"></a><span class="lineno">  743</span>&#160;    <span class="keywordflow">return</span> m_nodes.insert(nodeIndex).second;</div><div class="line"><a name="l00744"></a><span class="lineno">  744</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a73f3d0596eabc17748ce76ef276317d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73f3d0596eabc17748ce76ef276317d3">&#9670;&nbsp;</a></span>parseBipartiteLink()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Network::parseBipartiteLink </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int &amp;&#160;</td>
          <td class="paramname"><em>featureNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int &amp;&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>weight</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Parse a bipartite link of format "f1 n1 1.0" for a link between feature node 1 to ordinary node 1 with weight 1.0. The order of the feature nodes and ordinary nodes can be swapped. Store the numberical id (minus possible indexOffset for non-zerobased indexing) on the referenced uints. </p><dl class="section return"><dt>Returns</dt><dd>true if the input order was swapped </dd></dl>
<div class="fragment"><div class="line"><a name="l00614"></a><span class="lineno">  614</span>&#160;{</div><div class="line"><a name="l00615"></a><span class="lineno">  615</span>&#160;    <span class="keywordtype">bool</span> swappedOrder = <span class="keyword">false</span>;</div><div class="line"><a name="l00616"></a><span class="lineno">  616</span>&#160;    m_extractor.clear();</div><div class="line"><a name="l00617"></a><span class="lineno">  617</span>&#160;    m_extractor.str(line);</div><div class="line"><a name="l00618"></a><span class="lineno">  618</span>&#160;    std::string fn, n;</div><div class="line"><a name="l00619"></a><span class="lineno">  619</span>&#160;    <span class="keywordflow">if</span> (!(m_extractor &gt;&gt; fn &gt;&gt; n))</div><div class="line"><a name="l00620"></a><span class="lineno">  620</span>&#160;        <span class="keywordflow">throw</span> <a class="code" href="classFileFormatError.html">FileFormatError</a>(<a class="code" href="classio_1_1Str.html">io::Str</a>() &lt;&lt; <span class="stringliteral">&quot;Can&#39;t parse bipartite link data from line &#39;&quot;</span> &lt;&lt; line &lt;&lt; <span class="stringliteral">&quot;&#39;&quot;</span>);</div><div class="line"><a name="l00621"></a><span class="lineno">  621</span>&#160;    (m_extractor &gt;&gt; weight) || (weight = 1.0);</div><div class="line"><a name="l00622"></a><span class="lineno">  622</span>&#160;    <span class="keywordflow">if</span> (fn[0] != <span class="charliteral">&#39;f&#39;</span>) {</div><div class="line"><a name="l00623"></a><span class="lineno">  623</span>&#160;        std::swap(fn, n);</div><div class="line"><a name="l00624"></a><span class="lineno">  624</span>&#160;        swappedOrder = <span class="keyword">true</span>;</div><div class="line"><a name="l00625"></a><span class="lineno">  625</span>&#160;    }</div><div class="line"><a name="l00626"></a><span class="lineno">  626</span>&#160;    <span class="keywordflow">if</span> (fn[0] != <span class="charliteral">&#39;f&#39;</span> || fn.length() == 1 || !(std::istringstream( fn.substr(1) ) &gt;&gt; featureNode))</div><div class="line"><a name="l00627"></a><span class="lineno">  627</span>&#160;        <span class="keywordflow">throw</span> <a class="code" href="classFileFormatError.html">FileFormatError</a>(<a class="code" href="classio_1_1Str.html">io::Str</a>() &lt;&lt; <span class="stringliteral">&quot;Can&#39;t parse bipartite feature node (a numerical id prefixed by &#39;f&#39;) from line &#39;&quot;</span> &lt;&lt; line &lt;&lt; <span class="stringliteral">&quot;&#39;&quot;</span>);</div><div class="line"><a name="l00628"></a><span class="lineno">  628</span>&#160;    <span class="keywordflow">if</span> (n[0] != <span class="charliteral">&#39;n&#39;</span> || n.length() == 1 || !(std::istringstream( n.substr(1) ) &gt;&gt; <a class="code" href="structnode.html">node</a>))</div><div class="line"><a name="l00629"></a><span class="lineno">  629</span>&#160;        <span class="keywordflow">throw</span> <a class="code" href="classFileFormatError.html">FileFormatError</a>(<a class="code" href="classio_1_1Str.html">io::Str</a>() &lt;&lt; <span class="stringliteral">&quot;Can&#39;t parse bipartite ordinary node (a numerical id prefixed by &#39;n&#39;) from line &#39;&quot;</span> &lt;&lt; line &lt;&lt; <span class="stringliteral">&quot;&#39;&quot;</span>);</div><div class="line"><a name="l00630"></a><span class="lineno">  630</span>&#160;</div><div class="line"><a name="l00631"></a><span class="lineno">  631</span>&#160;    featureNode -= m_indexOffset;</div><div class="line"><a name="l00632"></a><span class="lineno">  632</span>&#160;    <a class="code" href="structnode.html">node</a> -= m_indexOffset;</div><div class="line"><a name="l00633"></a><span class="lineno">  633</span>&#160;    <span class="keywordflow">return</span> swappedOrder;</div><div class="line"><a name="l00634"></a><span class="lineno">  634</span>&#160;}</div><div class="ttc" id="structnode_html"><div class="ttname"><a href="structnode.html">node</a></div><div class="ttdef"><b>Definition:</b> code.h:138</div></div>
<div class="ttc" id="classFileFormatError_html"><div class="ttname"><a href="classFileFormatError.html">FileFormatError</a></div><div class="ttdef"><b>Definition:</b> convert.h:56</div></div>
<div class="ttc" id="classio_1_1Str_html"><div class="ttname"><a href="classio_1_1Str.html">io::Str</a></div><div class="ttdef"><b>Definition:</b> convert.h:165</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a06e77b2e70073abda5ef39bdb2e0680a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06e77b2e70073abda5ef39bdb2e0680a">&#9670;&nbsp;</a></span>parseLink()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Network::parseLink </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int &amp;&#160;</td>
          <td class="paramname"><em>n1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int &amp;&#160;</td>
          <td class="paramname"><em>n2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>weight</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Parse a string of link data. If no weight data can be extracted, the default value 1.0 will be used. </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">an</td><td>error if not both node numbers can be extracted. </td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><a name="l00583"></a><span class="lineno">  583</span>&#160;{</div><div class="line"><a name="l00584"></a><span class="lineno">  584</span>&#160;    m_extractor.clear();</div><div class="line"><a name="l00585"></a><span class="lineno">  585</span>&#160;    m_extractor.str(line);</div><div class="line"><a name="l00586"></a><span class="lineno">  586</span>&#160;    <span class="keywordflow">if</span> (!(m_extractor &gt;&gt; n1 &gt;&gt; n2))</div><div class="line"><a name="l00587"></a><span class="lineno">  587</span>&#160;        <span class="keywordflow">throw</span> <a class="code" href="classFileFormatError.html">FileFormatError</a>(<a class="code" href="classio_1_1Str.html">io::Str</a>() &lt;&lt; <span class="stringliteral">&quot;Can&#39;t parse link data from line &#39;&quot;</span> &lt;&lt; line &lt;&lt; <span class="stringliteral">&quot;&#39;&quot;</span>);</div><div class="line"><a name="l00588"></a><span class="lineno">  588</span>&#160;    (m_extractor &gt;&gt; weight) || (weight = 1.0);</div><div class="line"><a name="l00589"></a><span class="lineno">  589</span>&#160;    n1 -= m_indexOffset;</div><div class="line"><a name="l00590"></a><span class="lineno">  590</span>&#160;    n2 -= m_indexOffset;</div><div class="line"><a name="l00591"></a><span class="lineno">  591</span>&#160;}</div><div class="ttc" id="classFileFormatError_html"><div class="ttname"><a href="classFileFormatError.html">FileFormatError</a></div><div class="ttdef"><b>Definition:</b> convert.h:56</div></div>
<div class="ttc" id="classio_1_1Str_html"><div class="ttname"><a href="classio_1_1Str.html">io::Str</a></div><div class="ttdef"><b>Definition:</b> convert.h:165</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a57b99ecccedc6200838163fa3b1ad252"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57b99ecccedc6200838163fa3b1ad252">&#9670;&nbsp;</a></span>parseVertices() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string Network::parseVertices </td>
          <td>(</td>
          <td class="paramtype">std::ifstream &amp;&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>required</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Parse vertices </p><dl class="section return"><dt>Returns</dt><dd>The line after the vertices </dd></dl>
<div class="fragment"><div class="line"><a name="l00407"></a><span class="lineno">  407</span>&#160;{</div><div class="line"><a name="l00408"></a><span class="lineno">  408</span>&#160;    std::string line;</div><div class="line"><a name="l00409"></a><span class="lineno">  409</span>&#160;</div><div class="line"><a name="l00410"></a><span class="lineno">  410</span>&#160;    <span class="comment">// First skip lines until header</span></div><div class="line"><a name="l00411"></a><span class="lineno">  411</span>&#160;    <span class="keywordflow">while</span>(!std::getline(file, line).fail())</div><div class="line"><a name="l00412"></a><span class="lineno">  412</span>&#160;    {</div><div class="line"><a name="l00413"></a><span class="lineno">  413</span>&#160;        <span class="keywordflow">if</span> (line.length() == 0 || line[0] == <span class="charliteral">&#39;#&#39;</span>)</div><div class="line"><a name="l00414"></a><span class="lineno">  414</span>&#160;            <span class="keywordflow">continue</span>;</div><div class="line"><a name="l00415"></a><span class="lineno">  415</span>&#160;        <span class="keywordflow">if</span> (line[0] == <span class="charliteral">&#39;*&#39;</span>)</div><div class="line"><a name="l00416"></a><span class="lineno">  416</span>&#160;            <span class="keywordflow">break</span>;</div><div class="line"><a name="l00417"></a><span class="lineno">  417</span>&#160;    }</div><div class="line"><a name="l00418"></a><span class="lineno">  418</span>&#160;</div><div class="line"><a name="l00419"></a><span class="lineno">  419</span>&#160;    <span class="keywordflow">if</span> (line.length() == 0 || line[0] != <span class="charliteral">&#39;*&#39;</span>)</div><div class="line"><a name="l00420"></a><span class="lineno">  420</span>&#160;        <span class="keywordflow">throw</span> <a class="code" href="classFileFormatError.html">FileFormatError</a>(<span class="stringliteral">&quot;No matching header for vertices found.&quot;</span>);</div><div class="line"><a name="l00421"></a><span class="lineno">  421</span>&#160;</div><div class="line"><a name="l00422"></a><span class="lineno">  422</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="classNetwork.html#a57b99ecccedc6200838163fa3b1ad252">parseVertices</a>(file, line, required);</div><div class="line"><a name="l00423"></a><span class="lineno">  423</span>&#160;}</div><div class="ttc" id="classNetwork_html_a57b99ecccedc6200838163fa3b1ad252"><div class="ttname"><a href="classNetwork.html#a57b99ecccedc6200838163fa3b1ad252">Network::parseVertices</a></div><div class="ttdeci">std::string parseVertices(std::ifstream &amp;file, bool required=true)</div><div class="ttdef"><b>Definition:</b> Network.cpp:406</div></div>
<div class="ttc" id="classFileFormatError_html"><div class="ttname"><a href="classFileFormatError.html">FileFormatError</a></div><div class="ttdef"><b>Definition:</b> convert.h:56</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a5cec6b6daa66f112a70bc97c9c28fbc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cec6b6daa66f112a70bc97c9c28fbc0">&#9670;&nbsp;</a></span>parseVertices() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string Network::parseVertices </td>
          <td>(</td>
          <td class="paramtype">std::ifstream &amp;&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>heading</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>required</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Parse vertices under the heading </p><dl class="section return"><dt>Returns</dt><dd>The line after the vertices </dd></dl>
<div class="fragment"><div class="line"><a name="l00426"></a><span class="lineno">  426</span>&#160;{</div><div class="line"><a name="l00427"></a><span class="lineno">  427</span>&#160;    std::istringstream ss;</div><div class="line"><a name="l00428"></a><span class="lineno">  428</span>&#160;    std::string buf;</div><div class="line"><a name="l00429"></a><span class="lineno">  429</span>&#160;    ss.str(header);</div><div class="line"><a name="l00430"></a><span class="lineno">  430</span>&#160;    ss &gt;&gt; buf;</div><div class="line"><a name="l00431"></a><span class="lineno">  431</span>&#160;    <span class="keywordflow">if</span>(buf == <span class="stringliteral">&quot;*Vertices&quot;</span> || buf == <span class="stringliteral">&quot;*vertices&quot;</span> || buf == <span class="stringliteral">&quot;*VERTICES&quot;</span>) {</div><div class="line"><a name="l00432"></a><span class="lineno">  432</span>&#160;        <span class="keywordflow">if</span> (!(ss &gt;&gt; m_numNodesFound))</div><div class="line"><a name="l00433"></a><span class="lineno">  433</span>&#160;            <span class="keywordflow">throw</span> <a class="code" href="classBadConversionError.html">BadConversionError</a>(<a class="code" href="classio_1_1Str.html">io::Str</a>() &lt;&lt; <span class="stringliteral">&quot;Can&#39;t parse an integer after &#39;&quot;</span> &lt;&lt; buf &lt;&lt;</div><div class="line"><a name="l00434"></a><span class="lineno">  434</span>&#160;                    <span class="stringliteral">&quot;&#39; as the number of nodes.&quot;</span>);</div><div class="line"><a name="l00435"></a><span class="lineno">  435</span>&#160;    }</div><div class="line"><a name="l00436"></a><span class="lineno">  436</span>&#160;    <span class="keywordflow">else</span> {</div><div class="line"><a name="l00437"></a><span class="lineno">  437</span>&#160;        <span class="keywordflow">if</span> (!required)</div><div class="line"><a name="l00438"></a><span class="lineno">  438</span>&#160;            <span class="keywordflow">return</span> header;</div><div class="line"><a name="l00439"></a><span class="lineno">  439</span>&#160;        <span class="keywordflow">throw</span> <a class="code" href="classFileFormatError.html">FileFormatError</a>(<a class="code" href="classio_1_1Str.html">io::Str</a>() &lt;&lt; <span class="stringliteral">&quot;The header &#39;&quot;</span> &lt;&lt; header &lt;&lt; <span class="stringliteral">&quot;&#39; doesn&#39;t match *Vertices (case insensitive).&quot;</span>);</div><div class="line"><a name="l00440"></a><span class="lineno">  440</span>&#160;    }</div><div class="line"><a name="l00441"></a><span class="lineno">  441</span>&#160;</div><div class="line"><a name="l00442"></a><span class="lineno">  442</span>&#160;    <span class="keywordflow">if</span> (m_numNodesFound == 0)</div><div class="line"><a name="l00443"></a><span class="lineno">  443</span>&#160;        <span class="keywordflow">throw</span> <a class="code" href="classFileFormatError.html">FileFormatError</a>(<span class="stringliteral">&quot;The number of vertices cannot be zero.&quot;</span>);</div><div class="line"><a name="l00444"></a><span class="lineno">  444</span>&#160;</div><div class="line"><a name="l00445"></a><span class="lineno">  445</span>&#160;    <span class="keywordtype">bool</span> checkNodeLimit = m_config.nodeLimit &gt; 0;</div><div class="line"><a name="l00446"></a><span class="lineno">  446</span>&#160;    m_numNodes = checkNodeLimit ? m_config.nodeLimit : m_numNodesFound;</div><div class="line"><a name="l00447"></a><span class="lineno">  447</span>&#160;</div><div class="line"><a name="l00448"></a><span class="lineno">  448</span>&#160;    m_nodeNames.resize(m_numNodes);</div><div class="line"><a name="l00449"></a><span class="lineno">  449</span>&#160;    m_nodeWeights.assign(m_numNodes, 1.0);</div><div class="line"><a name="l00450"></a><span class="lineno">  450</span>&#160;    m_sumNodeWeights = 0.0;</div><div class="line"><a name="l00451"></a><span class="lineno">  451</span>&#160;</div><div class="line"><a name="l00452"></a><span class="lineno">  452</span>&#160;    std::string line;</div><div class="line"><a name="l00453"></a><span class="lineno">  453</span>&#160;    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> numNodesParsed = 0;</div><div class="line"><a name="l00454"></a><span class="lineno">  454</span>&#160;    <span class="keywordtype">bool</span> didEarlyBreak = <span class="keyword">false</span>;</div><div class="line"><a name="l00455"></a><span class="lineno">  455</span>&#160;</div><div class="line"><a name="l00456"></a><span class="lineno">  456</span>&#160;    <span class="comment">// Read node names and optional weight, assuming id 1, 2, 3, ... (or 0, 1, 2, ... if zero-based node numbering)</span></div><div class="line"><a name="l00457"></a><span class="lineno">  457</span>&#160;    <span class="keywordflow">while</span>(!std::getline(file, line).fail())</div><div class="line"><a name="l00458"></a><span class="lineno">  458</span>&#160;    {</div><div class="line"><a name="l00459"></a><span class="lineno">  459</span>&#160;        <span class="keywordflow">if</span> (line.length() == 0 || line[0] == <span class="charliteral">&#39;#&#39;</span>)</div><div class="line"><a name="l00460"></a><span class="lineno">  460</span>&#160;            <span class="keywordflow">continue</span>;</div><div class="line"><a name="l00461"></a><span class="lineno">  461</span>&#160;</div><div class="line"><a name="l00462"></a><span class="lineno">  462</span>&#160;        <span class="keywordflow">if</span> (line[0] == <span class="charliteral">&#39;*&#39;</span>)</div><div class="line"><a name="l00463"></a><span class="lineno">  463</span>&#160;            <span class="keywordflow">break</span>;</div><div class="line"><a name="l00464"></a><span class="lineno">  464</span>&#160;</div><div class="line"><a name="l00465"></a><span class="lineno">  465</span>&#160;        <span class="keywordflow">if</span> (m_config.nodeLimit &gt; 0 &amp;&amp; numNodesParsed == m_config.nodeLimit) {</div><div class="line"><a name="l00466"></a><span class="lineno">  466</span>&#160;            didEarlyBreak = <span class="keyword">true</span>;</div><div class="line"><a name="l00467"></a><span class="lineno">  467</span>&#160;            <span class="keywordflow">break</span>;</div><div class="line"><a name="l00468"></a><span class="lineno">  468</span>&#160;        }</div><div class="line"><a name="l00469"></a><span class="lineno">  469</span>&#160;</div><div class="line"><a name="l00470"></a><span class="lineno">  470</span>&#160;        <span class="comment">// parseVertice(line, id, name, weight);</span></div><div class="line"><a name="l00471"></a><span class="lineno">  471</span>&#160;        ss.clear();</div><div class="line"><a name="l00472"></a><span class="lineno">  472</span>&#160;        ss.str(line);</div><div class="line"><a name="l00473"></a><span class="lineno">  473</span>&#160;</div><div class="line"><a name="l00474"></a><span class="lineno">  474</span>&#160;        <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="keywordtype">id</span> = 0;</div><div class="line"><a name="l00475"></a><span class="lineno">  475</span>&#160;        <span class="keywordflow">if</span> (!(ss &gt;&gt; <span class="keywordtype">id</span>))</div><div class="line"><a name="l00476"></a><span class="lineno">  476</span>&#160;            <span class="keywordflow">throw</span> <a class="code" href="classFileFormatError.html">FileFormatError</a>(<a class="code" href="classio_1_1Str.html">io::Str</a>() &lt;&lt; <span class="stringliteral">&quot;Can&#39;t parse node id from line &#39;&quot;</span> &lt;&lt; line &lt;&lt; <span class="stringliteral">&quot;&#39;&quot;</span>);</div><div class="line"><a name="l00477"></a><span class="lineno">  477</span>&#160;</div><div class="line"><a name="l00478"></a><span class="lineno">  478</span>&#160;        <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nameStart = line.find_first_of(<span class="stringliteral">&quot;\&quot;&quot;</span>);</div><div class="line"><a name="l00479"></a><span class="lineno">  479</span>&#160;        <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nameEnd = line.find_last_of(<span class="stringliteral">&quot;\&quot;&quot;</span>);</div><div class="line"><a name="l00480"></a><span class="lineno">  480</span>&#160;        std::string name(<span class="stringliteral">&quot;&quot;</span>);</div><div class="line"><a name="l00481"></a><span class="lineno">  481</span>&#160;        <span class="keywordflow">if</span>(nameStart &lt; nameEnd) {</div><div class="line"><a name="l00482"></a><span class="lineno">  482</span>&#160;            name = std::string(line.begin() + nameStart + 1, line.begin() + nameEnd);</div><div class="line"><a name="l00483"></a><span class="lineno">  483</span>&#160;            line = line.substr(nameEnd + 1);</div><div class="line"><a name="l00484"></a><span class="lineno">  484</span>&#160;            ss.clear();</div><div class="line"><a name="l00485"></a><span class="lineno">  485</span>&#160;            ss.str(line);</div><div class="line"><a name="l00486"></a><span class="lineno">  486</span>&#160;        }</div><div class="line"><a name="l00487"></a><span class="lineno">  487</span>&#160;        <span class="keywordflow">else</span> {</div><div class="line"><a name="l00488"></a><span class="lineno">  488</span>&#160;            <span class="keywordflow">if</span> (!(ss &gt;&gt; name))</div><div class="line"><a name="l00489"></a><span class="lineno">  489</span>&#160;                <span class="keywordflow">throw</span> <a class="code" href="classFileFormatError.html">FileFormatError</a>(<a class="code" href="classio_1_1Str.html">io::Str</a>() &lt;&lt; <span class="stringliteral">&quot;Can&#39;t parse node name from line &#39;&quot;</span> &lt;&lt; line &lt;&lt; <span class="stringliteral">&quot;&#39;&quot;</span>);</div><div class="line"><a name="l00490"></a><span class="lineno">  490</span>&#160;        }</div><div class="line"><a name="l00491"></a><span class="lineno">  491</span>&#160;        <span class="keywordtype">double</span> weight = 1.0;</div><div class="line"><a name="l00492"></a><span class="lineno">  492</span>&#160;        <span class="keywordflow">if</span> ((ss &gt;&gt; weight)) {</div><div class="line"><a name="l00493"></a><span class="lineno">  493</span>&#160;            <span class="comment">// TODO: Check valid weight here?</span></div><div class="line"><a name="l00494"></a><span class="lineno">  494</span>&#160;            <span class="keywordflow">if</span> (weight &lt; 0.0) {</div><div class="line"><a name="l00495"></a><span class="lineno">  495</span>&#160;                <span class="keywordflow">throw</span> <a class="code" href="classFileFormatError.html">FileFormatError</a>(<a class="code" href="classio_1_1Str.html">io::Str</a>() &lt;&lt; <span class="stringliteral">&quot;Parsed a negative value (&quot;</span> &lt;&lt;</div><div class="line"><a name="l00496"></a><span class="lineno">  496</span>&#160;                weight &lt;&lt; <span class="stringliteral">&quot;) as weight to node &quot;</span> &lt;&lt; <span class="keywordtype">id</span> &lt;&lt; <span class="stringliteral">&quot; from line &#39;&quot;</span> &lt;&lt;</div><div class="line"><a name="l00497"></a><span class="lineno">  497</span>&#160;                line &lt;&lt; <span class="stringliteral">&quot;&#39;.&quot;</span>);</div><div class="line"><a name="l00498"></a><span class="lineno">  498</span>&#160;            }</div><div class="line"><a name="l00499"></a><span class="lineno">  499</span>&#160;        }</div><div class="line"><a name="l00500"></a><span class="lineno">  500</span>&#160;        <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nodeIndex = <span class="keyword">static_cast&lt;</span><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span><span class="keyword">&gt;</span>(<span class="keywordtype">id</span> - m_indexOffset);</div><div class="line"><a name="l00501"></a><span class="lineno">  501</span>&#160;        <span class="keywordflow">if</span> (nodeIndex != numNodesParsed)</div><div class="line"><a name="l00502"></a><span class="lineno">  502</span>&#160;        {</div><div class="line"><a name="l00503"></a><span class="lineno">  503</span>&#160;            <span class="keywordflow">throw</span> <a class="code" href="classBadConversionError.html">BadConversionError</a>(<a class="code" href="classio_1_1Str.html">io::Str</a>() &lt;&lt; <span class="stringliteral">&quot;The node id from line &#39;&quot;</span> &lt;&lt; line &lt;&lt;</div><div class="line"><a name="l00504"></a><span class="lineno">  504</span>&#160;                <span class="stringliteral">&quot;&#39; doesn&#39;t follow a consequitive order&quot;</span> &lt;&lt;</div><div class="line"><a name="l00505"></a><span class="lineno">  505</span>&#160;                ((m_indexOffset == 1 &amp;&amp; <span class="keywordtype">id</span> == 0)? <span class="stringliteral">&quot;.\nBe sure to use zero-based node numbering if the node numbers start from zero.&quot;</span> : <span class="stringliteral">&quot;.&quot;</span>));</div><div class="line"><a name="l00506"></a><span class="lineno">  506</span>&#160;        }</div><div class="line"><a name="l00507"></a><span class="lineno">  507</span>&#160;</div><div class="line"><a name="l00508"></a><span class="lineno">  508</span>&#160;        m_sumNodeWeights += weight;</div><div class="line"><a name="l00509"></a><span class="lineno">  509</span>&#160;        m_nodeWeights[nodeIndex] = weight;</div><div class="line"><a name="l00510"></a><span class="lineno">  510</span>&#160;        m_nodeNames[nodeIndex] = name;</div><div class="line"><a name="l00511"></a><span class="lineno">  511</span>&#160;        ++numNodesParsed;</div><div class="line"><a name="l00512"></a><span class="lineno">  512</span>&#160;    }</div><div class="line"><a name="l00513"></a><span class="lineno">  513</span>&#160;</div><div class="line"><a name="l00514"></a><span class="lineno">  514</span>&#160;    <span class="keywordflow">if</span> (line[0] == <span class="charliteral">&#39;*&#39;</span> &amp;&amp; numNodesParsed == 0)</div><div class="line"><a name="l00515"></a><span class="lineno">  515</span>&#160;    {</div><div class="line"><a name="l00516"></a><span class="lineno">  516</span>&#160;        <span class="comment">// Short pajek version (no nodes defined), set node number as name</span></div><div class="line"><a name="l00517"></a><span class="lineno">  517</span>&#160;        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; m_numNodes; ++i)</div><div class="line"><a name="l00518"></a><span class="lineno">  518</span>&#160;        {</div><div class="line"><a name="l00519"></a><span class="lineno">  519</span>&#160;            m_nodeWeights[i] = 1.0;</div><div class="line"><a name="l00520"></a><span class="lineno">  520</span>&#160;            m_nodeNames[i] = io::stringify(i+1);</div><div class="line"><a name="l00521"></a><span class="lineno">  521</span>&#160;        }</div><div class="line"><a name="l00522"></a><span class="lineno">  522</span>&#160;        m_sumNodeWeights = m_numNodes * 1.0;</div><div class="line"><a name="l00523"></a><span class="lineno">  523</span>&#160;    }</div><div class="line"><a name="l00524"></a><span class="lineno">  524</span>&#160;    </div><div class="line"><a name="l00525"></a><span class="lineno">  525</span>&#160;    <span class="keywordflow">if</span> (m_sumNodeWeights &lt; 1e-10) {</div><div class="line"><a name="l00526"></a><span class="lineno">  526</span>&#160;        <a class="code" href="classLog.html">Log</a>() &lt;&lt; <span class="stringliteral">&quot; (Warning: All node weights zero, changing to one) &quot;</span>;</div><div class="line"><a name="l00527"></a><span class="lineno">  527</span>&#160;        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; m_numNodes; ++i)</div><div class="line"><a name="l00528"></a><span class="lineno">  528</span>&#160;        {</div><div class="line"><a name="l00529"></a><span class="lineno">  529</span>&#160;            m_nodeWeights[i] = 1.0;</div><div class="line"><a name="l00530"></a><span class="lineno">  530</span>&#160;        }</div><div class="line"><a name="l00531"></a><span class="lineno">  531</span>&#160;        m_sumNodeWeights = m_numNodes * 1.0;</div><div class="line"><a name="l00532"></a><span class="lineno">  532</span>&#160;    }</div><div class="line"><a name="l00533"></a><span class="lineno">  533</span>&#160;</div><div class="line"><a name="l00534"></a><span class="lineno">  534</span>&#160;    <span class="keywordflow">if</span> (didEarlyBreak)</div><div class="line"><a name="l00535"></a><span class="lineno">  535</span>&#160;    {</div><div class="line"><a name="l00536"></a><span class="lineno">  536</span>&#160;        line = <a class="code" href="classNetwork.html#afd458fbfc07fc12e8ca3d6ec4e6a7291">skipUntilHeader</a>(file);</div><div class="line"><a name="l00537"></a><span class="lineno">  537</span>&#160;    }</div><div class="line"><a name="l00538"></a><span class="lineno">  538</span>&#160;</div><div class="line"><a name="l00539"></a><span class="lineno">  539</span>&#160;    <span class="keywordflow">return</span> line;</div><div class="line"><a name="l00540"></a><span class="lineno">  540</span>&#160;}</div><div class="ttc" id="classLog_html"><div class="ttname"><a href="classLog.html">Log</a></div><div class="ttdef"><b>Definition:</b> Logger.h:45</div></div>
<div class="ttc" id="classBadConversionError_html"><div class="ttname"><a href="classBadConversionError.html">BadConversionError</a></div><div class="ttdef"><b>Definition:</b> convert.h:66</div></div>
<div class="ttc" id="classFileFormatError_html"><div class="ttname"><a href="classFileFormatError.html">FileFormatError</a></div><div class="ttdef"><b>Definition:</b> convert.h:56</div></div>
<div class="ttc" id="classNetwork_html_afd458fbfc07fc12e8ca3d6ec4e6a7291"><div class="ttname"><a href="classNetwork.html#afd458fbfc07fc12e8ca3d6ec4e6a7291">Network::skipUntilHeader</a></div><div class="ttdeci">std::string skipUntilHeader(std::ifstream &amp;file)</div><div class="ttdef"><b>Definition:</b> Network.cpp:390</div></div>
<div class="ttc" id="classio_1_1Str_html"><div class="ttname"><a href="classio_1_1Str.html">io::Str</a></div><div class="ttdef"><b>Definition:</b> convert.h:165</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a7ebe3a5e948fc60e81fb94df08ca4358"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ebe3a5e948fc60e81fb94df08ca4358">&#9670;&nbsp;</a></span>setBipartiteNodesFrom()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Network::setBipartiteNodesFrom </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>bipartiteStartIndex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Change this network to a bipartite network </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bipartiteStartIndex</td><td>Nodes equal to or above this index are treated as feature nodes </td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><a name="l00638"></a><span class="lineno">  638</span>&#160;{</div><div class="line"><a name="l00639"></a><span class="lineno">  639</span>&#160;    m_bipartiteStartIndex = bipartiteStartIndex;</div><div class="line"><a name="l00640"></a><span class="lineno">  640</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="afd458fbfc07fc12e8ca3d6ec4e6a7291"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd458fbfc07fc12e8ca3d6ec4e6a7291">&#9670;&nbsp;</a></span>skipUntilHeader()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string Network::skipUntilHeader </td>
          <td>(</td>
          <td class="paramtype">std::ifstream &amp;&#160;</td>
          <td class="paramname"><em>file</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read lines from file until it starts with '*' and return that line. </p>
<div class="fragment"><div class="line"><a name="l00391"></a><span class="lineno">  391</span>&#160;{</div><div class="line"><a name="l00392"></a><span class="lineno">  392</span>&#160;    std::string line;</div><div class="line"><a name="l00393"></a><span class="lineno">  393</span>&#160;</div><div class="line"><a name="l00394"></a><span class="lineno">  394</span>&#160;    <span class="comment">// First skip lines until header</span></div><div class="line"><a name="l00395"></a><span class="lineno">  395</span>&#160;    <span class="keywordflow">while</span>(!std::getline(file, line).fail())</div><div class="line"><a name="l00396"></a><span class="lineno">  396</span>&#160;    {</div><div class="line"><a name="l00397"></a><span class="lineno">  397</span>&#160;        <span class="keywordflow">if</span> (line.length() == 0 || line[0] == <span class="charliteral">&#39;#&#39;</span>)</div><div class="line"><a name="l00398"></a><span class="lineno">  398</span>&#160;            <span class="keywordflow">continue</span>;</div><div class="line"><a name="l00399"></a><span class="lineno">  399</span>&#160;        <span class="keywordflow">if</span> (line[0] == <span class="charliteral">&#39;*&#39;</span>)</div><div class="line"><a name="l00400"></a><span class="lineno">  400</span>&#160;            <span class="keywordflow">break</span>;</div><div class="line"><a name="l00401"></a><span class="lineno">  401</span>&#160;    }</div><div class="line"><a name="l00402"></a><span class="lineno">  402</span>&#160;</div><div class="line"><a name="l00403"></a><span class="lineno">  403</span>&#160;    <span class="keywordflow">return</span> line;</div><div class="line"><a name="l00404"></a><span class="lineno">  404</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>dsmacc/graph/infomap/src/infomap/<a class="el" href="Network_8h_source.html">Network.h</a></li>
<li>dsmacc/graph/infomap/src/infomap/Network.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
