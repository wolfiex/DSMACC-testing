<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DSMACC: README</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">DSMACC
   &#160;<span id="projectnumber">2019</span>
   </div>
   <div id="projectbrief">Changes to DSMACC for the thesis of Daniel Ellis</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">README </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>A light, featureful and explicit option parsing library for node.js.</p>
<p><a href="#why">Why another one? See below</a>. tl;dr: The others I've tried are one of too loosey goosey (not explicit), too big/too many deps, or ill specified. YMMV.</p>
<p>Follow <a href="https://twitter.com/intent/user?screen_name=trentmick" target="_blank"></a> for updates to node-dashdash.</p>
<h1>Install</h1>
<pre class="fragment">npm install dashdash
</pre><h1>Usage</h1>
<p>``&lsquo;javascript var dashdash = require('dashdash&rsquo;);</p>
<p>// Specify the options. Minimally <code>name</code> (or <code>names</code>) and <code>type</code> // must be given for each. var options = [ { // <code>names</code> or a single <code>name</code>. First element is the <code>opts.KEY</code>. names: ['help', 'h'], // See "Option specs" below for types. type: 'bool', help: 'Print this help and exit.' } ];</p>
<p>// Shortcut form. As called it infers <code>process.argv</code>. See below for // the longer form to use methods like <code>.help()</code> on the Parser object. var opts = dashdash.parse({options: options});</p>
<p>console.log("opts:", opts); console.log("args:", opts._args); </p><div class="fragment"><div class="line"># Longer Example</div><div class="line"></div><div class="line">A more realistic [starter script &quot;foo.js&quot;](./examples/foo.js) is as follows.</div><div class="line">This also shows using `parser.help()` for formatted option help.</div><div class="line"></div><div class="line">```javascript</div><div class="line">var dashdash = require(&#39;./lib/dashdash&#39;);</div><div class="line"></div><div class="line">var options = [</div><div class="line">    {</div><div class="line">        name: &#39;version&#39;,</div><div class="line">        type: &#39;bool&#39;,</div><div class="line">        help: &#39;Print tool version and exit.&#39;</div><div class="line">    },</div><div class="line">    {</div><div class="line">        names: [&#39;help&#39;, &#39;h&#39;],</div><div class="line">        type: &#39;bool&#39;,</div><div class="line">        help: &#39;Print this help and exit.&#39;</div><div class="line">    },</div><div class="line">    {</div><div class="line">        names: [&#39;verbose&#39;, &#39;v&#39;],</div><div class="line">        type: &#39;arrayOfBool&#39;,</div><div class="line">        help: &#39;Verbose output. Use multiple times for more verbose.&#39;</div><div class="line">    },</div><div class="line">    {</div><div class="line">        names: [&#39;file&#39;, &#39;f&#39;],</div><div class="line">        type: &#39;string&#39;,</div><div class="line">        help: &#39;File to process&#39;,</div><div class="line">        helpArg: &#39;FILE&#39;</div><div class="line">    }</div><div class="line">];</div><div class="line"></div><div class="line">var parser = dashdash.createParser({options: options});</div><div class="line">try {</div><div class="line">    var opts = parser.parse(process.argv);</div><div class="line">} catch (e) {</div><div class="line">    console.error(&#39;foo: error: %s&#39;, e.message);</div><div class="line">    process.exit(1);</div><div class="line">}</div><div class="line"></div><div class="line">console.log(&quot;# opts:&quot;, opts);</div><div class="line">console.log(&quot;# args:&quot;, opts._args);</div><div class="line"></div><div class="line">// Use `parser.help()` for formatted options help.</div><div class="line">if (opts.help) {</div><div class="line">    var help = parser.help({includeEnv: true}).trimRight();</div><div class="line">    console.log(&#39;usage: node foo.js [OPTIONS]\n&#39;</div><div class="line">                + &#39;options:\n&#39;</div><div class="line">                + help);</div><div class="line">    process.exit(0);</div><div class="line">}</div><div class="line"></div><div class="line">// ...</div></div><!-- fragment --><p>Some example output from this script (foo.js):</p>
<div class="fragment"><div class="line">$ node foo.js -h</div><div class="line"># opts: { help: true,</div><div class="line">  _order: [ { name: &#39;help&#39;, value: true, from: &#39;argv&#39; } ],</div><div class="line">  _args: [] }</div><div class="line"># args: []</div><div class="line">usage: node foo.js [OPTIONS]</div><div class="line">options:</div><div class="line">    --version             Print tool version and exit.</div><div class="line">    -h, --help            Print this help and exit.</div><div class="line">    -v, --verbose         Verbose output. Use multiple times for more verbose.</div><div class="line">    -f FILE, --file=FILE  File to process</div><div class="line"></div><div class="line">$ node foo.js -v</div><div class="line"># opts: { verbose: [ true ],</div><div class="line">  _order: [ { name: &#39;verbose&#39;, value: true, from: &#39;argv&#39; } ],</div><div class="line">  _args: [] }</div><div class="line"># args: []</div><div class="line"></div><div class="line">$ node foo.js --version arg1</div><div class="line"># opts: { version: true,</div><div class="line">  _order: [ { name: &#39;version&#39;, value: true, from: &#39;argv&#39; } ],</div><div class="line">  _args: [ &#39;arg1&#39; ] }</div><div class="line"># args: [ &#39;arg1&#39; ]</div><div class="line"></div><div class="line">$ node foo.js -f bar.txt</div><div class="line"># opts: { file: &#39;bar.txt&#39;,</div><div class="line">  _order: [ { name: &#39;file&#39;, value: &#39;bar.txt&#39;, from: &#39;argv&#39; } ],</div><div class="line">  _args: [] }</div><div class="line"># args: []</div><div class="line"></div><div class="line">$ node foo.js -vvv --file=blah</div><div class="line"># opts: { verbose: [ true, true, true ],</div><div class="line">  file: &#39;blah&#39;,</div><div class="line">  _order:</div><div class="line">   [ { name: &#39;verbose&#39;, value: true, from: &#39;argv&#39; },</div><div class="line">     { name: &#39;verbose&#39;, value: true, from: &#39;argv&#39; },</div><div class="line">     { name: &#39;verbose&#39;, value: true, from: &#39;argv&#39; },</div><div class="line">     { name: &#39;file&#39;, value: &#39;blah&#39;, from: &#39;argv&#39; } ],</div><div class="line">  _args: [] }</div><div class="line"># args: []</div></div><!-- fragment --><p>See the <a href="examples/">"examples"</a> dir for a number of starter examples using some of dashdash's features.</p>
<h1>Environment variable integration</h1>
<p>If you want to allow environment variables to specify options to your tool, dashdash makes this easy. We can change the 'verbose' option in the example above to include an 'env' field:</p>
<div class="fragment"><div class="line">{</div><div class="line">    names: [&#39;verbose&#39;, &#39;v&#39;],</div><div class="line">    type: &#39;arrayOfBool&#39;,</div><div class="line">    env: &#39;FOO_VERBOSE&#39;,         // &lt;--- add this line</div><div class="line">    help: &#39;Verbose output. Use multiple times for more verbose.&#39;</div><div class="line">},</div></div><!-- fragment --><p>then the **"FOO_VERBOSE" environment variable** can be used to set this option:</p>
<div class="fragment"><div class="line">$ FOO_VERBOSE=1 node foo.js</div><div class="line"># opts: { verbose: [ true ],</div><div class="line">  _order: [ { name: &#39;verbose&#39;, value: true, from: &#39;env&#39; } ],</div><div class="line">  _args: [] }</div><div class="line"># args: []</div></div><!-- fragment --><p>Boolean options will interpret the empty string as unset, '0' as false and anything else as true.</p>
<div class="fragment"><div class="line">$ FOO_VERBOSE= node examples/foo.js                 # not set</div><div class="line"># opts: { _order: [], _args: [] }</div><div class="line"># args: []</div><div class="line"></div><div class="line">$ FOO_VERBOSE=0 node examples/foo.js                # &#39;0&#39; is false</div><div class="line"># opts: { verbose: [ false ],</div><div class="line">  _order: [ { key: &#39;verbose&#39;, value: false, from: &#39;env&#39; } ],</div><div class="line">  _args: [] }</div><div class="line"># args: []</div><div class="line"></div><div class="line">$ FOO_VERBOSE=1 node examples/foo.js                # true</div><div class="line"># opts: { verbose: [ true ],</div><div class="line">  _order: [ { key: &#39;verbose&#39;, value: true, from: &#39;env&#39; } ],</div><div class="line">  _args: [] }</div><div class="line"># args: []</div><div class="line"></div><div class="line">$ FOO_VERBOSE=boogabooga node examples/foo.js       # true</div><div class="line"># opts: { verbose: [ true ],</div><div class="line">  _order: [ { key: &#39;verbose&#39;, value: true, from: &#39;env&#39; } ],</div><div class="line">  _args: [] }</div><div class="line"># args: []</div></div><!-- fragment --><p>Non-booleans can be used as well. Strings:</p>
<div class="fragment"><div class="line">$ FOO_FILE=data.txt node examples/foo.js</div><div class="line"># opts: { file: &#39;data.txt&#39;,</div><div class="line">  _order: [ { key: &#39;file&#39;, value: &#39;data.txt&#39;, from: &#39;env&#39; } ],</div><div class="line">  _args: [] }</div><div class="line"># args: []</div></div><!-- fragment --><p>Numbers:</p>
<div class="fragment"><div class="line">$ FOO_TIMEOUT=5000 node examples/foo.js</div><div class="line"># opts: { timeout: 5000,</div><div class="line">  _order: [ { key: &#39;timeout&#39;, value: 5000, from: &#39;env&#39; } ],</div><div class="line">  _args: [] }</div><div class="line"># args: []</div><div class="line"></div><div class="line">$ FOO_TIMEOUT=blarg node examples/foo.js</div><div class="line">foo: error: arg for &quot;FOO_TIMEOUT&quot; is not a positive integer: &quot;blarg&quot;</div></div><!-- fragment --><p>With the <code>includeEnv: true</code> config to <code>parser.help()</code> the environment variable can also be included in <b>help output</b>: </p><pre class="fragment">usage: node foo.js [OPTIONS]
options:
    --version             Print tool version and exit.
    -h, --help            Print this help and exit.
    -v, --verbose         Verbose output. Use multiple times for more verbose.
                          Environment: FOO_VERBOSE=1
    -f FILE, --file=FILE  File to process
</pre><h1>Bash completion</h1>
<p>Dashdash provides a simple way to create a Bash completion file that you can place in your "bash_completion.d" directory &ndash; sometimes that is "/usr/local/etc/bash_completion.d/"). Features:</p>
<ul>
<li>Support for short and long opts</li>
<li>Support for knowing which options take arguments</li>
<li>Support for subcommands (e.g. 'git log &lt;TAB&gt;' to show just options for the log subcommand). See <a href="https://github.com/trentm/node-cmdln#bash-completion">node-cmdln</a> for how to integrate that.</li>
<li>Does the right thing with "--" to stop options.</li>
<li>Custom optarg and arg types for custom completions.</li>
</ul>
<p>Dashdash will return bash completion file content given a parser instance: </p><pre class="fragment">var parser = dashdash.createParser({options: options});
console.log( parser.bashCompletion({name: 'mycli'}) );
</pre><p>or directly from a <code>options</code> array of options specs: </p><pre class="fragment">var code = dashdash.bashCompletionFromOptions({
    name: 'mycli',
    options: OPTIONS
});
</pre><p>Write that content to "/usr/local/etc/bash_completion.d/mycli" and you will have Bash completions for <code>mycli</code>. Alternatively you can write it to any file (e.g. "~/.bashrc") and source it.</p>
<p>You could add a <code>--completion</code> hidden option to your tool that emits the completion content and document for your users to call that to install Bash completions.</p>
<p>See <a href="examples/ddcompletion.js">examples/ddcompletion.js</a> for a complete example, including how one can define bash functions for completion of custom option types. Also see <a href="https://github.com/trentm/node-cmdln">node-cmdln</a> for how it uses this for Bash completion for full multi-subcommand tools.</p>
<ul>
<li>TODO: document specExtra</li>
<li>TODO: document includeHidden</li>
<li>TODO: document custom types, <code>function complete\_FOO</code> guide, completionType</li>
<li>TODO: document argtypes</li>
</ul>
<h1>Parser config</h1>
<p>Parser construction (i.e. <code>dashdash.createParser(CONFIG)</code>) takes the following fields:</p>
<ul>
<li><code>options</code> (Array of option specs). Required. See the <a href="#option-specs">Option specs</a> section below.</li>
<li><p class="startli"><code>interspersed</code> (Boolean). Optional. Default is true. If true this allows interspersed arguments and options. I.e.: </p><pre class="fragment">  node ./tool.js -v arg1 arg2 -h   # '-h' is after interspersed args
</pre><p class="startli">Set it to false to have '-h' <b>not</b> get parsed as an option in the above example.</p>
</li>
<li><p class="startli"><code>allowUnknown</code> (Boolean). Optional. Default is false. If false, this causes unknown arguments to throw an error. I.e.: </p><pre class="fragment">  node ./tool.js -v arg1 --afe8asefksjefhas
</pre><p class="startli">Set it to true to treat the unknown option as a positional argument.</p>
<p class="startli"><b>Caveat</b>: When a shortopt group, such as <code>-xaz</code> contains a mix of known and unknown options, the <em>entire</em> group is passed through unmolested as a positional argument.</p>
<p class="startli">Consider if you have a known short option <code>-a</code>, and parse the following command line: </p><pre class="fragment">  node ./tool.js -xaz
</pre><p class="startli">where <code>-x</code> and <code>-z</code> are unknown. There are multiple ways to interpret this:</p><ol type="1">
<li><code>-x</code> takes a value: &lsquo;{x: 'az&rsquo;}<code> 2.</code>-x<code>and</code>-z<code>are both booleans:</code>{x:true,a:true,z:true}`</li>
</ol>
<p class="startli">Since dashdash does not know what <code>-x</code> and <code>-z</code> are, it can't know if you'd prefer to receive &lsquo;{a:true,_args:[&rsquo;-x','-z']}<code>or </code>{x:'az'}<code>, or</code>{_args:['-xaz']}`. Leaving the positional arg unprocessed is the easiest mistake for the user to recover from.</p>
</li>
</ul>
<h1><a class="el" href="structOption.html">Option</a> specs</h1>
<p>Example using all fields (required fields are noted):</p>
<div class="fragment"><div class="line">{</div><div class="line">    names: [&#39;file&#39;, &#39;f&#39;],       // Required (one of `names` or `name`).</div><div class="line">    type: &#39;string&#39;,             // Required.</div><div class="line">    completionType: &#39;filename&#39;,</div><div class="line">    env: &#39;MYTOOL_FILE&#39;,</div><div class="line">    help: &#39;Config file to load before running &quot;mytool&quot;&#39;,</div><div class="line">    helpArg: &#39;PATH&#39;,</div><div class="line">    helpWrap: false,</div><div class="line">    default: path.resolve(process.env.HOME, &#39;.mytoolrc&#39;)</div><div class="line">}</div></div><!-- fragment --><p>Each option spec in the <code>options</code> array must/can have the following fields:</p>
<ul>
<li><code>name</code> (String) or <code>names</code> (Array). Required. These give the option name and aliases. The first name (if more than one given) is the key for the parsed <code>opts</code> object.</li>
<li><p class="startli"><code>type</code> (String). Required. One of:</p><ul>
<li>bool</li>
<li>string</li>
<li>number</li>
<li>integer</li>
<li>positiveInteger</li>
<li>date (epoch seconds, e.g. 1396031701, or ISO 8601 format <code>YYYY-MM-DD[THH:MM:SS[.sss][Z]]</code>, e.g. "2014-03-28T18:35:01.489Z")</li>
<li>arrayOfBool</li>
<li>arrayOfString</li>
<li>arrayOfNumber</li>
<li>arrayOfInteger</li>
<li>arrayOfPositiveInteger</li>
<li>arrayOfDate</li>
</ul>
<p class="startli">FWIW, these names attempt to match with asserts on <a href="https://github.com/mcavage/node-assert-plus">assert-plus</a>. You can add your own custom option types with <code>dashdash.addOptionType</code>. See below.</p>
</li>
<li><code>completionType</code> (String). Optional. This is used for <a href="#bash-completion">Bash completion</a> for an option argument. If not specified, then the value of <code>type</code> is used. Any string may be specified, but only the following values have meaning:<ul>
<li><code>none</code>: Provide no completions.</li>
<li><code>file</code>: Bash's default completion (i.e. <code>complete -o default</code>), which includes filenames.</li>
<li><em>Any string FOO for which a <code>function complete_FOO</code> Bash function is defined.</em> This is for custom completions for a given tool. Typically these custom functions are provided in the <code>specExtra</code> argument to <code>dashdash.bashCompletionFromOptions()</code>. See <a href="examples/ddcompletion.js">"examples/ddcompletion.js"</a> for an example.</li>
</ul>
</li>
<li><p class="startli"><code>env</code> (String or Array of String). Optional. An environment variable name (or names) that can be used as a fallback for this option. For example, given a "foo.js" like this: </p><pre class="fragment">  var options = [{names: ['dry-run', 'n'], env: 'FOO_DRY_RUN'}];
  var opts = dashdash.parse({options: options});
</pre><p class="startli">Both <code>node foo.js --dry-run</code> and <code>FOO_DRY_RUN=1 node foo.js</code> would result in <code>opts.dry_run = true</code>.</p>
<p class="startli">An environment variable is only used as a fallback, i.e. it is ignored if the associated option is given in <code>argv</code>.</p>
</li>
<li><code>help</code> (String). Optional. Used for <code>parser.help()</code> output.</li>
<li><code>helpArg</code> (String). Optional. Used in help output as the placeholder for the option argument, e.g. the "PATH" in: <pre class="fragment">  ...
  -f PATH, --file=PATH    File to process
  ...
</pre></li>
<li><code>helpWrap</code> (Boolean). Optional, default true. Set this to <code>false</code> to have that option's <code>help</code> <em>not</em> be text wrapped in <code>&lt;parser&gt;.help()</code> output.</li>
<li><code>default</code>. Optional. A default value used for this option, if the option isn't specified in argv.</li>
<li><code>hidden</code> (Boolean). Optional, default false. If true, help output will not include this option. See also the <code>includeHidden</code> option to <code>bashCompletionFromOptions()</code> for <a href="#bash-completion">Bash completion</a>.</li>
</ul>
<h1><a class="el" href="structOption.html">Option</a> group headings</h1>
<p>You can add headings between option specs in the <code>options</code> array. To do so, simply add an object with only a <code>group</code> property &ndash; the string to print as the heading for the subsequent options in the array. For example:</p>
<div class="fragment"><div class="line">var options = [</div><div class="line">    {</div><div class="line">        group: &#39;Armament Options&#39;</div><div class="line">    },</div><div class="line">    {</div><div class="line">        names: [ &#39;weapon&#39;, &#39;w&#39; ],</div><div class="line">        type: &#39;string&#39;</div><div class="line">    },</div><div class="line">    {</div><div class="line">        group: &#39;General Options&#39;</div><div class="line">    },</div><div class="line">    {</div><div class="line">        names: [ &#39;help&#39;, &#39;h&#39; ],</div><div class="line">        type: &#39;bool&#39;</div><div class="line">    }</div><div class="line">];</div><div class="line">...</div></div><!-- fragment --><p>Note: You can use an empty string, &lsquo;{group: &rsquo;'}`, to get a blank line in help output between groups of options.</p>
<h1>Help config</h1>
<p>The <code>parser.help(...)</code> function is configurable as follows: </p><pre class="fragment">    Options:
      Armament Options:
    ^^  -w WEAPON, --weapon=WEAPON  Weapon with which to crush. One of: |
   /                                sword, spear, maul                  |
  /   General Options:                                                  |
 /      -h, --help                  Print this help and exit.           |
/   ^^^^                            ^                                   |
\       `-- indent                   `-- helpCol              maxCol ---'
 `-- headingIndent
</pre><ul>
<li><code>indent</code> (Number or String). Default 4. Set to a number (for that many spaces) or a string for the literal indent.</li>
<li><code>headingIndent</code> (Number or String). Default half length of <code>indent</code>. Set to a number (for that many spaces) or a string for the literal indent. This indent applies to group heading lines, between normal option lines.</li>
<li><code>nameSort</code> (String). Default is 'length'. By default the names are sorted to put the short opts first (i.e. '-h, &ndash;help' preferred to '&ndash;help, -h'). Set to 'none' to not do this sorting.</li>
<li><code>maxCol</code> (Number). Default 80. Note that reflow is just done on whitespace so a long token in the option help can overflow maxCol.</li>
<li><code>helpCol</code> (Number). If not set a reasonable value will be determined between <code>minHelpCol</code> and <code>maxHelpCol</code>.</li>
<li><code>minHelpCol</code> (Number). Default 20.</li>
<li><code>maxHelpCol</code> (Number). Default 40.</li>
<li><code>helpWrap</code> (Boolean). Default true. Set to <code>false</code> to have option <code>help</code> strings <em>not</em> be textwrapped to the helpCol..maxCol range.</li>
<li><code>includeEnv</code> (Boolean). Default false. If the option has associated environment variables (via the <code>env</code> option spec attribute), then append mentioned of those envvars to the help string.</li>
<li><code>includeDefault</code> (Boolean). Default false. If the option has a default value (via the <code>default</code> option spec attribute, or a default on the option's type), then a "Default: VALUE" string will be appended to the help string.</li>
</ul>
<h1>Custom option types</h1>
<p>Dashdash includes a good starter set of option types that it will parse for you. However, you can add your own via: </p><pre class="fragment">var dashdash = require('dashdash');
dashdash.addOptionType({
    name: '...',
    takesArg: true,
    helpArg: '...',
    parseArg: function (option, optstr, arg) {
        ...
    },
    array: false,  // optional
    arrayFlatten: false,  // optional
    default: ...,   // optional
    completionType: ...  // optional
});
</pre><p>For example, a simple option type that accepts 'yes', 'y', 'no' or 'n' as a boolean argument would look like: </p><pre class="fragment">var dashdash = require('dashdash');

function parseYesNo(option, optstr, arg) {
    var argLower = arg.toLowerCase()
    if (~['yes', 'y'].indexOf(argLower)) {
        return true;
    } else if (~['no', 'n'].indexOf(argLower)) {
        return false;
    } else {
        throw new Error(format(
            'arg for "%s" is not "yes" or "no": "%s"',
            optstr, arg));
    }
}

dashdash.addOptionType({
    name: 'yesno'
    takesArg: true,
    helpArg: '&lt;yes|no&gt;',
    parseArg: parseYesNo
});

var options = {
    {names: ['answer', 'a'], type: 'yesno'}
};
var opts = dashdash.parse({options: options});
</pre><p>See "examples/custom-option-\*.js" for other examples. See the <code>addOptionType</code> block comment in "lib/dashdash.js" for more details. Please let me know <a href="https://github.com/trentm/node-dashdash/issues/new">with an issue</a> if you write a generally useful one.</p>
<h1>Why</h1>
<p>Why another node.js option parsing lib?</p>
<ul>
<li><code>nopt</code> really is just for "tools like npm". Implicit opts (e.g. '&ndash;no-foo' works for every '&ndash;foo'). Can't disable abbreviated opts. Can't do multiple usages of same opt, e.g. '-vvv' (I think). Can't do grouped short opts.</li>
<li><code>optimist</code> has surprise interpretation of options (at least to me). Implicit opts mean ambiguities and poor error handling for fat-fingering. <code>process.exit</code> calls makes it hard to use as a libary.</li>
<li><code>optparse</code> Incomplete docs. Is this an attempted clone of Python's <code>optparse</code>. Not clear. Some divergence. <code>parser.on("name", ...)</code> API is weird.</li>
<li><code>argparse</code> Dep on underscore. No thanks just for option processing. <code>find lib | wc -l</code> -&gt; <code>26</code>. Overkill. Argparse is a bit different anyway. Not sure I want that.</li>
<li><code>posix-getopt</code> No type validation. Though that isn't a killer. AFAIK can't have a long opt without a short alias. I.e. no <code>getopt_long</code> semantics. Also, no whizbang features like generated help output.</li>
<li><a href="https://github.com/visionmedia/commander.js">"commander.js"</a>: I wrote <a href="http://trentm.com/2014/01/a-critique-of-commander-for-nodejs.html">a critique</a> a while back. It seems fine, but last I checked had <a href="https://github.com/visionmedia/commander.js/pull/121">an outstanding bug</a> that would prevent me from using it.</li>
</ul>
<h1>License</h1>
<p>MIT. See LICENSE.txt. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
