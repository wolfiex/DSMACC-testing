<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DSMACC: InfomapGreedyCommon&lt; InfomapGreedyDerivedType &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">DSMACC
   &#160;<span id="projectnumber">2019</span>
   </div>
   <div id="projectbrief">Changes to DSMACC for the thesis of Daniel Ellis</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classInfomapGreedyCommon-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">InfomapGreedyCommon&lt; InfomapGreedyDerivedType &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Inheritance diagram for InfomapGreedyCommon&lt; InfomapGreedyDerivedType &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classInfomapGreedyCommon.png" usemap="#InfomapGreedyCommon_3C_20InfomapGreedyDerivedType_20_3E_map" alt=""/>
  <map id="InfomapGreedyCommon_3C_20InfomapGreedyDerivedType_20_3E_map" name="InfomapGreedyCommon_3C_20InfomapGreedyDerivedType_20_3E_map">
<area href="classInfomapGreedySpecialized.html" alt="InfomapGreedySpecialized&lt; derived_traits&lt; InfomapGreedyDerivedType &gt;::flow_type &gt;" shape="rect" coords="0,112,617,136"/>
<area href="classInfomapGreedy.html" alt="InfomapGreedy&lt; InfomapGreedySpecialized&lt; derived_traits&lt; InfomapGreedyDerivedType &gt;::flow_type &gt; &gt;" shape="rect" coords="0,56,617,80"/>
<area href="classInfomapBase.html" alt="InfomapBase" shape="rect" coords="0,0,617,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a8889c3cd57d341ee75ae9c13b7d77dee"><td class="memItemLeft" align="right" valign="top"><a id="a8889c3cd57d341ee75ae9c13b7d77dee"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>InfomapGreedyCommon</b> (const <a class="el" href="structConfig.html">Config</a> &amp;conf, <a class="el" href="classNodeFactoryBase.html">NodeFactoryBase</a> *nodeFactory)</td></tr>
<tr class="separator:a8889c3cd57d341ee75ae9c13b7d77dee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d115399a2be685d098a372faa969d32"><td class="memItemLeft" align="right" valign="top"><a id="a3d115399a2be685d098a372faa969d32"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>InfomapGreedyCommon</b> (const <a class="el" href="classInfomapBase.html">InfomapBase</a> &amp;infomap, <a class="el" href="classNodeFactoryBase.html">NodeFactoryBase</a> *nodeFactory)</td></tr>
<tr class="separator:a3d115399a2be685d098a372faa969d32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classInfomapGreedySpecialized"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classInfomapGreedySpecialized')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classInfomapGreedySpecialized.html">InfomapGreedySpecialized&lt; derived_traits&lt; InfomapGreedyDerivedType &gt;::flow_type &gt;</a></td></tr>
<tr class="memitem:a857f5bdae7458ff36f7aee81878ee635 inherit pub_methods_classInfomapGreedySpecialized"><td class="memItemLeft" align="right" valign="top"><a id="a857f5bdae7458ff36f7aee81878ee635"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>InfomapGreedySpecialized</b> (const <a class="el" href="structConfig.html">Config</a> &amp;conf, <a class="el" href="classNodeFactoryBase.html">NodeFactoryBase</a> *nodeFactory)</td></tr>
<tr class="separator:a857f5bdae7458ff36f7aee81878ee635 inherit pub_methods_classInfomapGreedySpecialized"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2b03c6dcc7523d98f174bfb75daafc5 inherit pub_methods_classInfomapGreedySpecialized"><td class="memItemLeft" align="right" valign="top"><a id="ad2b03c6dcc7523d98f174bfb75daafc5"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>InfomapGreedySpecialized</b> (const <a class="el" href="classInfomapBase.html">InfomapBase</a> &amp;infomap, <a class="el" href="classNodeFactoryBase.html">NodeFactoryBase</a> *nodeFactory)</td></tr>
<tr class="separator:ad2b03c6dcc7523d98f174bfb75daafc5 inherit pub_methods_classInfomapGreedySpecialized"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classInfomapGreedy"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classInfomapGreedy')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classInfomapGreedy.html">InfomapGreedy&lt; InfomapGreedySpecialized&lt; derived_traits&lt; InfomapGreedyDerivedType &gt;::flow_type &gt; &gt;</a></td></tr>
<tr class="memitem:a423bc1ffe6544b0b9516eb9edf6941d3 inherit pub_methods_classInfomapGreedy"><td class="memItemLeft" align="right" valign="top"><a id="a423bc1ffe6544b0b9516eb9edf6941d3"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>InfomapGreedy</b> (const <a class="el" href="structConfig.html">Config</a> &amp;conf, <a class="el" href="classNodeFactoryBase.html">NodeFactoryBase</a> *nodeFactory)</td></tr>
<tr class="separator:a423bc1ffe6544b0b9516eb9edf6941d3 inherit pub_methods_classInfomapGreedy"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7927c5724c0e4f6df05d1fae351ec667 inherit pub_methods_classInfomapGreedy"><td class="memItemLeft" align="right" valign="top"><a id="a7927c5724c0e4f6df05d1fae351ec667"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>InfomapGreedy</b> (const <a class="el" href="classInfomapBase.html">InfomapBase</a> &amp;infomap, <a class="el" href="classNodeFactoryBase.html">NodeFactoryBase</a> *nodeFactory)</td></tr>
<tr class="separator:a7927c5724c0e4f6df05d1fae351ec667 inherit pub_methods_classInfomapGreedy"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classInfomapBase"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classInfomapBase')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classInfomapBase.html">InfomapBase</a></td></tr>
<tr class="memitem:ad70ef13ee923d11822c706c99e3acad1 inherit pub_methods_classInfomapBase"><td class="memItemLeft" align="right" valign="top"><a id="ad70ef13ee923d11822c706c99e3acad1"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>InfomapBase</b> (const <a class="el" href="structConfig.html">Config</a> &amp;conf, <a class="el" href="classNodeFactoryBase.html">NodeFactoryBase</a> *nodeFactory)</td></tr>
<tr class="separator:ad70ef13ee923d11822c706c99e3acad1 inherit pub_methods_classInfomapBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0d03cda09e95c018f5471f83bedb395 inherit pub_methods_classInfomapBase"><td class="memItemLeft" align="right" valign="top"><a id="af0d03cda09e95c018f5471f83bedb395"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>InfomapBase</b> (const <a class="el" href="classInfomapBase.html">InfomapBase</a> &amp;infomap, <a class="el" href="classNodeFactoryBase.html">NodeFactoryBase</a> *nodeFactory)</td></tr>
<tr class="separator:af0d03cda09e95c018f5471f83bedb395 inherit pub_methods_classInfomapBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b8bf35f42a03f3abf797b6a06ce9873 inherit pub_methods_classInfomapBase"><td class="memItemLeft" align="right" valign="top"><a id="a8b8bf35f42a03f3abf797b6a06ce9873"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>run</b> ()</td></tr>
<tr class="separator:a8b8bf35f42a03f3abf797b6a06ce9873 inherit pub_methods_classInfomapBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fae64f1a942f8efe41d7e40696b3d1d inherit pub_methods_classInfomapBase"><td class="memItemLeft" align="right" valign="top"><a id="a3fae64f1a942f8efe41d7e40696b3d1d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>run</b> (<a class="el" href="classNetwork.html">Network</a> &amp;input, <a class="el" href="classHierarchicalNetwork.html">HierarchicalNetwork</a> &amp;output)</td></tr>
<tr class="separator:a3fae64f1a942f8efe41d7e40696b3d1d inherit pub_methods_classInfomapBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1865023eecb098ba1ba9d00164851d64 inherit pub_methods_classInfomapBase"><td class="memItemLeft" align="right" valign="top"><a id="a1865023eecb098ba1ba9d00164851d64"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>run</b> (<a class="el" href="classHierarchicalNetwork.html">HierarchicalNetwork</a> &amp;output)</td></tr>
<tr class="separator:a1865023eecb098ba1ba9d00164851d64 inherit pub_methods_classInfomapBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c35382d0b4dc02e875f43174b20541b inherit pub_methods_classInfomapBase"><td class="memItemLeft" align="right" valign="top"><a id="a7c35382d0b4dc02e875f43174b20541b"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>initNetwork</b> ()</td></tr>
<tr class="separator:a7c35382d0b4dc02e875f43174b20541b inherit pub_methods_classInfomapBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a795d05d87685a4711eb528e3947c16f4 inherit pub_methods_classInfomapBase"><td class="memItemLeft" align="right" valign="top"><a id="a795d05d87685a4711eb528e3947c16f4"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>initNetwork</b> (<a class="el" href="classNetwork.html">Network</a> &amp;input)</td></tr>
<tr class="separator:a795d05d87685a4711eb528e3947c16f4 inherit pub_methods_classInfomapBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad808b0cf6c10cad542b5dcead997c147 inherit pub_methods_classInfomapBase"><td class="memItemLeft" align="right" valign="top"><a id="ad808b0cf6c10cad542b5dcead997c147"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>calcOneLevelCodelength</b> ()</td></tr>
<tr class="separator:ad808b0cf6c10cad542b5dcead997c147 inherit pub_methods_classInfomapBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af44c571136811f49c2d3c1fb2401983f inherit pub_methods_classInfomapBase"><td class="memItemLeft" align="right" valign="top"><a id="af44c571136811f49c2d3c1fb2401983f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>calcEntropyRate</b> ()</td></tr>
<tr class="separator:af44c571136811f49c2d3c1fb2401983f inherit pub_methods_classInfomapBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a580c1b1174a1093489faf6cfefaf0eb2 inherit pub_methods_classInfomapBase"><td class="memItemLeft" align="right" valign="top"><a id="a580c1b1174a1093489faf6cfefaf0eb2"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>consolidateExternalClusterData</b> (bool printResults=false)</td></tr>
<tr class="separator:a580c1b1174a1093489faf6cfefaf0eb2 inherit pub_methods_classInfomapBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72e68d442f3becf6e55942c8a0c15ca8 inherit pub_methods_classInfomapBase"><td class="memItemLeft" align="right" valign="top"><a id="a72e68d442f3becf6e55942c8a0c15ca8"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>preClusterMultiplexNetwork</b> (bool printResults=false)</td></tr>
<tr class="separator:a72e68d442f3becf6e55942c8a0c15ca8 inherit pub_methods_classInfomapBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33a93dfdd5140b67eff80260f573968f inherit pub_methods_classInfomapBase"><td class="memItemLeft" align="right" valign="top"><a id="a33a93dfdd5140b67eff80260f573968f"></a>
const <a class="el" href="classNodeBase.html">NodeBase</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>root</b> () const</td></tr>
<tr class="separator:a33a93dfdd5140b67eff80260f573968f inherit pub_methods_classInfomapBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2927fa281448a7bf6aa489179186be95 inherit pub_methods_classInfomapBase"><td class="memItemLeft" align="right" valign="top"><a id="a2927fa281448a7bf6aa489179186be95"></a>
<a class="el" href="classNodeBase.html">NodeBase</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>root</b> ()</td></tr>
<tr class="separator:a2927fa281448a7bf6aa489179186be95 inherit pub_methods_classInfomapBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d80d820eaaf0208a857445fbdfeeb49 inherit pub_methods_classInfomapBase"><td class="memItemLeft" align="right" valign="top"><a id="a0d80d820eaaf0208a857445fbdfeeb49"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>maxDepth</b> ()</td></tr>
<tr class="separator:a0d80d820eaaf0208a857445fbdfeeb49 inherit pub_methods_classInfomapBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45e57381daf363449416709beb430ca8 inherit pub_methods_classInfomapBase"><td class="memItemLeft" align="right" valign="top"><a id="a45e57381daf363449416709beb430ca8"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>numBottomModules</b> ()</td></tr>
<tr class="separator:a45e57381daf363449416709beb430ca8 inherit pub_methods_classInfomapBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4193d5838c66fb72a6b3d3ae11a6c1d7 inherit pub_methods_classInfomapBase"><td class="memItemLeft" align="right" valign="top"><a id="a4193d5838c66fb72a6b3d3ae11a6c1d7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>sortTree</b> ()</td></tr>
<tr class="separator:a4193d5838c66fb72a6b3d3ae11a6c1d7 inherit pub_methods_classInfomapBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:aaaa423506d351f689fe1e2cf0092930c"><td class="memItemLeft" align="right" valign="top"><a id="aaaa423506d351f689fe1e2cf0092930c"></a>
virtual std::auto_ptr&lt; <a class="el" href="classInfomapBase.html">InfomapBase</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getNewInfomapInstance</b> ()</td></tr>
<tr class="separator:aaaa423506d351f689fe1e2cf0092930c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6f3822e0e2a7d5bbbc00f52b2750222"><td class="memItemLeft" align="right" valign="top"><a id="ab6f3822e0e2a7d5bbbc00f52b2750222"></a>
NodeType &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getNode</b> (<a class="el" href="classNodeBase.html">NodeBase</a> &amp;<a class="el" href="structnode.html">node</a>)</td></tr>
<tr class="separator:ab6f3822e0e2a7d5bbbc00f52b2750222"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e46fb6c7041f09993a70135e22585a7"><td class="memItemLeft" align="right" valign="top"><a id="a6e46fb6c7041f09993a70135e22585a7"></a>
const NodeType &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getNode</b> (const <a class="el" href="classNodeBase.html">NodeBase</a> &amp;<a class="el" href="structnode.html">node</a>) const</td></tr>
<tr class="separator:a6e46fb6c7041f09993a70135e22585a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a201b93e2f668b3f55c130c933a78e4ce"><td class="memItemLeft" align="right" valign="top"><a id="a201b93e2f668b3f55c130c933a78e4ce"></a>
virtual unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>aggregateFlowValuesFromLeafToRoot</b> ()</td></tr>
<tr class="separator:a201b93e2f668b3f55c130c933a78e4ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c15dc01895797111c8b546cbc35d797"><td class="memItemLeft" align="right" valign="top"><a id="a7c15dc01895797111c8b546cbc35d797"></a>
virtual double&#160;</td><td class="memItemRight" valign="bottom"><b>calcCodelengthOnAllNodesInTree</b> ()</td></tr>
<tr class="separator:a7c15dc01895797111c8b546cbc35d797"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16b8fb2ee1e3c5fa6bb52caba21558e7"><td class="memItemLeft" align="right" valign="top"><a id="a16b8fb2ee1e3c5fa6bb52caba21558e7"></a>
virtual double&#160;</td><td class="memItemRight" valign="bottom"><b>calcCodelengthOnRootOfLeafNodes</b> (const <a class="el" href="classNodeBase.html">NodeBase</a> &amp;parent)</td></tr>
<tr class="separator:a16b8fb2ee1e3c5fa6bb52caba21558e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae651d281b4b98215fe2ace4c25b2ecd0"><td class="memItemLeft" align="right" valign="top"><a id="ae651d281b4b98215fe2ace4c25b2ecd0"></a>
virtual double&#160;</td><td class="memItemRight" valign="bottom"><b>calcCodelengthOnModuleOfModules</b> (const <a class="el" href="classNodeBase.html">NodeBase</a> &amp;parent)</td></tr>
<tr class="separator:ae651d281b4b98215fe2ace4c25b2ecd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83f8c77d553b7da850ae770a3cda2ac0"><td class="memItemLeft" align="right" valign="top"><a id="a83f8c77d553b7da850ae770a3cda2ac0"></a>
virtual double&#160;</td><td class="memItemRight" valign="bottom"><b>calcCodelengthOnModuleOfLeafNodes</b> (const <a class="el" href="classNodeBase.html">NodeBase</a> &amp;parent)</td></tr>
<tr class="separator:a83f8c77d553b7da850ae770a3cda2ac0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a912810e1dba306751dacd82acddf373a"><td class="memItemLeft" align="right" valign="top"><a id="a912810e1dba306751dacd82acddf373a"></a>
virtual std::pair&lt; double, double &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>calcCodelength</b> (const <a class="el" href="classNodeBase.html">NodeBase</a> &amp;parent)</td></tr>
<tr class="separator:a912810e1dba306751dacd82acddf373a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6135849730a24a4f3fea57ff32991e5"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classInfomapGreedyCommon.html#af6135849730a24a4f3fea57ff32991e5">initConstantInfomapTerms</a> ()</td></tr>
<tr class="separator:af6135849730a24a4f3fea57ff32991e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae168ab41c18759e09b1a3dff97ee017d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classInfomapGreedyCommon.html#ae168ab41c18759e09b1a3dff97ee017d">calculateCodelengthFromActiveNetwork</a> ()</td></tr>
<tr class="separator:ae168ab41c18759e09b1a3dff97ee017d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17feb30bfa3d448f7933c3fcc237f833"><td class="memItemLeft" align="right" valign="top">virtual unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classInfomapGreedyCommon.html#a17feb30bfa3d448f7933c3fcc237f833">optimizeModules</a> ()</td></tr>
<tr class="separator:a17feb30bfa3d448f7933c3fcc237f833"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b5e71572ae01ce0788f919290903b63"><td class="memItemLeft" align="right" valign="top">virtual unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classInfomapGreedyCommon.html#a3b5e71572ae01ce0788f919290903b63">optimizeModulesCrude</a> ()</td></tr>
<tr class="separator:a3b5e71572ae01ce0788f919290903b63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25af363aae49138b379a823b6ab2ad5c"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classInfomapGreedyCommon.html#a25af363aae49138b379a823b6ab2ad5c">tryMoveEachNodeIntoBestModule</a> ()</td></tr>
<tr class="separator:a25af363aae49138b379a823b6ab2ad5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d0eb8fd059c6d308c53f8c4ed8f10f9"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classInfomapGreedyCommon.html#a5d0eb8fd059c6d308c53f8c4ed8f10f9">tryMoveEachNodeIntoBestModuleParallelizable</a> ()</td></tr>
<tr class="separator:a5d0eb8fd059c6d308c53f8c4ed8f10f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebf032fcd793b9496e5b1952cb14c233"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classInfomapGreedyCommon.html#aebf032fcd793b9496e5b1952cb14c233">tryMoveEachNodeIntoBestModuleInParallel</a> ()</td></tr>
<tr class="separator:aebf032fcd793b9496e5b1952cb14c233"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1026d8aaeb5a5ceeb6c272d6adba431"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classInfomapGreedyCommon.html#ac1026d8aaeb5a5ceeb6c272d6adba431">tryMoveEachNodeIntoStrongestConnectedModule</a> ()</td></tr>
<tr class="separator:ac1026d8aaeb5a5ceeb6c272d6adba431"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affbdd4750e010adba7f1cd15a295303e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classInfomapGreedyCommon.html#affbdd4750e010adba7f1cd15a295303e">moveNodesToPredefinedModules</a> ()</td></tr>
<tr class="separator:affbdd4750e010adba7f1cd15a295303e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4845dbd57d006f5220e6a7d9f293f9d"><td class="memItemLeft" align="right" valign="top">virtual unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classInfomapGreedyCommon.html#ad4845dbd57d006f5220e6a7d9f293f9d">consolidateModules</a> (bool replaceExistingStructure, bool asSubModules)</td></tr>
<tr class="separator:ad4845dbd57d006f5220e6a7d9f293f9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classInfomapGreedySpecialized"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classInfomapGreedySpecialized')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classInfomapGreedySpecialized.html">InfomapGreedySpecialized&lt; derived_traits&lt; InfomapGreedyDerivedType &gt;::flow_type &gt;</a></td></tr>
<tr class="memitem:ab0687122e7aca86d3644802da9435389 inherit pro_methods_classInfomapGreedySpecialized"><td class="memItemLeft" align="right" valign="top"><a id="ab0687122e7aca86d3644802da9435389"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>addTeleportationFlowOnLeafNodes</b> ()</td></tr>
<tr class="separator:ab0687122e7aca86d3644802da9435389 inherit pro_methods_classInfomapGreedySpecialized"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa44b4504548744d27ff60c145f0a7f9 inherit pro_methods_classInfomapGreedySpecialized"><td class="memItemLeft" align="right" valign="top"><a id="afa44b4504548744d27ff60c145f0a7f9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>addTeleportationFlowOnLeafNodes</b> ()</td></tr>
<tr class="separator:afa44b4504548744d27ff60c145f0a7f9 inherit pro_methods_classInfomapGreedySpecialized"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ed422ef6adedd65703ef29cb258e4d5 inherit pro_methods_classInfomapGreedySpecialized"><td class="memItemLeft" align="right" valign="top"><a id="a8ed422ef6adedd65703ef29cb258e4d5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>addTeleportationFlowOnModules</b> ()</td></tr>
<tr class="separator:a8ed422ef6adedd65703ef29cb258e4d5 inherit pro_methods_classInfomapGreedySpecialized"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e08e332374478ccb12de4eee9d67f74 inherit pro_methods_classInfomapGreedySpecialized"><td class="memItemLeft" align="right" valign="top"><a id="a5e08e332374478ccb12de4eee9d67f74"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>addTeleportationFlowOnModules</b> ()</td></tr>
<tr class="separator:a5e08e332374478ccb12de4eee9d67f74 inherit pro_methods_classInfomapGreedySpecialized"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1ccbef79b7e94cf2762aa5a94a28965 inherit pro_methods_classInfomapGreedySpecialized"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>initEnterExitFlow</b> ()</td></tr>
<tr class="separator:ab1ccbef79b7e94cf2762aa5a94a28965 inherit pro_methods_classInfomapGreedySpecialized"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a43bd2e0610fb4e5a9375f1c36202ec inherit pro_methods_classInfomapGreedySpecialized"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classInfomapGreedySpecialized.html#a8a43bd2e0610fb4e5a9375f1c36202ec">initEnterExitFlow</a> ()</td></tr>
<tr class="separator:a8a43bd2e0610fb4e5a9375f1c36202ec inherit pro_methods_classInfomapGreedySpecialized"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d9a4d72c7de6f26100404eb8374fe67 inherit pro_methods_classInfomapGreedySpecialized"><td class="memItemLeft" align="right" valign="top"><a id="a1d9a4d72c7de6f26100404eb8374fe67"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>addTeleportationDeltaFlowOnOldModuleIfMove</b> (<a class="el" href="classNode.html">NodeType</a> &amp;nodeToMove, <a class="el" href="structDeltaFlow.html">DeltaFlow</a> &amp;oldModuleDeltaFlow)</td></tr>
<tr class="separator:a1d9a4d72c7de6f26100404eb8374fe67 inherit pro_methods_classInfomapGreedySpecialized"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75e11276dfb6864051923f5c37797908 inherit pro_methods_classInfomapGreedySpecialized"><td class="memItemLeft" align="right" valign="top"><a id="a75e11276dfb6864051923f5c37797908"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>addTeleportationDeltaFlowOnOldModuleIfMove</b> (<a class="el" href="classNode.html">NodeType</a> &amp;nodeToMove, <a class="el" href="structDeltaFlow.html">DeltaFlow</a> &amp;oldModuleDeltaFlow)</td></tr>
<tr class="separator:a75e11276dfb6864051923f5c37797908 inherit pro_methods_classInfomapGreedySpecialized"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70d972f56b7e75ad7560b6aeb2e83006 inherit pro_methods_classInfomapGreedySpecialized"><td class="memItemLeft" align="right" valign="top"><a id="a70d972f56b7e75ad7560b6aeb2e83006"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>addTeleportationDeltaFlowOnNewModuleIfMove</b> (<a class="el" href="classNode.html">NodeType</a> &amp;nodeToMove, <a class="el" href="structDeltaFlow.html">DeltaFlow</a> &amp;newModuleDeltaFlow)</td></tr>
<tr class="separator:a70d972f56b7e75ad7560b6aeb2e83006 inherit pro_methods_classInfomapGreedySpecialized"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfc2696a5e37ccde0ef2e826e8862634 inherit pro_methods_classInfomapGreedySpecialized"><td class="memItemLeft" align="right" valign="top"><a id="abfc2696a5e37ccde0ef2e826e8862634"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>addTeleportationDeltaFlowOnNewModuleIfMove</b> (<a class="el" href="classNode.html">NodeType</a> &amp;nodeToMove, <a class="el" href="structDeltaFlow.html">DeltaFlow</a> &amp;newModuleDeltaFlow)</td></tr>
<tr class="separator:abfc2696a5e37ccde0ef2e826e8862634 inherit pro_methods_classInfomapGreedySpecialized"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48f09b206d12d895ecbf192c10f87733 inherit pro_methods_classInfomapGreedySpecialized"><td class="memItemLeft" align="right" valign="top"><a id="a48f09b206d12d895ecbf192c10f87733"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>addTeleportationDeltaFlowIfMove</b> (<a class="el" href="classNode.html">NodeType</a> &amp;current, std::vector&lt; DeltaFlowType &gt; &amp;moduleDeltaExits, unsigned int numModuleLinks)</td></tr>
<tr class="separator:a48f09b206d12d895ecbf192c10f87733 inherit pro_methods_classInfomapGreedySpecialized"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17350f602093d70fca05bca4000d41b6 inherit pro_methods_classInfomapGreedySpecialized"><td class="memItemLeft" align="right" valign="top"><a id="a17350f602093d70fca05bca4000d41b6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>addTeleportationDeltaFlowIfMove</b> (<a class="el" href="classNode.html">NodeType</a> &amp;current, std::map&lt; unsigned int, DeltaFlowType &gt; &amp;moduleDeltaFlow)</td></tr>
<tr class="separator:a17350f602093d70fca05bca4000d41b6 inherit pro_methods_classInfomapGreedySpecialized"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74d832086c68afeeafebe629528d3cb5 inherit pro_methods_classInfomapGreedySpecialized"><td class="memItemLeft" align="right" valign="top"><a id="a74d832086c68afeeafebe629528d3cb5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>addTeleportationDeltaFlowIfMove</b> (<a class="el" href="classNode.html">NodeType</a> &amp;current, std::vector&lt; DeltaFlowType &gt; &amp;moduleDeltaExits, unsigned int numModuleLinks)</td></tr>
<tr class="separator:a74d832086c68afeeafebe629528d3cb5 inherit pro_methods_classInfomapGreedySpecialized"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9533b437c55107b55b89aeab4a53967 inherit pro_methods_classInfomapGreedySpecialized"><td class="memItemLeft" align="right" valign="top"><a id="ab9533b437c55107b55b89aeab4a53967"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>addTeleportationDeltaFlowIfMove</b> (<a class="el" href="classNode.html">NodeType</a> &amp;current, std::map&lt; unsigned int, DeltaFlowType &gt; &amp;moduleDeltaFlow)</td></tr>
<tr class="separator:ab9533b437c55107b55b89aeab4a53967 inherit pro_methods_classInfomapGreedySpecialized"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74770140c946e45361a1506b5a2b40fe inherit pro_methods_classInfomapGreedySpecialized"><td class="memItemLeft" align="right" valign="top"><a id="a74770140c946e45361a1506b5a2b40fe"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>getDeltaCodelengthOnMovingNode</b> (<a class="el" href="classNode.html">NodeType</a> &amp;current, <a class="el" href="structDeltaFlow.html">DeltaFlow</a> &amp;oldModuleDelta, <a class="el" href="structDeltaFlow.html">DeltaFlow</a> &amp;newModuleDelta)</td></tr>
<tr class="separator:a74770140c946e45361a1506b5a2b40fe inherit pro_methods_classInfomapGreedySpecialized"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6d5f1312d7ecefeb06ee0812ea38d7f inherit pro_methods_classInfomapGreedySpecialized"><td class="memItemLeft" align="right" valign="top"><a id="ab6d5f1312d7ecefeb06ee0812ea38d7f"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>getDeltaCodelengthOnMovingNode</b> (<a class="el" href="classNode.html">NodeType</a> &amp;current, <a class="el" href="structDeltaFlow.html">DeltaFlow</a> &amp;oldModuleDelta, <a class="el" href="structDeltaFlow.html">DeltaFlow</a> &amp;newModuleDelta)</td></tr>
<tr class="separator:ab6d5f1312d7ecefeb06ee0812ea38d7f inherit pro_methods_classInfomapGreedySpecialized"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f4ff75d89a26f1b474ca5a2190878c7 inherit pro_methods_classInfomapGreedySpecialized"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classInfomapGreedySpecialized.html#a6f4ff75d89a26f1b474ca5a2190878c7">updateCodelengthOnMovingNode</a> (<a class="el" href="classNode.html">NodeType</a> &amp;current, <a class="el" href="structDeltaFlow.html">DeltaFlow</a> &amp;oldModuleDelta, <a class="el" href="structDeltaFlow.html">DeltaFlow</a> &amp;newModuleDelta)</td></tr>
<tr class="separator:a6f4ff75d89a26f1b474ca5a2190878c7 inherit pro_methods_classInfomapGreedySpecialized"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac092082ca150776f3827c1508c5b25b7 inherit pro_methods_classInfomapGreedySpecialized"><td class="memItemLeft" align="right" valign="top"><a id="ac092082ca150776f3827c1508c5b25b7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>updateCodelengthOnMovingNode</b> (<a class="el" href="classNode.html">NodeType</a> &amp;current, <a class="el" href="structDeltaFlow.html">DeltaFlow</a> &amp;oldModuleDelta, <a class="el" href="structDeltaFlow.html">DeltaFlow</a> &amp;newModuleDelta)</td></tr>
<tr class="separator:ac092082ca150776f3827c1508c5b25b7 inherit pro_methods_classInfomapGreedySpecialized"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88be662d41bb5064cd54b7309a831f0c inherit pro_methods_classInfomapGreedySpecialized"><td class="memItemLeft" align="right" valign="top"><a id="a88be662d41bb5064cd54b7309a831f0c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>updateFlowOnMovingNode</b> (<a class="el" href="classNode.html">NodeType</a> &amp;current, <a class="el" href="structDeltaFlow.html">DeltaFlow</a> &amp;oldModuleDelta, <a class="el" href="structDeltaFlow.html">DeltaFlow</a> &amp;newModuleDelta)</td></tr>
<tr class="separator:a88be662d41bb5064cd54b7309a831f0c inherit pro_methods_classInfomapGreedySpecialized"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65b216131a08a0779095acec9572829b inherit pro_methods_classInfomapGreedySpecialized"><td class="memItemLeft" align="right" valign="top"><a id="a65b216131a08a0779095acec9572829b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>updateFlowOnMovingNode</b> (<a class="el" href="classNode.html">NodeType</a> &amp;current, <a class="el" href="structDeltaFlow.html">DeltaFlow</a> &amp;oldModuleDelta, <a class="el" href="structDeltaFlow.html">DeltaFlow</a> &amp;newModuleDelta)</td></tr>
<tr class="separator:a65b216131a08a0779095acec9572829b inherit pro_methods_classInfomapGreedySpecialized"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classInfomapGreedy"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classInfomapGreedy')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classInfomapGreedy.html">InfomapGreedy&lt; InfomapGreedySpecialized&lt; derived_traits&lt; InfomapGreedyDerivedType &gt;::flow_type &gt; &gt;</a></td></tr>
<tr class="memitem:a13210b106c999a0df0e4be8d72347d7a inherit pro_methods_classInfomapGreedy"><td class="memItemLeft" align="right" valign="top"><a id="a13210b106c999a0df0e4be8d72347d7a"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>resetModuleFlowFromLeafNodes</b> ()</td></tr>
<tr class="separator:a13210b106c999a0df0e4be8d72347d7a inherit pro_methods_classInfomapGreedy"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addb5f63b9ea785dd1dea78af55cc4511 inherit pro_methods_classInfomapGreedy"><td class="memItemLeft" align="right" valign="top"><a id="addb5f63b9ea785dd1dea78af55cc4511"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>resetModuleFlow</b> (<a class="el" href="classNodeBase.html">NodeBase</a> &amp;<a class="el" href="structnode.html">node</a>)</td></tr>
<tr class="separator:addb5f63b9ea785dd1dea78af55cc4511 inherit pro_methods_classInfomapGreedy"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcc7d7b67a24a4637fa79c12a7e86a13 inherit pro_methods_classInfomapGreedy"><td class="memItemLeft" align="right" valign="top"><a id="adcc7d7b67a24a4637fa79c12a7e86a13"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>transformNodeFlowToEnterFlow</b> (<a class="el" href="classNodeBase.html">NodeBase</a> *parent)</td></tr>
<tr class="separator:adcc7d7b67a24a4637fa79c12a7e86a13 inherit pro_methods_classInfomapGreedy"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a419dc025fd69b4db6f1ed6822fb4c7d3 inherit pro_methods_classInfomapGreedy"><td class="memItemLeft" align="right" valign="top"><a id="a419dc025fd69b4db6f1ed6822fb4c7d3"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>cloneFlowData</b> (const <a class="el" href="classNodeBase.html">NodeBase</a> &amp;source, <a class="el" href="classNodeBase.html">NodeBase</a> &amp;target)</td></tr>
<tr class="separator:a419dc025fd69b4db6f1ed6822fb4c7d3 inherit pro_methods_classInfomapGreedy"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac48438b67647ba0985ed96e41c3bddcf inherit pro_methods_classInfomapGreedy"><td class="memItemLeft" align="right" valign="top"><a id="ac48438b67647ba0985ed96e41c3bddcf"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>printNodeRanks</b> (std::ostream &amp;out)</td></tr>
<tr class="separator:ac48438b67647ba0985ed96e41c3bddcf inherit pro_methods_classInfomapGreedy"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b30c388daeaa1cc33f35143ab4cb7fb inherit pro_methods_classInfomapGreedy"><td class="memItemLeft" align="right" valign="top"><a id="a0b30c388daeaa1cc33f35143ab4cb7fb"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>printFlowNetwork</b> (std::ostream &amp;out)</td></tr>
<tr class="separator:a0b30c388daeaa1cc33f35143ab4cb7fb inherit pro_methods_classInfomapGreedy"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2469202878f49deb588c5f59eac32035 inherit pro_methods_classInfomapGreedy"><td class="memItemLeft" align="right" valign="top"><a id="a2469202878f49deb588c5f59eac32035"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>sortTree</b> (<a class="el" href="classNodeBase.html">NodeBase</a> &amp;parent)</td></tr>
<tr class="separator:a2469202878f49deb588c5f59eac32035 inherit pro_methods_classInfomapGreedy"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa523c48982fe29a2ed56a277066a1a4d inherit pro_methods_classInfomapGreedy"><td class="memItemLeft" align="right" valign="top"><a id="aa523c48982fe29a2ed56a277066a1a4d"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>saveHierarchicalNetwork</b> (<a class="el" href="classHierarchicalNetwork.html">HierarchicalNetwork</a> &amp;output, std::string rootName, bool includeLinks)</td></tr>
<tr class="separator:aa523c48982fe29a2ed56a277066a1a4d inherit pro_methods_classInfomapGreedy"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a661c0fcd1f35daf78c882b636d6c562b inherit pro_methods_classInfomapGreedy"><td class="memItemLeft" align="right" valign="top"><a id="a661c0fcd1f35daf78c882b636d6c562b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>buildHierarchicalNetworkHelper</b> (<a class="el" href="classHierarchicalNetwork.html">HierarchicalNetwork</a> &amp;hierarchicalNetwork, <a class="el" href="classSNode.html">HierarchicalNetwork::node_type</a> &amp;parent, std::vector&lt; std::string &gt; &amp;leafNodeNames, <a class="el" href="classNodeBase.html">NodeBase</a> *<a class="el" href="structnode.html">node</a>=0)</td></tr>
<tr class="separator:a661c0fcd1f35daf78c882b636d6c562b inherit pro_methods_classInfomapGreedy"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a5a5ca2ea604828316528997cec3f4f inherit pro_methods_classInfomapGreedy"><td class="memItemLeft" align="right" valign="top"><a id="a3a5a5ca2ea604828316528997cec3f4f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>buildHierarchicalNetworkHelper</b> (<a class="el" href="classHierarchicalNetwork.html">HierarchicalNetwork</a> &amp;hierarchicalNetwork, <a class="el" href="classSNode.html">HierarchicalNetwork::node_type</a> &amp;parent, std::deque&lt; std::pair&lt; <a class="el" href="classNodeBase.html">NodeBase</a> *, <a class="el" href="classSNode.html">HierarchicalNetwork::node_type</a> * &gt; &gt; &amp;leafModules, <a class="el" href="classNodeBase.html">NodeBase</a> *<a class="el" href="structnode.html">node</a>=0)</td></tr>
<tr class="separator:a3a5a5ca2ea604828316528997cec3f4f inherit pro_methods_classInfomapGreedy"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11a1d5d91080168d356af81cc94cde35 inherit pro_methods_classInfomapGreedy"><td class="memItemLeft" align="right" valign="top"><a id="a11a1d5d91080168d356af81cc94cde35"></a>
<a class="el" href="classNode.html">NodeType</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getNode</b> (<a class="el" href="classNodeBase.html">NodeBase</a> &amp;<a class="el" href="structnode.html">node</a>)</td></tr>
<tr class="separator:a11a1d5d91080168d356af81cc94cde35 inherit pro_methods_classInfomapGreedy"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18b88ba06696752b0a0f2d3fd88bcf34 inherit pro_methods_classInfomapGreedy"><td class="memItemLeft" align="right" valign="top"><a id="a18b88ba06696752b0a0f2d3fd88bcf34"></a>
const <a class="el" href="classNode.html">NodeType</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getNode</b> (const <a class="el" href="classNodeBase.html">NodeBase</a> &amp;<a class="el" href="structnode.html">node</a>) const</td></tr>
<tr class="separator:a18b88ba06696752b0a0f2d3fd88bcf34 inherit pro_methods_classInfomapGreedy"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa5cb942809843ac68555b8968550ce5 inherit pro_methods_classInfomapGreedy"><td class="memItemLeft" align="right" valign="top"><a id="aaa5cb942809843ac68555b8968550ce5"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>numActiveModules</b> ()</td></tr>
<tr class="separator:aaa5cb942809843ac68555b8968550ce5 inherit pro_methods_classInfomapGreedy"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6e095686aba6d35b9c9d0b46d4331f9 inherit pro_methods_classInfomapGreedy"><td class="memItemLeft" align="right" valign="top"><a id="ae6e095686aba6d35b9c9d0b46d4331f9"></a>
virtual unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>numDynamicModules</b> ()</td></tr>
<tr class="separator:ae6e095686aba6d35b9c9d0b46d4331f9 inherit pro_methods_classInfomapGreedy"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e437f8a037687eec90c2e5019765049 inherit pro_methods_classInfomapGreedy"><td class="memItemLeft" align="right" valign="top"><a id="a8e437f8a037687eec90c2e5019765049"></a>
virtual <a class="el" href="structFlowDummy.html">FlowDummy</a>&#160;</td><td class="memItemRight" valign="bottom"><b>getNodeData</b> (<a class="el" href="classNodeBase.html">NodeBase</a> &amp;<a class="el" href="structnode.html">node</a>)</td></tr>
<tr class="separator:a8e437f8a037687eec90c2e5019765049 inherit pro_methods_classInfomapGreedy"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2643c17305063ecdce23a6e21893fa98 inherit pro_methods_classInfomapGreedy"><td class="memItemLeft" align="right" valign="top"><a id="a2643c17305063ecdce23a6e21893fa98"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>debugPrintInfomapTerms</b> ()</td></tr>
<tr class="separator:a2643c17305063ecdce23a6e21893fa98 inherit pro_methods_classInfomapGreedy"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classInfomapBase"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classInfomapBase')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classInfomapBase.html">InfomapBase</a></td></tr>
<tr class="memitem:a3b07335e7bdce0858a15b009d9265db6 inherit pro_methods_classInfomapBase"><td class="memItemLeft" align="right" valign="top"><a id="a3b07335e7bdce0858a15b009d9265db6"></a>
virtual std::vector&lt; <a class="el" href="structPhysData.html">PhysData</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getPhysicalMembers</b> (<a class="el" href="classNodeBase.html">NodeBase</a> &amp;<a class="el" href="structnode.html">node</a>)=0</td></tr>
<tr class="separator:a3b07335e7bdce0858a15b009d9265db6 inherit pro_methods_classInfomapBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add32bae3484c40b5613fcdac33c1ba7a inherit pro_methods_classInfomapBase"><td class="memItemLeft" align="right" valign="top"><a id="add32bae3484c40b5613fcdac33c1ba7a"></a>
virtual <a class="el" href="structStateNode.html">StateNode</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getMemoryNode</b> (<a class="el" href="classNodeBase.html">NodeBase</a> &amp;<a class="el" href="structnode.html">node</a>)=0</td></tr>
<tr class="separator:add32bae3484c40b5613fcdac33c1ba7a inherit pro_methods_classInfomapBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13278a18743abf7336ceef12965b1cf7 inherit pro_methods_classInfomapBase"><td class="memItemLeft" align="right" valign="top"><a id="a13278a18743abf7336ceef12965b1cf7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>initPreClustering</b> (bool printResults=false)</td></tr>
<tr class="separator:a13278a18743abf7336ceef12965b1cf7 inherit pro_methods_classInfomapBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8347fea5ed1cd22a27c7d972496e7d90 inherit pro_methods_classInfomapBase"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classInfomapBase.html#a8347fea5ed1cd22a27c7d972496e7d90">initModuleOptimization</a> ()=0</td></tr>
<tr class="separator:a8347fea5ed1cd22a27c7d972496e7d90 inherit pro_methods_classInfomapBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c47213c7fb80fed3ee0febf213d0a3c inherit pro_methods_classInfomapBase"><td class="memItemLeft" align="right" valign="top"><a id="a6c47213c7fb80fed3ee0febf213d0a3c"></a>
virtual std::auto_ptr&lt; <a class="el" href="classInfomapBase.html">InfomapBase</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getNewInfomapInstanceWithoutMemory</b> ()=0</td></tr>
<tr class="separator:a6c47213c7fb80fed3ee0febf213d0a3c inherit pro_methods_classInfomapBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada59370de9cad46ea24d1d3cdc85121f inherit pro_methods_classInfomapBase"><td class="memItemLeft" align="right" valign="top"><a id="ada59370de9cad46ea24d1d3cdc85121f"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>generateNetworkFromChildren</b> (<a class="el" href="classNodeBase.html">NodeBase</a> &amp;parent)=0</td></tr>
<tr class="separator:ada59370de9cad46ea24d1d3cdc85121f inherit pro_methods_classInfomapBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53664f99d89e22c5175e00c9ed934b64 inherit pro_methods_classInfomapBase"><td class="memItemLeft" align="right" valign="top"><a id="a53664f99d89e22c5175e00c9ed934b64"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>numNonTrivialTopModules</b> ()</td></tr>
<tr class="separator:a53664f99d89e22c5175e00c9ed934b64 inherit pro_methods_classInfomapBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbd9e063924f287b9b0e57bb9e814ed9 inherit pro_methods_classInfomapBase"><td class="memItemLeft" align="right" valign="top"><a id="afbd9e063924f287b9b0e57bb9e814ed9"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>numTopModules</b> ()</td></tr>
<tr class="separator:afbd9e063924f287b9b0e57bb9e814ed9 inherit pro_methods_classInfomapBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3e574923c01fd92b79dfd1b40243846 inherit pro_methods_classInfomapBase"><td class="memItemLeft" align="right" valign="top"><a id="aa3e574923c01fd92b79dfd1b40243846"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>numLeafNodes</b> ()</td></tr>
<tr class="separator:aa3e574923c01fd92b79dfd1b40243846 inherit pro_methods_classInfomapBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83dc486ce25757727437aaefa39a12a0 inherit pro_methods_classInfomapBase"><td class="memItemLeft" align="right" valign="top"><a id="a83dc486ce25757727437aaefa39a12a0"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isTopLevel</b> ()</td></tr>
<tr class="separator:a83dc486ce25757727437aaefa39a12a0 inherit pro_methods_classInfomapBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6aa3e0a34a98efa520e68301c6e7f2fd inherit pro_methods_classInfomapBase"><td class="memItemLeft" align="right" valign="top"><a id="a6aa3e0a34a98efa520e68301c6e7f2fd"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isSuperLevelOnTopLevel</b> ()</td></tr>
<tr class="separator:a6aa3e0a34a98efa520e68301c6e7f2fd inherit pro_methods_classInfomapBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14711330a837a9063a6548f783570c18 inherit pro_methods_classInfomapBase"><td class="memItemLeft" align="right" valign="top"><a id="a14711330a837a9063a6548f783570c18"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isFullNetwork</b> ()</td></tr>
<tr class="separator:a14711330a837a9063a6548f783570c18 inherit pro_methods_classInfomapBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2612f2f214e5673f89973c7f421d15cc inherit pro_methods_classInfomapBase"><td class="memItemLeft" align="right" valign="top"><a id="a2612f2f214e5673f89973c7f421d15cc"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isFirstLoop</b> ()</td></tr>
<tr class="separator:a2612f2f214e5673f89973c7f421d15cc inherit pro_methods_classInfomapBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a080bdf84b2d311b3348ac8548b832df4 inherit pro_methods_classInfomapBase"><td class="memItemLeft" align="right" valign="top"><a id="a080bdf84b2d311b3348ac8548b832df4"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>haveModules</b> ()</td></tr>
<tr class="separator:a080bdf84b2d311b3348ac8548b832df4 inherit pro_methods_classInfomapBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab381afa30992135f54611f8f1c5797dc inherit pro_methods_classInfomapBase"><td class="memItemLeft" align="right" valign="top"><a id="ab381afa30992135f54611f8f1c5797dc"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>haveSubModules</b> ()</td></tr>
<tr class="separator:ab381afa30992135f54611f8f1c5797dc inherit pro_methods_classInfomapBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd4a4685d08ee59f39e65734d28cd3f1 inherit pro_methods_classInfomapBase"><td class="memItemLeft" align="right" valign="top"><a id="afd4a4685d08ee59f39e65734d28cd3f1"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>useHardPartitions</b> ()</td></tr>
<tr class="separator:afd4a4685d08ee59f39e65734d28cd3f1 inherit pro_methods_classInfomapBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bd3b453a38dd0af27aa664e5e4d73ce inherit pro_methods_classInfomapBase"><td class="memItemLeft" align="right" valign="top"><a id="a8bd3b453a38dd0af27aa664e5e4d73ce"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>getLevelAggregationLimit</b> ()</td></tr>
<tr class="separator:a8bd3b453a38dd0af27aa664e5e4d73ce inherit pro_methods_classInfomapBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2f0af29d538027add1d82464dd04508 inherit pro_methods_classInfomapBase"><td class="memItemLeft" align="right" valign="top"><a id="ab2f0af29d538027add1d82464dd04508"></a>
unsigned long int&#160;</td><td class="memItemRight" valign="bottom"><b>getSeedFromCodelength</b> (double value)</td></tr>
<tr class="separator:ab2f0af29d538027add1d82464dd04508 inherit pro_methods_classInfomapBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc239c6037c43021c79c6e5f997d7be6 inherit pro_methods_classInfomapBase"><td class="memItemLeft" align="right" valign="top"><a id="afc239c6037c43021c79c6e5f997d7be6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>reseed</b> (unsigned long int seed)</td></tr>
<tr class="separator:afc239c6037c43021c79c6e5f997d7be6 inherit pro_methods_classInfomapBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:aca47c78ffb35ca1a504ee5ed811adce4"><td class="memItemLeft" align="right" valign="top"><a id="aca47c78ffb35ca1a504ee5ed811adce4"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>m_coreLoopCount</b></td></tr>
<tr class="separator:aca47c78ffb35ca1a504ee5ed811adce4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_classInfomapGreedySpecialized"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classInfomapGreedySpecialized')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classInfomapGreedySpecialized.html">InfomapGreedySpecialized&lt; derived_traits&lt; InfomapGreedyDerivedType &gt;::flow_type &gt;</a></td></tr>
<tr class="memitem:a0e21c84a547706c86a2049db1a5e3c89 inherit pro_attribs_classInfomapGreedySpecialized"><td class="memItemLeft" align="right" valign="top"><a id="a0e21c84a547706c86a2049db1a5e3c89"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>m_sumDanglingFlow</b></td></tr>
<tr class="separator:a0e21c84a547706c86a2049db1a5e3c89 inherit pro_attribs_classInfomapGreedySpecialized"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_classInfomapGreedy"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classInfomapGreedy')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classInfomapGreedy.html">InfomapGreedy&lt; InfomapGreedySpecialized&lt; derived_traits&lt; InfomapGreedyDerivedType &gt;::flow_type &gt; &gt;</a></td></tr>
<tr class="memitem:a052836aaf0028764e15fcd76db739ed9 inherit pro_attribs_classInfomapGreedy"><td class="memItemLeft" align="right" valign="top"><a id="a052836aaf0028764e15fcd76db739ed9"></a>
std::vector&lt; FlowType &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>m_moduleFlowData</b></td></tr>
<tr class="separator:a052836aaf0028764e15fcd76db739ed9 inherit pro_attribs_classInfomapGreedy"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c76d10f30540fce14025bb77bf41322 inherit pro_attribs_classInfomapGreedy"><td class="memItemLeft" align="right" valign="top"><a id="a7c76d10f30540fce14025bb77bf41322"></a>
std::vector&lt; unsigned int &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>m_moduleMembers</b></td></tr>
<tr class="separator:a7c76d10f30540fce14025bb77bf41322 inherit pro_attribs_classInfomapGreedy"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d40eaa16a290b50838d39c387cd4070 inherit pro_attribs_classInfomapGreedy"><td class="memItemLeft" align="right" valign="top"><a id="a9d40eaa16a290b50838d39c387cd4070"></a>
std::vector&lt; unsigned int &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>m_emptyModules</b></td></tr>
<tr class="separator:a9d40eaa16a290b50838d39c387cd4070 inherit pro_attribs_classInfomapGreedy"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade6d21317f10d6aa8d5f56ccd964e6c4 inherit pro_attribs_classInfomapGreedy"><td class="memItemLeft" align="right" valign="top"><a id="ade6d21317f10d6aa8d5f56ccd964e6c4"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>nodeFlow_log_nodeFlow</b></td></tr>
<tr class="separator:ade6d21317f10d6aa8d5f56ccd964e6c4 inherit pro_attribs_classInfomapGreedy"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26265300752e6b42f4af59b9d69832f3 inherit pro_attribs_classInfomapGreedy"><td class="memItemLeft" align="right" valign="top"><a id="a26265300752e6b42f4af59b9d69832f3"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>flow_log_flow</b></td></tr>
<tr class="separator:a26265300752e6b42f4af59b9d69832f3 inherit pro_attribs_classInfomapGreedy"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79a94c676b1242614833c14dc1e24dd7 inherit pro_attribs_classInfomapGreedy"><td class="memItemLeft" align="right" valign="top"><a id="a79a94c676b1242614833c14dc1e24dd7"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>exit_log_exit</b></td></tr>
<tr class="separator:a79a94c676b1242614833c14dc1e24dd7 inherit pro_attribs_classInfomapGreedy"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87dfb511c2468b75f0ff100ad0a230c8 inherit pro_attribs_classInfomapGreedy"><td class="memItemLeft" align="right" valign="top"><a id="a87dfb511c2468b75f0ff100ad0a230c8"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>enter_log_enter</b></td></tr>
<tr class="separator:a87dfb511c2468b75f0ff100ad0a230c8 inherit pro_attribs_classInfomapGreedy"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac25a9968e64d1de82b2ebbc751b1215 inherit pro_attribs_classInfomapGreedy"><td class="memItemLeft" align="right" valign="top"><a id="aac25a9968e64d1de82b2ebbc751b1215"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>enterFlow</b></td></tr>
<tr class="separator:aac25a9968e64d1de82b2ebbc751b1215 inherit pro_attribs_classInfomapGreedy"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ac6dc942e2854f92ae50bdfb4e0e636 inherit pro_attribs_classInfomapGreedy"><td class="memItemLeft" align="right" valign="top"><a id="a1ac6dc942e2854f92ae50bdfb4e0e636"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>enterFlow_log_enterFlow</b></td></tr>
<tr class="separator:a1ac6dc942e2854f92ae50bdfb4e0e636 inherit pro_attribs_classInfomapGreedy"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acba5802ba37d9ec690af9ed646af9068 inherit pro_attribs_classInfomapGreedy"><td class="memItemLeft" align="right" valign="top"><a id="acba5802ba37d9ec690af9ed646af9068"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>exitNetworkFlow</b></td></tr>
<tr class="separator:acba5802ba37d9ec690af9ed646af9068 inherit pro_attribs_classInfomapGreedy"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09851fa2fe22cd6f1081884e2c40fd32 inherit pro_attribs_classInfomapGreedy"><td class="memItemLeft" align="right" valign="top"><a id="a09851fa2fe22cd6f1081884e2c40fd32"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>exitNetworkFlow_log_exitNetworkFlow</b></td></tr>
<tr class="separator:a09851fa2fe22cd6f1081884e2c40fd32 inherit pro_attribs_classInfomapGreedy"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_classInfomapBase"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classInfomapBase')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classInfomapBase.html">InfomapBase</a></td></tr>
<tr class="memitem:ad864fffe327deeff79a57f6f5c9a206e inherit pro_attribs_classInfomapBase"><td class="memItemLeft" align="right" valign="top"><a id="ad864fffe327deeff79a57f6f5c9a206e"></a>
<a class="el" href="structConfig.html">Config</a>&#160;</td><td class="memItemRight" valign="bottom"><b>m_config</b></td></tr>
<tr class="separator:ad864fffe327deeff79a57f6f5c9a206e inherit pro_attribs_classInfomapBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af26209a483326cbc9ceb3aaa203a5199 inherit pro_attribs_classInfomapBase"><td class="memItemLeft" align="right" valign="top"><a id="af26209a483326cbc9ceb3aaa203a5199"></a>
<a class="el" href="classMTRand.html">MTRand</a>&#160;</td><td class="memItemRight" valign="bottom"><b>m_rand</b></td></tr>
<tr class="separator:af26209a483326cbc9ceb3aaa203a5199 inherit pro_attribs_classInfomapBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e325b3b37a623dbe5ce66e95bfddd3c inherit pro_attribs_classInfomapBase"><td class="memItemLeft" align="right" valign="top"><a id="a4e325b3b37a623dbe5ce66e95bfddd3c"></a>
<a class="el" href="classTreeData.html">TreeData</a>&#160;</td><td class="memItemRight" valign="bottom"><b>m_treeData</b></td></tr>
<tr class="separator:a4e325b3b37a623dbe5ce66e95bfddd3c inherit pro_attribs_classInfomapBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac51c8b09b5c2cb8c36123845d474aab7 inherit pro_attribs_classInfomapBase"><td class="memItemLeft" align="right" valign="top"><a id="ac51c8b09b5c2cb8c36123845d474aab7"></a>
std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>m_nodeNames</b></td></tr>
<tr class="separator:ac51c8b09b5c2cb8c36123845d474aab7 inherit pro_attribs_classInfomapBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c9cf55bef3392f7a3ace0c38e407588 inherit pro_attribs_classInfomapBase"><td class="memItemLeft" align="right" valign="top"><a id="a3c9cf55bef3392f7a3ace0c38e407588"></a>
std::vector&lt; <a class="el" href="classNodeBase.html">NodeBase</a> * &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>m_activeNetwork</b></td></tr>
<tr class="separator:a3c9cf55bef3392f7a3ace0c38e407588 inherit pro_attribs_classInfomapBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86d9e83a4d4089744113c84d3f2d5e98 inherit pro_attribs_classInfomapBase"><td class="memItemLeft" align="right" valign="top"><a id="a86d9e83a4d4089744113c84d3f2d5e98"></a>
std::vector&lt; unsigned int &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>m_moveTo</b></td></tr>
<tr class="separator:a86d9e83a4d4089744113c84d3f2d5e98 inherit pro_attribs_classInfomapBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef852877a7ecf8c88bd1b4fb22dd0cd2 inherit pro_attribs_classInfomapBase"><td class="memItemLeft" align="right" valign="top"><a id="aef852877a7ecf8c88bd1b4fb22dd0cd2"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>m_isCoarseTune</b></td></tr>
<tr class="separator:aef852877a7ecf8c88bd1b4fb22dd0cd2 inherit pro_attribs_classInfomapBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f6004f65c7c000985643b5f74fe9ec7 inherit pro_attribs_classInfomapBase"><td class="memItemLeft" align="right" valign="top"><a id="a0f6004f65c7c000985643b5f74fe9ec7"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>m_trialIndex</b></td></tr>
<tr class="separator:a0f6004f65c7c000985643b5f74fe9ec7 inherit pro_attribs_classInfomapBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66cec7b6ee5b864117f001acf2b2ba24 inherit pro_attribs_classInfomapBase"><td class="memItemLeft" align="right" valign="top"><a id="a66cec7b6ee5b864117f001acf2b2ba24"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>m_tuneIterationIndex</b></td></tr>
<tr class="separator:a66cec7b6ee5b864117f001acf2b2ba24 inherit pro_attribs_classInfomapBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a836bc7654d622f5ca119d45cbb5b72c3 inherit pro_attribs_classInfomapBase"><td class="memItemLeft" align="right" valign="top"><a id="a836bc7654d622f5ca119d45cbb5b72c3"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>m_aggregationLevel</b></td></tr>
<tr class="separator:a836bc7654d622f5ca119d45cbb5b72c3 inherit pro_attribs_classInfomapBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dd41789ae9237970c18582fc6154830 inherit pro_attribs_classInfomapBase"><td class="memItemLeft" align="right" valign="top"><a id="a0dd41789ae9237970c18582fc6154830"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>m_numNonTrivialTopModules</b></td></tr>
<tr class="separator:a0dd41789ae9237970c18582fc6154830 inherit pro_attribs_classInfomapBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7c51398734e88e0dadc61f881b92599 inherit pro_attribs_classInfomapBase"><td class="memItemLeft" align="right" valign="top"><a id="ad7c51398734e88e0dadc61f881b92599"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>m_subLevel</b></td></tr>
<tr class="separator:ad7c51398734e88e0dadc61f881b92599 inherit pro_attribs_classInfomapBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a685bea4bbc52e7125950431373c18db7 inherit pro_attribs_classInfomapBase"><td class="memItemLeft" align="right" valign="top"><a id="a685bea4bbc52e7125950431373c18db7"></a>
const unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>m_TOP_LEVEL_ADDITION</b></td></tr>
<tr class="separator:a685bea4bbc52e7125950431373c18db7 inherit pro_attribs_classInfomapBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9a7c497570a187787194e341cd8946e inherit pro_attribs_classInfomapBase"><td class="memItemLeft" align="right" valign="top"><a id="ad9a7c497570a187787194e341cd8946e"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>oneLevelCodelength</b></td></tr>
<tr class="separator:ad9a7c497570a187787194e341cd8946e inherit pro_attribs_classInfomapBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74526eeb7ed801c098c49205a95310f0 inherit pro_attribs_classInfomapBase"><td class="memItemLeft" align="right" valign="top"><a id="a74526eeb7ed801c098c49205a95310f0"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>codelength</b></td></tr>
<tr class="separator:a74526eeb7ed801c098c49205a95310f0 inherit pro_attribs_classInfomapBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1a474d23c1e1d463f88ed04f350d984 inherit pro_attribs_classInfomapBase"><td class="memItemLeft" align="right" valign="top"><a id="ae1a474d23c1e1d463f88ed04f350d984"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>indexCodelength</b></td></tr>
<tr class="separator:ae1a474d23c1e1d463f88ed04f350d984 inherit pro_attribs_classInfomapBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48d4beb1bd668bd4d6bf6b2d903974cb inherit pro_attribs_classInfomapBase"><td class="memItemLeft" align="right" valign="top"><a id="a48d4beb1bd668bd4d6bf6b2d903974cb"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>moduleCodelength</b></td></tr>
<tr class="separator:a48d4beb1bd668bd4d6bf6b2d903974cb inherit pro_attribs_classInfomapBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4963cfc549ccddf4d44b45bd0256d76 inherit pro_attribs_classInfomapBase"><td class="memItemLeft" align="right" valign="top"><a id="aa4963cfc549ccddf4d44b45bd0256d76"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>hierarchicalCodelength</b></td></tr>
<tr class="separator:aa4963cfc549ccddf4d44b45bd0256d76 inherit pro_attribs_classInfomapBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7adef48b01710e6172252878cc73bc92 inherit pro_attribs_classInfomapBase"><td class="memItemLeft" align="right" valign="top"><a id="a7adef48b01710e6172252878cc73bc92"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>bestHierarchicalCodelength</b></td></tr>
<tr class="separator:a7adef48b01710e6172252878cc73bc92 inherit pro_attribs_classInfomapBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af76299594197c87a986b88bc731520c9 inherit pro_attribs_classInfomapBase"><td class="memItemLeft" align="right" valign="top"><a id="af76299594197c87a986b88bc731520c9"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>bestIntermediateCodelength</b></td></tr>
<tr class="separator:af76299594197c87a986b88bc731520c9 inherit pro_attribs_classInfomapBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a977d4acbc74556676815a9dc53e024 inherit pro_attribs_classInfomapBase"><td class="memItemLeft" align="right" valign="top"><a id="a5a977d4acbc74556676815a9dc53e024"></a>
std::ostringstream&#160;</td><td class="memItemRight" valign="bottom"><b>bestIntermediateStatistics</b></td></tr>
<tr class="separator:a5a977d4acbc74556676815a9dc53e024 inherit pro_attribs_classInfomapBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addc56af424e75045a5267e24f54d0fd2 inherit pro_attribs_classInfomapBase"><td class="memItemLeft" align="right" valign="top"><a id="addc56af424e75045a5267e24f54d0fd2"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>m_initialMaxNumberOfModularLevels</b></td></tr>
<tr class="separator:addc56af424e75045a5267e24f54d0fd2 inherit pro_attribs_classInfomapBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af38843e45aa8dfbb152cf1afec177284 inherit pro_attribs_classInfomapBase"><td class="memItemLeft" align="right" valign="top"><a id="af38843e45aa8dfbb152cf1afec177284"></a>
<a class="el" href="classHierarchicalNetwork.html">HierarchicalNetwork</a>&#160;</td><td class="memItemRight" valign="bottom"><b>m_ioNetwork</b></td></tr>
<tr class="separator:af38843e45aa8dfbb152cf1afec177284 inherit pro_attribs_classInfomapBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1255bc8c63d90d691ecc3036e69a9616 inherit pro_attribs_classInfomapBase"><td class="memItemLeft" align="right" valign="top"><a id="a1255bc8c63d90d691ecc3036e69a9616"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>m_externalOutput</b></td></tr>
<tr class="separator:a1255bc8c63d90d691ecc3036e69a9616 inherit pro_attribs_classInfomapBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad29b0a59237bca92eb644b4c30ee83d7 inherit pro_attribs_classInfomapBase"><td class="memItemLeft" align="right" valign="top"><a id="ad29b0a59237bca92eb644b4c30ee83d7"></a>
std::vector&lt; <a class="el" href="structPerIterationStats.html">PerIterationStats</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>m_iterationStats</b></td></tr>
<tr class="separator:ad29b0a59237bca92eb644b4c30ee83d7 inherit pro_attribs_classInfomapBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54d9b0ca622edb831bf6a918770ed965 inherit pro_attribs_classInfomapBase"><td class="memItemLeft" align="right" valign="top"><a id="a54d9b0ca622edb831bf6a918770ed965"></a>
std::ostringstream&#160;</td><td class="memItemRight" valign="bottom"><b>bestSolutionStatistics</b></td></tr>
<tr class="separator:a54d9b0ca622edb831bf6a918770ed965 inherit pro_attribs_classInfomapBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30ebedcdd39e023f72dbdf355be90577 inherit pro_attribs_classInfomapBase"><td class="memItemLeft" align="right" valign="top"><a id="a30ebedcdd39e023f72dbdf355be90577"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>bestNumLevels</b></td></tr>
<tr class="separator:a30ebedcdd39e023f72dbdf355be90577 inherit pro_attribs_classInfomapBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_types_classInfomapGreedy"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classInfomapGreedy')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classInfomapGreedy.html">InfomapGreedy&lt; InfomapGreedySpecialized&lt; derived_traits&lt; InfomapGreedyDerivedType &gt;::flow_type &gt; &gt;</a></td></tr>
<tr class="memitem:a26946b4543a062c5aa9562aa9d173604 inherit pub_types_classInfomapGreedy"><td class="memItemLeft" align="right" valign="top"><a id="a26946b4543a062c5aa9562aa9d173604"></a>
typedef <a class="el" href="structderived__traits.html">derived_traits</a>&lt; <a class="el" href="classInfomapGreedySpecialized.html">InfomapGreedySpecialized</a>&lt; <a class="el" href="structderived__traits.html">derived_traits</a>&lt; InfomapGreedyDerivedType &gt;::flow_type &gt; &gt;::flow_type&#160;</td><td class="memItemRight" valign="bottom"><b>FlowType</b></td></tr>
<tr class="separator:a26946b4543a062c5aa9562aa9d173604 inherit pub_types_classInfomapGreedy"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1183efde6aeba9e84d3b58d3ef9fc501 inherit pub_types_classInfomapGreedy"><td class="memItemLeft" align="right" valign="top"><a id="a1183efde6aeba9e84d3b58d3ef9fc501"></a>
typedef <a class="el" href="structflowData__traits.html">flowData_traits</a>&lt; FlowType &gt;::detailed_balance_type&#160;</td><td class="memItemRight" valign="bottom"><b>DetailedBalanceType</b></td></tr>
<tr class="separator:a1183efde6aeba9e84d3b58d3ef9fc501 inherit pub_types_classInfomapGreedy"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0cdcb030bea05e21b00fccdadb2311d inherit pub_types_classInfomapGreedy"><td class="memItemLeft" align="right" valign="top"><a id="af0cdcb030bea05e21b00fccdadb2311d"></a>
typedef <a class="el" href="structflowData__traits.html">flowData_traits</a>&lt; FlowType &gt;::directed_with_recorded_teleportation_type&#160;</td><td class="memItemRight" valign="bottom"><b>DirectedWithRecordedTeleportationType</b></td></tr>
<tr class="separator:af0cdcb030bea05e21b00fccdadb2311d inherit pub_types_classInfomapGreedy"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a6501d0b50513b09d1067a0389ddcd5 inherit pub_types_classInfomapGreedy"><td class="memItemLeft" align="right" valign="top"><a id="a0a6501d0b50513b09d1067a0389ddcd5"></a>
typedef <a class="el" href="structflowData__traits.html">flowData_traits</a>&lt; FlowType &gt;::teleportation_type&#160;</td><td class="memItemRight" valign="bottom"><b>TeleportationType</b></td></tr>
<tr class="separator:a0a6501d0b50513b09d1067a0389ddcd5 inherit pub_types_classInfomapGreedy"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f8feee3326cf749904ed392f5c6bbfe inherit pub_types_classInfomapGreedy"><td class="memItemLeft" align="right" valign="top"><a id="a4f8feee3326cf749904ed392f5c6bbfe"></a>
typedef <a class="el" href="classNode.html">Node</a>&lt; FlowType &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>NodeType</b></td></tr>
<tr class="separator:a4f8feee3326cf749904ed392f5c6bbfe inherit pub_types_classInfomapGreedy"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf8eb913e5a12c583b95a2589e5bcc09 inherit pub_types_classInfomapGreedy"><td class="memItemLeft" align="right" valign="top"><a id="aaf8eb913e5a12c583b95a2589e5bcc09"></a>
typedef <a class="el" href="classEdge.html">Edge</a>&lt; <a class="el" href="classNodeBase.html">NodeBase</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>EdgeType</b></td></tr>
<tr class="separator:aaf8eb913e5a12c583b95a2589e5bcc09 inherit pub_types_classInfomapGreedy"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_types_classInfomapBase"><td colspan="2" onclick="javascript:toggleInherit('pro_types_classInfomapBase')"><img src="closed.png" alt="-"/>&#160;Protected Types inherited from <a class="el" href="classInfomapBase.html">InfomapBase</a></td></tr>
<tr class="memitem:aa518ba75554156fa59a7a33b4ada17d6 inherit pro_types_classInfomapBase"><td class="memItemLeft" align="right" valign="top"><a id="aa518ba75554156fa59a7a33b4ada17d6"></a>
typedef <a class="el" href="classEdge.html">Edge</a>&lt; <a class="el" href="classNodeBase.html">NodeBase</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>EdgeType</b></td></tr>
<tr class="separator:aa518ba75554156fa59a7a33b4ada17d6 inherit pro_types_classInfomapBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d6f282c78e746621d33ca8a99d4230f inherit pro_types_classInfomapBase"><td class="memItemLeft" align="right" valign="top"><a id="a5d6f282c78e746621d33ca8a99d4230f"></a>
typedef std::vector&lt; <a class="el" href="classNodeBase.html">NodeBase</a> * &gt;::iterator&#160;</td><td class="memItemRight" valign="bottom"><b>activeNetwork_iterator</b></td></tr>
<tr class="separator:a5d6f282c78e746621d33ca8a99d4230f inherit pro_types_classInfomapBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ae168ab41c18759e09b1a3dff97ee017d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae168ab41c18759e09b1a3dff97ee017d">&#9670;&nbsp;</a></span>calculateCodelengthFromActiveNetwork()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InfomapGreedyDerivedType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classInfomapGreedyCommon.html">InfomapGreedyCommon</a>&lt; InfomapGreedyDerivedType &gt;::calculateCodelengthFromActiveNetwork </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Specialized for the case when enter and exit flow may differ </p>
<div class="fragment"><div class="line"><a name="l00334"></a><span class="lineno">  334</span>&#160;{</div><div class="line"><a name="l00335"></a><span class="lineno">  335</span>&#160;    Super::enter_log_enter = 0.0;</div><div class="line"><a name="l00336"></a><span class="lineno">  336</span>&#160;    Super::flow_log_flow = 0.0;</div><div class="line"><a name="l00337"></a><span class="lineno">  337</span>&#160;    Super::exit_log_exit = 0.0;</div><div class="line"><a name="l00338"></a><span class="lineno">  338</span>&#160;    Super::enterFlow = 0.0;</div><div class="line"><a name="l00339"></a><span class="lineno">  339</span>&#160;</div><div class="line"><a name="l00340"></a><span class="lineno">  340</span>&#160;    <span class="comment">// For each module</span></div><div class="line"><a name="l00341"></a><span class="lineno">  341</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">typename</span> Super::activeNetwork_iterator it(Super::m_activeNetwork.<a class="code" href="namespacebegin.html">begin</a>()), itEnd(Super::m_activeNetwork.end());</div><div class="line"><a name="l00342"></a><span class="lineno">  342</span>&#160;            it != itEnd; ++it)</div><div class="line"><a name="l00343"></a><span class="lineno">  343</span>&#160;    {</div><div class="line"><a name="l00344"></a><span class="lineno">  344</span>&#160;        NodeType&amp; <a class="code" href="structnode.html">node</a> = getNode(**it);</div><div class="line"><a name="l00345"></a><span class="lineno">  345</span>&#160;        <span class="comment">// own node/module codebook</span></div><div class="line"><a name="l00346"></a><span class="lineno">  346</span>&#160;        Super::flow_log_flow += infomath::plogp(<a class="code" href="structnode.html">node</a>.data.flow + <a class="code" href="structnode.html">node</a>.data.exitFlow);</div><div class="line"><a name="l00347"></a><span class="lineno">  347</span>&#160;</div><div class="line"><a name="l00348"></a><span class="lineno">  348</span>&#160;        <span class="comment">// use of index codebook</span></div><div class="line"><a name="l00349"></a><span class="lineno">  349</span>&#160;        Super::enter_log_enter += infomath::plogp(<a class="code" href="structnode.html">node</a>.data.enterFlow);</div><div class="line"><a name="l00350"></a><span class="lineno">  350</span>&#160;        Super::exit_log_exit += infomath::plogp(<a class="code" href="structnode.html">node</a>.data.exitFlow);</div><div class="line"><a name="l00351"></a><span class="lineno">  351</span>&#160;        Super::enterFlow += <a class="code" href="structnode.html">node</a>.data.enterFlow;</div><div class="line"><a name="l00352"></a><span class="lineno">  352</span>&#160;    }</div><div class="line"><a name="l00353"></a><span class="lineno">  353</span>&#160;    Super::enterFlow += Super::exitNetworkFlow;</div><div class="line"><a name="l00354"></a><span class="lineno">  354</span>&#160;    Super::enterFlow_log_enterFlow = infomath::plogp(Super::enterFlow);</div><div class="line"><a name="l00355"></a><span class="lineno">  355</span>&#160;</div><div class="line"><a name="l00356"></a><span class="lineno">  356</span>&#160;    derived().calculateNodeFlow_log_nodeFlowForMemoryNetwork();</div><div class="line"><a name="l00357"></a><span class="lineno">  357</span>&#160;</div><div class="line"><a name="l00358"></a><span class="lineno">  358</span>&#160;    Super::indexCodelength = Super::enterFlow_log_enterFlow - Super::enter_log_enter - Super::exitNetworkFlow_log_exitNetworkFlow;</div><div class="line"><a name="l00359"></a><span class="lineno">  359</span>&#160;    Super::moduleCodelength = -Super::exit_log_exit + Super::flow_log_flow - Super::nodeFlow_log_nodeFlow;</div><div class="line"><a name="l00360"></a><span class="lineno">  360</span>&#160;    Super::codelength = Super::indexCodelength + Super::moduleCodelength;</div><div class="line"><a name="l00361"></a><span class="lineno">  361</span>&#160;}</div><div class="ttc" id="structnode_html"><div class="ttname"><a href="structnode.html">node</a></div><div class="ttdef"><b>Definition:</b> code.h:138</div></div>
<div class="ttc" id="namespacebegin_html"><div class="ttname"><a href="namespacebegin.html">begin</a></div><div class="ttdef"><b>Definition:</b> begin.py:1</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ad4845dbd57d006f5220e6a7d9f293f9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4845dbd57d006f5220e6a7d9f293f9d">&#9670;&nbsp;</a></span>consolidateModules()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InfomapGreedyDerivedType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="classInfomapGreedyCommon.html">InfomapGreedyCommon</a>&lt; InfomapGreedyDerivedType &gt;::consolidateModules </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>replaceExistingStructure</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>asSubModules</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Take the non-empty dynamic modules from the optimization of the active network and create module nodes to insert above the active network in the tree. Also aggregate the links from the active network to inter-module links in the new modular network.</p>
<p>If true, it doesn't add any depth to the tree but replacing either the existing modular parent structure (if <code>asSubModules</code> is true) or the active network itself if it's not the leaf level, in which case it will add a level of depth to the tree anyway.</p>
<p>Set to true to consolidate the dynamic modules as submodules under existing modules, and store existing parent structure on the index member of the submodules. Presupposes that the active network already have a modular parent structure, and that the dynamic structure that will be consolidated actually contains nothing but strict sub-structures of the existing modules, i.e. that the index property of two nodes with different parent must be different. Presumably the sub-module structure initiated on the active network is found by partitioning each existing module.</p>
<dl class="section return"><dt>Returns</dt><dd>The number of created modules </dd></dl>

<p>Implements <a class="el" href="classInfomapBase.html#ac6da8d87eb4d0760157367e8fcdfbdbc">InfomapBase</a>.</p>
<div class="fragment"><div class="line"><a name="l01329"></a><span class="lineno"> 1329</span>&#160;{</div><div class="line"><a name="l01330"></a><span class="lineno"> 1330</span>&#160;    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> numNodes = Super::m_activeNetwork.size();</div><div class="line"><a name="l01331"></a><span class="lineno"> 1331</span>&#160;    std::vector&lt;NodeBase*&gt; modules(numNodes, 0);</div><div class="line"><a name="l01332"></a><span class="lineno"> 1332</span>&#160;</div><div class="line"><a name="l01333"></a><span class="lineno"> 1333</span>&#160;    <span class="keywordtype">bool</span> activeNetworkAlreadyHaveModuleLevel = Super::m_activeNetwork[0]-&gt;parent != Super::root();</div><div class="line"><a name="l01334"></a><span class="lineno"> 1334</span>&#160;    <span class="keywordtype">bool</span> activeNetworkIsLeafNetwork = Super::m_activeNetwork[0]-&gt;isLeaf();</div><div class="line"><a name="l01335"></a><span class="lineno"> 1335</span>&#160;</div><div class="line"><a name="l01336"></a><span class="lineno"> 1336</span>&#160;</div><div class="line"><a name="l01337"></a><span class="lineno"> 1337</span>&#160;    <span class="keywordflow">if</span> (asSubModules)</div><div class="line"><a name="l01338"></a><span class="lineno"> 1338</span>&#160;    {</div><div class="line"><a name="l01339"></a><span class="lineno"> 1339</span>&#160;        ASSERT(activeNetworkAlreadyHaveModuleLevel);</div><div class="line"><a name="l01340"></a><span class="lineno"> 1340</span>&#160;        <span class="comment">// Release the pointers from modules to leaf nodes so that the new submodules will be inserted as its only children.</span></div><div class="line"><a name="l01341"></a><span class="lineno"> 1341</span>&#160;        <span class="keywordflow">for</span> (<a class="code" href="classSiblingIterator.html">NodeBase::sibling_iterator</a> moduleIt(Super::root()-&gt;begin_child()), moduleEnd(Super::root()-&gt;end_child());</div><div class="line"><a name="l01342"></a><span class="lineno"> 1342</span>&#160;                moduleIt != moduleEnd; ++moduleIt)</div><div class="line"><a name="l01343"></a><span class="lineno"> 1343</span>&#160;        {</div><div class="line"><a name="l01344"></a><span class="lineno"> 1344</span>&#160;            moduleIt-&gt;releaseChildren();</div><div class="line"><a name="l01345"></a><span class="lineno"> 1345</span>&#160;        }</div><div class="line"><a name="l01346"></a><span class="lineno"> 1346</span>&#160;    }</div><div class="line"><a name="l01347"></a><span class="lineno"> 1347</span>&#160;    <span class="keywordflow">else</span></div><div class="line"><a name="l01348"></a><span class="lineno"> 1348</span>&#160;    {</div><div class="line"><a name="l01349"></a><span class="lineno"> 1349</span>&#160;        <span class="comment">// Happens after optimizing fine-tune and when moving leaf nodes to super clusters</span></div><div class="line"><a name="l01350"></a><span class="lineno"> 1350</span>&#160;        <span class="keywordflow">if</span> (activeNetworkAlreadyHaveModuleLevel)</div><div class="line"><a name="l01351"></a><span class="lineno"> 1351</span>&#160;        {</div><div class="line"><a name="l01352"></a><span class="lineno"> 1352</span>&#160;            DEBUG_OUT(<span class="stringliteral">&quot;Replace existing &quot;</span> &lt;&lt; numTopModules() &lt;&lt; <span class="stringliteral">&quot; modules with its children before consolidating the &quot;</span> &lt;&lt;</div><div class="line"><a name="l01353"></a><span class="lineno"> 1353</span>&#160;                    numActiveModules() &lt;&lt; <span class="stringliteral">&quot; dynamic modules... &quot;</span>);</div><div class="line"><a name="l01354"></a><span class="lineno"> 1354</span>&#160;            Super::root()-&gt;replaceChildrenWithGrandChildren();</div><div class="line"><a name="l01355"></a><span class="lineno"> 1355</span>&#160;            ASSERT(m_activeNetwork[0]-&gt;parent == root());</div><div class="line"><a name="l01356"></a><span class="lineno"> 1356</span>&#160;        }</div><div class="line"><a name="l01357"></a><span class="lineno"> 1357</span>&#160;        Super::root()-&gt;releaseChildren();</div><div class="line"><a name="l01358"></a><span class="lineno"> 1358</span>&#160;    }</div><div class="line"><a name="l01359"></a><span class="lineno"> 1359</span>&#160;</div><div class="line"><a name="l01360"></a><span class="lineno"> 1360</span>&#160;    <span class="comment">// Create the new module nodes and re-parent the active network from its common parent to the new module level</span></div><div class="line"><a name="l01361"></a><span class="lineno"> 1361</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; numNodes; ++i)</div><div class="line"><a name="l01362"></a><span class="lineno"> 1362</span>&#160;    {</div><div class="line"><a name="l01363"></a><span class="lineno"> 1363</span>&#160;        <a class="code" href="classNodeBase.html">NodeBase</a>* <a class="code" href="structnode.html">node</a> = Super::m_activeNetwork[i];</div><div class="line"><a name="l01364"></a><span class="lineno"> 1364</span>&#160;        <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> moduleIndex = <a class="code" href="structnode.html">node</a>-&gt;index;</div><div class="line"><a name="l01365"></a><span class="lineno"> 1365</span>&#160;        <span class="keywordflow">if</span> (modules[moduleIndex] == 0)</div><div class="line"><a name="l01366"></a><span class="lineno"> 1366</span>&#160;        {</div><div class="line"><a name="l01367"></a><span class="lineno"> 1367</span>&#160;            modules[moduleIndex] = <span class="keyword">new</span> NodeType(Super::m_moduleFlowData[moduleIndex]);</div><div class="line"><a name="l01368"></a><span class="lineno"> 1368</span>&#160;            <a class="code" href="structnode.html">node</a>-&gt;parent-&gt;addChild(modules[moduleIndex]);</div><div class="line"><a name="l01369"></a><span class="lineno"> 1369</span>&#160;            modules[moduleIndex]-&gt;index = moduleIndex;</div><div class="line"><a name="l01370"></a><span class="lineno"> 1370</span>&#160;            <span class="comment">// If node-&gt;parent is a module, its former children (leafnodes) has been released above, getting only submodules</span></div><div class="line"><a name="l01371"></a><span class="lineno"> 1371</span>&#160;<span class="comment">//          if (node-&gt;parent-&gt;firstChild == node)</span></div><div class="line"><a name="l01372"></a><span class="lineno"> 1372</span>&#160;<span class="comment">//              node-&gt;parent-&gt;firstChild = modules[moduleIndex];</span></div><div class="line"><a name="l01373"></a><span class="lineno"> 1373</span>&#160;        }</div><div class="line"><a name="l01374"></a><span class="lineno"> 1374</span>&#160;        modules[moduleIndex]-&gt;addChild(<a class="code" href="structnode.html">node</a>);</div><div class="line"><a name="l01375"></a><span class="lineno"> 1375</span>&#160;    }</div><div class="line"><a name="l01376"></a><span class="lineno"> 1376</span>&#160;</div><div class="line"><a name="l01377"></a><span class="lineno"> 1377</span>&#160;    <span class="keywordflow">if</span> (asSubModules)</div><div class="line"><a name="l01378"></a><span class="lineno"> 1378</span>&#160;    {</div><div class="line"><a name="l01379"></a><span class="lineno"> 1379</span>&#160;        DEBUG_OUT(<span class="stringliteral">&quot;Consolidated &quot;</span> &lt;&lt; numActiveModules() &lt;&lt; <span class="stringliteral">&quot; submodules under &quot;</span> &lt;&lt; numTopModules() &lt;&lt; <span class="stringliteral">&quot; modules, &quot;</span> &lt;&lt;</div><div class="line"><a name="l01380"></a><span class="lineno"> 1380</span>&#160;                <span class="stringliteral">&quot;store module structure before releasing it...&quot;</span> &lt;&lt; std::endl);</div><div class="line"><a name="l01381"></a><span class="lineno"> 1381</span>&#160;        <span class="comment">// Store the module structure on the submodules</span></div><div class="line"><a name="l01382"></a><span class="lineno"> 1382</span>&#160;        <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> moduleIndex = 0;</div><div class="line"><a name="l01383"></a><span class="lineno"> 1383</span>&#160;        <span class="keywordflow">for</span> (<a class="code" href="classSiblingIterator.html">NodeBase::sibling_iterator</a> moduleIt(Super::root()-&gt;begin_child()), endIt(Super::root()-&gt;end_child());</div><div class="line"><a name="l01384"></a><span class="lineno"> 1384</span>&#160;                moduleIt != endIt; ++moduleIt, ++moduleIndex)</div><div class="line"><a name="l01385"></a><span class="lineno"> 1385</span>&#160;        {</div><div class="line"><a name="l01386"></a><span class="lineno"> 1386</span>&#160;            <span class="keywordflow">for</span> (<a class="code" href="classSiblingIterator.html">NodeBase::sibling_iterator</a> subModuleIt(moduleIt-&gt;begin_child()), endIt(moduleIt-&gt;end_child());</div><div class="line"><a name="l01387"></a><span class="lineno"> 1387</span>&#160;                    subModuleIt != endIt; ++subModuleIt)</div><div class="line"><a name="l01388"></a><span class="lineno"> 1388</span>&#160;            {</div><div class="line"><a name="l01389"></a><span class="lineno"> 1389</span>&#160;                subModuleIt-&gt;index = moduleIndex;</div><div class="line"><a name="l01390"></a><span class="lineno"> 1390</span>&#160;            }</div><div class="line"><a name="l01391"></a><span class="lineno"> 1391</span>&#160;        }</div><div class="line"><a name="l01392"></a><span class="lineno"> 1392</span>&#160;        <span class="keywordflow">if</span> (replaceExistingStructure)</div><div class="line"><a name="l01393"></a><span class="lineno"> 1393</span>&#160;        {</div><div class="line"><a name="l01394"></a><span class="lineno"> 1394</span>&#160;            <span class="comment">// Remove the module level</span></div><div class="line"><a name="l01395"></a><span class="lineno"> 1395</span>&#160;            Super::root()-&gt;replaceChildrenWithGrandChildren();</div><div class="line"><a name="l01396"></a><span class="lineno"> 1396</span>&#160;        }</div><div class="line"><a name="l01397"></a><span class="lineno"> 1397</span>&#160;    }</div><div class="line"><a name="l01398"></a><span class="lineno"> 1398</span>&#160;</div><div class="line"><a name="l01399"></a><span class="lineno"> 1399</span>&#160;</div><div class="line"><a name="l01400"></a><span class="lineno"> 1400</span>&#160;    <span class="comment">// Aggregate links from lower level to the new modular level</span></div><div class="line"><a name="l01401"></a><span class="lineno"> 1401</span>&#160;    <span class="keyword">typedef</span> std::pair&lt;NodeBase*, NodeBase*&gt; NodePair;</div><div class="line"><a name="l01402"></a><span class="lineno"> 1402</span>&#160;    <span class="keyword">typedef</span> std::map&lt;NodePair, double, CompNodePair&gt; EdgeMap;</div><div class="line"><a name="l01403"></a><span class="lineno"> 1403</span>&#160;    EdgeMap moduleLinks;</div><div class="line"><a name="l01404"></a><span class="lineno"> 1404</span>&#160;</div><div class="line"><a name="l01405"></a><span class="lineno"> 1405</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">typename</span> Super::activeNetwork_iterator nodeIt(Super::m_activeNetwork.<a class="code" href="namespacebegin.html">begin</a>()), nodeEnd(Super::m_activeNetwork.end());</div><div class="line"><a name="l01406"></a><span class="lineno"> 1406</span>&#160;            nodeIt != nodeEnd; ++nodeIt)</div><div class="line"><a name="l01407"></a><span class="lineno"> 1407</span>&#160;    {</div><div class="line"><a name="l01408"></a><span class="lineno"> 1408</span>&#160;        <a class="code" href="classNodeBase.html">NodeBase</a>* <a class="code" href="structnode.html">node</a> = *nodeIt;</div><div class="line"><a name="l01409"></a><span class="lineno"> 1409</span>&#160;</div><div class="line"><a name="l01410"></a><span class="lineno"> 1410</span>&#160;        <a class="code" href="classNodeBase.html">NodeBase</a>* parent = <a class="code" href="structnode.html">node</a>-&gt;parent;</div><div class="line"><a name="l01411"></a><span class="lineno"> 1411</span>&#160;        <span class="keywordflow">for</span> (NodeBase::edge_iterator edgeIt(<a class="code" href="structnode.html">node</a>-&gt;begin_outEdge()), edgeEnd(<a class="code" href="structnode.html">node</a>-&gt;end_outEdge());</div><div class="line"><a name="l01412"></a><span class="lineno"> 1412</span>&#160;                edgeIt != edgeEnd; ++edgeIt)</div><div class="line"><a name="l01413"></a><span class="lineno"> 1413</span>&#160;        {</div><div class="line"><a name="l01414"></a><span class="lineno"> 1414</span>&#160;            EdgeType* edge = *edgeIt;</div><div class="line"><a name="l01415"></a><span class="lineno"> 1415</span>&#160;            <a class="code" href="classNodeBase.html">NodeBase</a>* otherParent = edge-&gt;target.parent;</div><div class="line"><a name="l01416"></a><span class="lineno"> 1416</span>&#160;</div><div class="line"><a name="l01417"></a><span class="lineno"> 1417</span>&#160;            <span class="keywordflow">if</span> (otherParent != parent)</div><div class="line"><a name="l01418"></a><span class="lineno"> 1418</span>&#160;            {</div><div class="line"><a name="l01419"></a><span class="lineno"> 1419</span>&#160;                <a class="code" href="classNodeBase.html">NodeBase</a> *m1 = parent, *m2 = otherParent;</div><div class="line"><a name="l01420"></a><span class="lineno"> 1420</span>&#160;                <span class="comment">// If undirected, the order may be swapped to aggregate the edge on an opposite one</span></div><div class="line"><a name="l01421"></a><span class="lineno"> 1421</span>&#160;                <span class="keywordflow">if</span> (!IsDirectedType() &amp;&amp; m1-&gt;index &gt; m2-&gt;index)</div><div class="line"><a name="l01422"></a><span class="lineno"> 1422</span>&#160;                    std::swap(m1, m2);</div><div class="line"><a name="l01423"></a><span class="lineno"> 1423</span>&#160;                <span class="comment">// Insert the node pair in the edge map. If not inserted, add the flow value to existing node pair.</span></div><div class="line"><a name="l01424"></a><span class="lineno"> 1424</span>&#160;                std::pair&lt;typename EdgeMap::iterator, bool&gt; ret = \</div><div class="line"><a name="l01425"></a><span class="lineno"> 1425</span>&#160;                    moduleLinks.insert(std::make_pair(NodePair(m1, m2), edge-&gt;data.flow));</div><div class="line"><a name="l01426"></a><span class="lineno"> 1426</span>&#160;                <span class="keywordflow">if</span> (!ret.second)</div><div class="line"><a name="l01427"></a><span class="lineno"> 1427</span>&#160;                    ret.first-&gt;second += edge-&gt;data.flow;</div><div class="line"><a name="l01428"></a><span class="lineno"> 1428</span>&#160;            }</div><div class="line"><a name="l01429"></a><span class="lineno"> 1429</span>&#160;        }</div><div class="line"><a name="l01430"></a><span class="lineno"> 1430</span>&#160;    }</div><div class="line"><a name="l01431"></a><span class="lineno"> 1431</span>&#160;</div><div class="line"><a name="l01432"></a><span class="lineno"> 1432</span>&#160;    <span class="comment">// Add the aggregated edge flow structure to the new modules</span></div><div class="line"><a name="l01433"></a><span class="lineno"> 1433</span>&#160;    <span class="keywordflow">for</span> (EdgeMap::const_iterator edgeIt(moduleLinks.begin()), edgeEnd(moduleLinks.end());</div><div class="line"><a name="l01434"></a><span class="lineno"> 1434</span>&#160;            edgeIt != edgeEnd; ++edgeIt)</div><div class="line"><a name="l01435"></a><span class="lineno"> 1435</span>&#160;    {</div><div class="line"><a name="l01436"></a><span class="lineno"> 1436</span>&#160;        <span class="keyword">const</span> NodePair&amp; nodePair = edgeIt-&gt;first;</div><div class="line"><a name="l01437"></a><span class="lineno"> 1437</span>&#160;        nodePair.first-&gt;addOutEdge(*nodePair.second, 0.0, edgeIt-&gt;second);</div><div class="line"><a name="l01438"></a><span class="lineno"> 1438</span>&#160;    }</div><div class="line"><a name="l01439"></a><span class="lineno"> 1439</span>&#160;</div><div class="line"><a name="l01440"></a><span class="lineno"> 1440</span>&#160;    <span class="comment">// Replace active network with its children if not at leaf level.</span></div><div class="line"><a name="l01441"></a><span class="lineno"> 1441</span>&#160;    <span class="keywordflow">if</span> (!activeNetworkIsLeafNetwork &amp;&amp; replaceExistingStructure)</div><div class="line"><a name="l01442"></a><span class="lineno"> 1442</span>&#160;    {</div><div class="line"><a name="l01443"></a><span class="lineno"> 1443</span>&#160;        <span class="keywordflow">for</span> (<span class="keyword">typename</span> Super::activeNetwork_iterator nodeIt(Super::m_activeNetwork.<a class="code" href="namespacebegin.html">begin</a>()), nodeEnd(Super::m_activeNetwork.end());</div><div class="line"><a name="l01444"></a><span class="lineno"> 1444</span>&#160;                nodeIt != nodeEnd; ++nodeIt)</div><div class="line"><a name="l01445"></a><span class="lineno"> 1445</span>&#160;        {</div><div class="line"><a name="l01446"></a><span class="lineno"> 1446</span>&#160;            (*nodeIt)-&gt;replaceWithChildren();</div><div class="line"><a name="l01447"></a><span class="lineno"> 1447</span>&#160;        }</div><div class="line"><a name="l01448"></a><span class="lineno"> 1448</span>&#160;    }</div><div class="line"><a name="l01449"></a><span class="lineno"> 1449</span>&#160;</div><div class="line"><a name="l01450"></a><span class="lineno"> 1450</span>&#160;    <span class="comment">// Calculate the number of non-trivial modules</span></div><div class="line"><a name="l01451"></a><span class="lineno"> 1451</span>&#160;    Super::m_numNonTrivialTopModules = 0;</div><div class="line"><a name="l01452"></a><span class="lineno"> 1452</span>&#160;    <span class="keywordflow">for</span> (<a class="code" href="classSiblingIterator.html">NodeBase::sibling_iterator</a> moduleIt(Super::root()-&gt;begin_child()), endIt(Super::root()-&gt;end_child());</div><div class="line"><a name="l01453"></a><span class="lineno"> 1453</span>&#160;            moduleIt != endIt; ++moduleIt)</div><div class="line"><a name="l01454"></a><span class="lineno"> 1454</span>&#160;    {</div><div class="line"><a name="l01455"></a><span class="lineno"> 1455</span>&#160;        <span class="keywordflow">if</span> (moduleIt-&gt;childDegree() != 1)</div><div class="line"><a name="l01456"></a><span class="lineno"> 1456</span>&#160;            ++Super::m_numNonTrivialTopModules;</div><div class="line"><a name="l01457"></a><span class="lineno"> 1457</span>&#160;    }</div><div class="line"><a name="l01458"></a><span class="lineno"> 1458</span>&#160;</div><div class="line"><a name="l01459"></a><span class="lineno"> 1459</span>&#160;    <span class="comment">// For memory networks</span></div><div class="line"><a name="l01460"></a><span class="lineno"> 1460</span>&#160;    derived().consolidatePhysicalNodes(modules);</div><div class="line"><a name="l01461"></a><span class="lineno"> 1461</span>&#160;</div><div class="line"><a name="l01462"></a><span class="lineno"> 1462</span>&#160;    <span class="keywordflow">return</span> Super::numActiveModules();</div><div class="line"><a name="l01463"></a><span class="lineno"> 1463</span>&#160;}</div><div class="ttc" id="structnode_html"><div class="ttname"><a href="structnode.html">node</a></div><div class="ttdef"><b>Definition:</b> code.h:138</div></div>
<div class="ttc" id="classNodeBase_html"><div class="ttname"><a href="classNodeBase.html">NodeBase</a></div><div class="ttdef"><b>Definition:</b> Node.h:132</div></div>
<div class="ttc" id="namespacebegin_html"><div class="ttname"><a href="namespacebegin.html">begin</a></div><div class="ttdef"><b>Definition:</b> begin.py:1</div></div>
<div class="ttc" id="classSiblingIterator_html"><div class="ttname"><a href="classSiblingIterator.html">SiblingIterator</a></div><div class="ttdef"><b>Definition:</b> treeIterators.h:491</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="af6135849730a24a4f3fea57ff32991e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6135849730a24a4f3fea57ff32991e5">&#9670;&nbsp;</a></span>initConstantInfomapTerms()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InfomapGreedyDerivedType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classInfomapGreedyCommon.html">InfomapGreedyCommon</a>&lt; InfomapGreedyDerivedType &gt;::initConstantInfomapTerms </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Init the infomap term that only depends on the flow value on the leaf nodes. </p>

<p>Implements <a class="el" href="classInfomapBase.html#a093ad5e840cb4529ac32eaf4f9d6d8b2">InfomapBase</a>.</p>
<div class="fragment"><div class="line"><a name="l00317"></a><span class="lineno">  317</span>&#160;{</div><div class="line"><a name="l00318"></a><span class="lineno">  318</span>&#160;    <span class="comment">// Not constant for memory Infomap!</span></div><div class="line"><a name="l00319"></a><span class="lineno">  319</span>&#160;    Super::nodeFlow_log_nodeFlow = 0.0;</div><div class="line"><a name="l00320"></a><span class="lineno">  320</span>&#160;    <span class="comment">// For each module</span></div><div class="line"><a name="l00321"></a><span class="lineno">  321</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">typename</span> Super::activeNetwork_iterator it(Super::m_activeNetwork.<a class="code" href="namespacebegin.html">begin</a>()), itEnd(Super::m_activeNetwork.end());</div><div class="line"><a name="l00322"></a><span class="lineno">  322</span>&#160;            it != itEnd; ++it)</div><div class="line"><a name="l00323"></a><span class="lineno">  323</span>&#160;    {</div><div class="line"><a name="l00324"></a><span class="lineno">  324</span>&#160;        NodeType&amp; <a class="code" href="structnode.html">node</a> = getNode(**it);</div><div class="line"><a name="l00325"></a><span class="lineno">  325</span>&#160;        Super::nodeFlow_log_nodeFlow += infomath::plogp(<a class="code" href="structnode.html">node</a>.data.flow);</div><div class="line"><a name="l00326"></a><span class="lineno">  326</span>&#160;    }</div><div class="line"><a name="l00327"></a><span class="lineno">  327</span>&#160;}</div><div class="ttc" id="structnode_html"><div class="ttname"><a href="structnode.html">node</a></div><div class="ttdef"><b>Definition:</b> code.h:138</div></div>
<div class="ttc" id="namespacebegin_html"><div class="ttname"><a href="namespacebegin.html">begin</a></div><div class="ttdef"><b>Definition:</b> begin.py:1</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="affbdd4750e010adba7f1cd15a295303e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affbdd4750e010adba7f1cd15a295303e">&#9670;&nbsp;</a></span>moveNodesToPredefinedModules()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InfomapGreedyDerivedType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classInfomapGreedyCommon.html">InfomapGreedyCommon</a>&lt; InfomapGreedyDerivedType &gt;::moveNodesToPredefinedModules </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Loop through each node and move it to the module predefined by the member vector m_moveTo. </p>

<p>Implements <a class="el" href="classInfomapBase.html#ab085f56e93df121d113b5869a51824c9">InfomapBase</a>.</p>
<div class="fragment"><div class="line"><a name="l01246"></a><span class="lineno"> 1246</span>&#160;{</div><div class="line"><a name="l01247"></a><span class="lineno"> 1247</span>&#160;    <span class="comment">// Size of active network and cluster array should match.</span></div><div class="line"><a name="l01248"></a><span class="lineno"> 1248</span>&#160;    ASSERT(m_moveTo.size() == m_activeNetwork.size());</div><div class="line"><a name="l01249"></a><span class="lineno"> 1249</span>&#160;</div><div class="line"><a name="l01250"></a><span class="lineno"> 1250</span>&#160;    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> numNodes = Super::m_activeNetwork.size();</div><div class="line"><a name="l01251"></a><span class="lineno"> 1251</span>&#160;</div><div class="line"><a name="l01252"></a><span class="lineno"> 1252</span>&#160;    DEBUG_OUT(<span class="stringliteral">&quot;Begin moving &quot;</span> &lt;&lt; numNodes &lt;&lt; <span class="stringliteral">&quot; nodes to predefined modules, starting with codelength &quot;</span> &lt;&lt;</div><div class="line"><a name="l01253"></a><span class="lineno"> 1253</span>&#160;            codelength &lt;&lt; <span class="stringliteral">&quot;...&quot;</span> &lt;&lt; std::endl);</div><div class="line"><a name="l01254"></a><span class="lineno"> 1254</span>&#160;</div><div class="line"><a name="l01255"></a><span class="lineno"> 1255</span>&#160;    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> numMoved = 0;</div><div class="line"><a name="l01256"></a><span class="lineno"> 1256</span>&#160;    <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; numNodes; ++k)</div><div class="line"><a name="l01257"></a><span class="lineno"> 1257</span>&#160;    {</div><div class="line"><a name="l01258"></a><span class="lineno"> 1258</span>&#160;        NodeType&amp; current = getNode(*Super::m_activeNetwork[k]);</div><div class="line"><a name="l01259"></a><span class="lineno"> 1259</span>&#160;        <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> oldM = current.index; <span class="comment">// == k</span></div><div class="line"><a name="l01260"></a><span class="lineno"> 1260</span>&#160;        <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> newM = Super::m_moveTo[k];</div><div class="line"><a name="l01261"></a><span class="lineno"> 1261</span>&#160;</div><div class="line"><a name="l01262"></a><span class="lineno"> 1262</span>&#160;        <span class="keywordflow">if</span> (newM != oldM)</div><div class="line"><a name="l01263"></a><span class="lineno"> 1263</span>&#160;        {</div><div class="line"><a name="l01264"></a><span class="lineno"> 1264</span>&#160;            DeltaFlowType oldModuleDelta(oldM, 0.0, 0.0, 0.0, 0.0);</div><div class="line"><a name="l01265"></a><span class="lineno"> 1265</span>&#160;            DeltaFlowType newModuleDelta(newM, 0.0, 0.0, 0.0, 0.0);</div><div class="line"><a name="l01266"></a><span class="lineno"> 1266</span>&#160;</div><div class="line"><a name="l01267"></a><span class="lineno"> 1267</span>&#160;            Super::addTeleportationDeltaFlowOnOldModuleIfMove(current, oldModuleDelta);</div><div class="line"><a name="l01268"></a><span class="lineno"> 1268</span>&#160;            Super::addTeleportationDeltaFlowOnNewModuleIfMove(current, newModuleDelta);</div><div class="line"><a name="l01269"></a><span class="lineno"> 1269</span>&#160;</div><div class="line"><a name="l01270"></a><span class="lineno"> 1270</span>&#160;            <span class="comment">// For all outlinks</span></div><div class="line"><a name="l01271"></a><span class="lineno"> 1271</span>&#160;            <span class="keywordflow">for</span> (NodeBase::edge_iterator edgeIt(current.begin_outEdge()), endIt(current.end_outEdge());</div><div class="line"><a name="l01272"></a><span class="lineno"> 1272</span>&#160;                    edgeIt != endIt; ++edgeIt)</div><div class="line"><a name="l01273"></a><span class="lineno"> 1273</span>&#160;            {</div><div class="line"><a name="l01274"></a><span class="lineno"> 1274</span>&#160;                EdgeType&amp; edge = **edgeIt;</div><div class="line"><a name="l01275"></a><span class="lineno"> 1275</span>&#160;                <span class="keywordflow">if</span> (edge.isSelfPointing())</div><div class="line"><a name="l01276"></a><span class="lineno"> 1276</span>&#160;                    <span class="keywordflow">continue</span>;</div><div class="line"><a name="l01277"></a><span class="lineno"> 1277</span>&#160;                <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> otherModule = edge.target.index;</div><div class="line"><a name="l01278"></a><span class="lineno"> 1278</span>&#160;                <span class="keywordflow">if</span> (otherModule == oldM)</div><div class="line"><a name="l01279"></a><span class="lineno"> 1279</span>&#160;                    oldModuleDelta.deltaExit += edge.data.flow;</div><div class="line"><a name="l01280"></a><span class="lineno"> 1280</span>&#160;                <span class="keywordflow">else</span> <span class="keywordflow">if</span> (otherModule == newM)</div><div class="line"><a name="l01281"></a><span class="lineno"> 1281</span>&#160;                    newModuleDelta.deltaExit += edge.data.flow;</div><div class="line"><a name="l01282"></a><span class="lineno"> 1282</span>&#160;            }</div><div class="line"><a name="l01283"></a><span class="lineno"> 1283</span>&#160;</div><div class="line"><a name="l01284"></a><span class="lineno"> 1284</span>&#160;            <span class="comment">// For all inlinks</span></div><div class="line"><a name="l01285"></a><span class="lineno"> 1285</span>&#160;            <span class="keywordflow">for</span> (NodeBase::edge_iterator edgeIt(current.begin_inEdge()), endIt(current.end_inEdge());</div><div class="line"><a name="l01286"></a><span class="lineno"> 1286</span>&#160;                    edgeIt != endIt; ++edgeIt)</div><div class="line"><a name="l01287"></a><span class="lineno"> 1287</span>&#160;            {</div><div class="line"><a name="l01288"></a><span class="lineno"> 1288</span>&#160;                EdgeType&amp; edge = **edgeIt;</div><div class="line"><a name="l01289"></a><span class="lineno"> 1289</span>&#160;                <span class="keywordflow">if</span> (edge.isSelfPointing())</div><div class="line"><a name="l01290"></a><span class="lineno"> 1290</span>&#160;                    <span class="keywordflow">continue</span>;</div><div class="line"><a name="l01291"></a><span class="lineno"> 1291</span>&#160;                <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> otherModule = edge.source.index;</div><div class="line"><a name="l01292"></a><span class="lineno"> 1292</span>&#160;                <span class="keywordflow">if</span> (otherModule == oldM)</div><div class="line"><a name="l01293"></a><span class="lineno"> 1293</span>&#160;                    oldModuleDelta.deltaEnter += edge.data.flow;</div><div class="line"><a name="l01294"></a><span class="lineno"> 1294</span>&#160;                <span class="keywordflow">else</span> <span class="keywordflow">if</span> (otherModule == newM)</div><div class="line"><a name="l01295"></a><span class="lineno"> 1295</span>&#160;                    newModuleDelta.deltaEnter += edge.data.flow;</div><div class="line"><a name="l01296"></a><span class="lineno"> 1296</span>&#160;            }</div><div class="line"><a name="l01297"></a><span class="lineno"> 1297</span>&#160;</div><div class="line"><a name="l01298"></a><span class="lineno"> 1298</span>&#160;</div><div class="line"><a name="l01299"></a><span class="lineno"> 1299</span>&#160;            <span class="comment">// For memory networks</span></div><div class="line"><a name="l01300"></a><span class="lineno"> 1300</span>&#160;            derived().performPredefinedMoveOfMemoryNode(current, oldM, newM, oldModuleDelta, newModuleDelta);</div><div class="line"><a name="l01301"></a><span class="lineno"> 1301</span>&#160;</div><div class="line"><a name="l01302"></a><span class="lineno"> 1302</span>&#160;</div><div class="line"><a name="l01303"></a><span class="lineno"> 1303</span>&#160;            <span class="comment">//Update empty module vector</span></div><div class="line"><a name="l01304"></a><span class="lineno"> 1304</span>&#160;            <span class="keywordflow">if</span>(Super::m_moduleMembers[newM] == 0)</div><div class="line"><a name="l01305"></a><span class="lineno"> 1305</span>&#160;            {</div><div class="line"><a name="l01306"></a><span class="lineno"> 1306</span>&#160;                Super::m_emptyModules.pop_back();</div><div class="line"><a name="l01307"></a><span class="lineno"> 1307</span>&#160;            }</div><div class="line"><a name="l01308"></a><span class="lineno"> 1308</span>&#160;            <span class="keywordflow">if</span>(Super::m_moduleMembers[oldM] == 1)</div><div class="line"><a name="l01309"></a><span class="lineno"> 1309</span>&#160;            {</div><div class="line"><a name="l01310"></a><span class="lineno"> 1310</span>&#160;                Super::m_emptyModules.push_back(oldM);</div><div class="line"><a name="l01311"></a><span class="lineno"> 1311</span>&#160;            }</div><div class="line"><a name="l01312"></a><span class="lineno"> 1312</span>&#160;</div><div class="line"><a name="l01313"></a><span class="lineno"> 1313</span>&#160;            <a class="code" href="classInfomapGreedySpecialized.html#a6f4ff75d89a26f1b474ca5a2190878c7">Super::updateCodelengthOnMovingNode</a>(current, oldModuleDelta, newModuleDelta);</div><div class="line"><a name="l01314"></a><span class="lineno"> 1314</span>&#160;            derived().updateCodelengthOnMovingMemoryNode(oldModuleDelta, newModuleDelta);</div><div class="line"><a name="l01315"></a><span class="lineno"> 1315</span>&#160;</div><div class="line"><a name="l01316"></a><span class="lineno"> 1316</span>&#160;            Super::m_moduleMembers[oldM] -= 1;</div><div class="line"><a name="l01317"></a><span class="lineno"> 1317</span>&#160;            Super::m_moduleMembers[newM] += 1;</div><div class="line"><a name="l01318"></a><span class="lineno"> 1318</span>&#160;</div><div class="line"><a name="l01319"></a><span class="lineno"> 1319</span>&#160;            current.index = newM;</div><div class="line"><a name="l01320"></a><span class="lineno"> 1320</span>&#160;            ++numMoved;</div><div class="line"><a name="l01321"></a><span class="lineno"> 1321</span>&#160;        }</div><div class="line"><a name="l01322"></a><span class="lineno"> 1322</span>&#160;    }</div><div class="line"><a name="l01323"></a><span class="lineno"> 1323</span>&#160;    DEBUG_OUT(<span class="stringliteral">&quot;Done! Moved &quot;</span> &lt;&lt; numMoved &lt;&lt; <span class="stringliteral">&quot; nodes into &quot;</span> &lt;&lt; numActiveModules() &lt;&lt; <span class="stringliteral">&quot; modules to codelength: &quot;</span> &lt;&lt; codelength &lt;&lt; std::endl);</div><div class="line"><a name="l01324"></a><span class="lineno"> 1324</span>&#160;}</div><div class="ttc" id="classInfomapGreedySpecialized_html_a6f4ff75d89a26f1b474ca5a2190878c7"><div class="ttname"><a href="classInfomapGreedySpecialized.html#a6f4ff75d89a26f1b474ca5a2190878c7">InfomapGreedySpecialized::updateCodelengthOnMovingNode</a></div><div class="ttdeci">void updateCodelengthOnMovingNode(NodeType &amp;current, DeltaFlow &amp;oldModuleDelta, DeltaFlow &amp;newModuleDelta)</div><div class="ttdef"><b>Definition:</b> InfomapGreedySpecialized.h:322</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a17feb30bfa3d448f7933c3fcc237f833"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17feb30bfa3d448f7933c3fcc237f833">&#9670;&nbsp;</a></span>optimizeModules()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InfomapGreedyDerivedType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="classInfomapGreedyCommon.html">InfomapGreedyCommon</a>&lt; InfomapGreedyDerivedType &gt;::optimizeModules </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Loop through each node and move it to the module that reduces the total codelength the most. Start over until converged.</p>
<dl class="section return"><dt>Returns</dt><dd>The number of effective optimization rounds, i.e. zero if no move was made. </dd></dl>

<p>Implements <a class="el" href="classInfomapBase.html#a443a496b76cc78286cce345e018c4fd8">InfomapBase</a>.</p>
<div class="fragment"><div class="line"><a name="l00366"></a><span class="lineno">  366</span>&#160;{</div><div class="line"><a name="l00367"></a><span class="lineno">  367</span>&#160;    DEBUG_OUT(<span class="stringliteral">&quot;\nInfomapGreedyCommon&lt;InfomapGreedyDerivedType&gt;::optimizeModules()&quot;</span>);</div><div class="line"><a name="l00368"></a><span class="lineno">  368</span>&#160;    m_coreLoopCount = 0;</div><div class="line"><a name="l00369"></a><span class="lineno">  369</span>&#160;    <span class="keywordtype">double</span> oldCodelength = Super::codelength;</div><div class="line"><a name="l00370"></a><span class="lineno">  370</span>&#160;    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> loopLimit = Super::m_config.coreLoopLimit;</div><div class="line"><a name="l00371"></a><span class="lineno">  371</span>&#160;    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> minRandLoop = 2;</div><div class="line"><a name="l00372"></a><span class="lineno">  372</span>&#160;    <span class="keywordflow">if</span> (loopLimit &gt;= minRandLoop &amp;&amp; Super::m_config.randomizeCoreLoopLimit)</div><div class="line"><a name="l00373"></a><span class="lineno">  373</span>&#160;        loopLimit = <span class="keyword">static_cast&lt;</span><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span><span class="keyword">&gt;</span>(Super::m_rand() * (loopLimit - minRandLoop)) + minRandLoop;</div><div class="line"><a name="l00374"></a><span class="lineno">  374</span>&#160;    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> loopLimitOnAggregationLevels = 20;</div><div class="line"><a name="l00375"></a><span class="lineno">  375</span>&#160;</div><div class="line"><a name="l00376"></a><span class="lineno">  376</span>&#160;    <span class="comment">// Iterate while the optimization loop moves some nodes within the dynamic modular structure</span></div><div class="line"><a name="l00377"></a><span class="lineno">  377</span>&#160;    <span class="keywordflow">do</span></div><div class="line"><a name="l00378"></a><span class="lineno">  378</span>&#160;    {</div><div class="line"><a name="l00379"></a><span class="lineno">  379</span>&#160;        oldCodelength = Super::codelength;</div><div class="line"><a name="l00380"></a><span class="lineno">  380</span>&#160;        <span class="keywordflow">if</span> (Super::m_config.innerParallelization)</div><div class="line"><a name="l00381"></a><span class="lineno">  381</span>&#160;            <a class="code" href="classInfomapGreedyCommon.html#aebf032fcd793b9496e5b1952cb14c233">tryMoveEachNodeIntoBestModuleInParallel</a>(); <span class="comment">// returns numNodesMoved</span></div><div class="line"><a name="l00382"></a><span class="lineno">  382</span>&#160;        <span class="keywordflow">else</span></div><div class="line"><a name="l00383"></a><span class="lineno">  383</span>&#160;            <a class="code" href="classInfomapGreedyCommon.html#a25af363aae49138b379a823b6ab2ad5c">tryMoveEachNodeIntoBestModule</a>(); <span class="comment">// returns numNodesMoved</span></div><div class="line"><a name="l00384"></a><span class="lineno">  384</span>&#160;        ++m_coreLoopCount;</div><div class="line"><a name="l00385"></a><span class="lineno">  385</span>&#160;    } <span class="keywordflow">while</span> (m_coreLoopCount != (Super::m_aggregationLevel == 0 &amp;&amp; !Super::m_isCoarseTune? loopLimit : loopLimitOnAggregationLevels) &amp;&amp;</div><div class="line"><a name="l00386"></a><span class="lineno">  386</span>&#160;            Super::codelength &lt; oldCodelength - Super::m_config.minimumCodelengthImprovement);</div><div class="line"><a name="l00387"></a><span class="lineno">  387</span>&#160;</div><div class="line"><a name="l00388"></a><span class="lineno">  388</span>&#160;    <span class="keywordflow">return</span> m_coreLoopCount;</div><div class="line"><a name="l00389"></a><span class="lineno">  389</span>&#160;}</div><div class="ttc" id="classInfomapGreedyCommon_html_a25af363aae49138b379a823b6ab2ad5c"><div class="ttname"><a href="classInfomapGreedyCommon.html#a25af363aae49138b379a823b6ab2ad5c">InfomapGreedyCommon::tryMoveEachNodeIntoBestModule</a></div><div class="ttdeci">unsigned int tryMoveEachNodeIntoBestModule()</div><div class="ttdef"><b>Definition:</b> InfomapGreedyCommon.h:426</div></div>
<div class="ttc" id="classInfomapGreedyCommon_html_aebf032fcd793b9496e5b1952cb14c233"><div class="ttname"><a href="classInfomapGreedyCommon.html#aebf032fcd793b9496e5b1952cb14c233">InfomapGreedyCommon::tryMoveEachNodeIntoBestModuleInParallel</a></div><div class="ttdeci">unsigned int tryMoveEachNodeIntoBestModuleInParallel()</div><div class="ttdef"><b>Definition:</b> InfomapGreedyCommon.h:847</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a3b5e71572ae01ce0788f919290903b63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b5e71572ae01ce0788f919290903b63">&#9670;&nbsp;</a></span>optimizeModulesCrude()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InfomapGreedyDerivedType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="classInfomapGreedyCommon.html">InfomapGreedyCommon</a>&lt; InfomapGreedyDerivedType &gt;::optimizeModulesCrude </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Loop through each node and move it to the strongest connected module. Start over until converged.</p>
<dl class="section return"><dt>Returns</dt><dd>The number of effective optimization rounds, i.e. zero if no move was made. </dd></dl>

<p>Implements <a class="el" href="classInfomapBase.html#acb6dc935567c31d7ada4b514c5b8dcea">InfomapBase</a>.</p>
<div class="fragment"><div class="line"><a name="l00394"></a><span class="lineno">  394</span>&#160;{</div><div class="line"><a name="l00395"></a><span class="lineno">  395</span>&#160;    m_coreLoopCount = 0;</div><div class="line"><a name="l00396"></a><span class="lineno">  396</span>&#160;    <span class="comment">// double oldCodelength = Super::codelength;</span></div><div class="line"><a name="l00397"></a><span class="lineno">  397</span>&#160;    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> loopLimit = Super::m_config.coreLoopLimit;</div><div class="line"><a name="l00398"></a><span class="lineno">  398</span>&#160;    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> minRandLoop = 3;</div><div class="line"><a name="l00399"></a><span class="lineno">  399</span>&#160;    <span class="keywordflow">if</span> (loopLimit &gt;= minRandLoop &amp;&amp; Super::m_config.randomizeCoreLoopLimit)</div><div class="line"><a name="l00400"></a><span class="lineno">  400</span>&#160;        loopLimit = <span class="keyword">static_cast&lt;</span><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span><span class="keyword">&gt;</span>(Super::m_rand() * (loopLimit - minRandLoop)) + minRandLoop;</div><div class="line"><a name="l00401"></a><span class="lineno">  401</span>&#160;    <span class="comment">// unsigned int loopLimitOnAggregationLevels = -1;</span></div><div class="line"><a name="l00402"></a><span class="lineno">  402</span>&#160;    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> numMoved = 0;</div><div class="line"><a name="l00403"></a><span class="lineno">  403</span>&#160;</div><div class="line"><a name="l00404"></a><span class="lineno">  404</span>&#160;    <span class="comment">// Iterate while the optimization loop moves some nodes within the dynamic modular structure</span></div><div class="line"><a name="l00405"></a><span class="lineno">  405</span>&#160;    <span class="keywordflow">do</span></div><div class="line"><a name="l00406"></a><span class="lineno">  406</span>&#160;    {</div><div class="line"><a name="l00407"></a><span class="lineno">  407</span>&#160;        <span class="comment">// oldCodelength = Super::codelength;</span></div><div class="line"><a name="l00408"></a><span class="lineno">  408</span>&#160;        numMoved = <a class="code" href="classInfomapGreedyCommon.html#ac1026d8aaeb5a5ceeb6c272d6adba431">tryMoveEachNodeIntoStrongestConnectedModule</a>(); <span class="comment">// returns numNodesMoved</span></div><div class="line"><a name="l00409"></a><span class="lineno">  409</span>&#160;        ++m_coreLoopCount;</div><div class="line"><a name="l00410"></a><span class="lineno">  410</span>&#160;    } <span class="keywordflow">while</span> (m_coreLoopCount != loopLimit &amp;&amp; numMoved &gt; 0);</div><div class="line"><a name="l00411"></a><span class="lineno">  411</span>&#160;</div><div class="line"><a name="l00412"></a><span class="lineno">  412</span>&#160;    <span class="keywordflow">return</span> m_coreLoopCount;</div><div class="line"><a name="l00413"></a><span class="lineno">  413</span>&#160;}</div><div class="ttc" id="classInfomapGreedyCommon_html_ac1026d8aaeb5a5ceeb6c272d6adba431"><div class="ttname"><a href="classInfomapGreedyCommon.html#ac1026d8aaeb5a5ceeb6c272d6adba431">InfomapGreedyCommon::tryMoveEachNodeIntoStrongestConnectedModule</a></div><div class="ttdeci">unsigned int tryMoveEachNodeIntoStrongestConnectedModule()</div><div class="ttdef"><b>Definition:</b> InfomapGreedyCommon.h:1126</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a25af363aae49138b379a823b6ab2ad5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25af363aae49138b379a823b6ab2ad5c">&#9670;&nbsp;</a></span>tryMoveEachNodeIntoBestModule()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InfomapGreedyDerivedType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="classInfomapGreedyCommon.html">InfomapGreedyCommon</a>&lt; InfomapGreedyDerivedType &gt;::tryMoveEachNodeIntoBestModule </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Minimize the codelength by trying to move each node into best module.</p>
<p>For each node:</p><ol type="1">
<li>Calculate the change in codelength for a move to each of its neighbouring modules or to an empty module</li>
<li>Move to the one that reduces the codelength the most, if any.</li>
</ol>
<dl class="section return"><dt>Returns</dt><dd>The number of nodes moved. </dd></dl>
<div class="fragment"><div class="line"><a name="l00427"></a><span class="lineno">  427</span>&#160;{</div><div class="line"><a name="l00428"></a><span class="lineno">  428</span>&#160;    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> numNodes = Super::m_activeNetwork.size();</div><div class="line"><a name="l00429"></a><span class="lineno">  429</span>&#160;    <span class="comment">// Get random enumeration of nodes</span></div><div class="line"><a name="l00430"></a><span class="lineno">  430</span>&#160;    std::vector&lt;unsigned int&gt; randomOrder(numNodes);</div><div class="line"><a name="l00431"></a><span class="lineno">  431</span>&#160;    infomath::getRandomizedIndexVector(randomOrder, Super::m_rand);</div><div class="line"><a name="l00432"></a><span class="lineno">  432</span>&#160;</div><div class="line"><a name="l00433"></a><span class="lineno">  433</span>&#160;    std::vector&lt;DeltaFlowType&gt; moduleDeltaEnterExit(numNodes);</div><div class="line"><a name="l00434"></a><span class="lineno">  434</span>&#160;    std::vector&lt;unsigned int&gt; redirect(numNodes, 0);</div><div class="line"><a name="l00435"></a><span class="lineno">  435</span>&#160;    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> offset = 1;</div><div class="line"><a name="l00436"></a><span class="lineno">  436</span>&#160;    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> maxOffset = std::numeric_limits&lt;unsigned int&gt;::max() - 1 - numNodes;</div><div class="line"><a name="l00437"></a><span class="lineno">  437</span>&#160;</div><div class="line"><a name="l00438"></a><span class="lineno">  438</span>&#160;</div><div class="line"><a name="l00439"></a><span class="lineno">  439</span>&#160;    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> numMoved = 0;</div><div class="line"><a name="l00440"></a><span class="lineno">  440</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; numNodes; ++i)</div><div class="line"><a name="l00441"></a><span class="lineno">  441</span>&#160;    {</div><div class="line"><a name="l00442"></a><span class="lineno">  442</span>&#160;        <span class="comment">// Reset offset before overflow</span></div><div class="line"><a name="l00443"></a><span class="lineno">  443</span>&#160;        <span class="keywordflow">if</span> (offset &gt; maxOffset)</div><div class="line"><a name="l00444"></a><span class="lineno">  444</span>&#160;        {</div><div class="line"><a name="l00445"></a><span class="lineno">  445</span>&#160;            redirect.assign(numNodes, 0);</div><div class="line"><a name="l00446"></a><span class="lineno">  446</span>&#160;            offset = 1;</div><div class="line"><a name="l00447"></a><span class="lineno">  447</span>&#160;        }</div><div class="line"><a name="l00448"></a><span class="lineno">  448</span>&#160;</div><div class="line"><a name="l00449"></a><span class="lineno">  449</span>&#160;        <span class="comment">// Pick nodes in random order</span></div><div class="line"><a name="l00450"></a><span class="lineno">  450</span>&#160;        <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> flip = randomOrder[i];</div><div class="line"><a name="l00451"></a><span class="lineno">  451</span>&#160;        NodeType&amp; current = getNode(*Super::m_activeNetwork[flip]);</div><div class="line"><a name="l00452"></a><span class="lineno">  452</span>&#160;</div><div class="line"><a name="l00453"></a><span class="lineno">  453</span>&#160;        <span class="keywordflow">if</span> (!current.dirty)</div><div class="line"><a name="l00454"></a><span class="lineno">  454</span>&#160;            <span class="keywordflow">continue</span>;</div><div class="line"><a name="l00455"></a><span class="lineno">  455</span>&#160;</div><div class="line"><a name="l00456"></a><span class="lineno">  456</span>&#160;        <span class="comment">// Don&#39;t move out from previous merge on first loop</span></div><div class="line"><a name="l00457"></a><span class="lineno">  457</span>&#160;        <span class="keywordflow">if</span> (Super::m_moduleMembers[current.index] &gt; 1 &amp;&amp; Super::isFirstLoop() &amp;&amp; m_config.tuneIterationLimit != 1)</div><div class="line"><a name="l00458"></a><span class="lineno">  458</span>&#160;            <span class="keywordflow">continue</span>;</div><div class="line"><a name="l00459"></a><span class="lineno">  459</span>&#160;</div><div class="line"><a name="l00460"></a><span class="lineno">  460</span>&#160;        <span class="comment">// Don&#39;t decrease the number of modules if already equal the preferred number</span></div><div class="line"><a name="l00461"></a><span class="lineno">  461</span>&#160;        <span class="keywordflow">if</span> (Super::isTopLevel() &amp;&amp; Super::numActiveModules() == m_config.preferredNumberOfModules &amp;&amp; Super::m_moduleMembers[current.index] == 1)</div><div class="line"><a name="l00462"></a><span class="lineno">  462</span>&#160;            <span class="keywordflow">continue</span>;</div><div class="line"><a name="l00463"></a><span class="lineno">  463</span>&#160;</div><div class="line"><a name="l00464"></a><span class="lineno">  464</span>&#160;</div><div class="line"><a name="l00465"></a><span class="lineno">  465</span>&#160;        <span class="comment">// If no links connecting this node with other nodes, it won&#39;t move into others,</span></div><div class="line"><a name="l00466"></a><span class="lineno">  466</span>&#160;        <span class="comment">// and others won&#39;t move into this. TODO: Always best leave it alone?</span></div><div class="line"><a name="l00467"></a><span class="lineno">  467</span>&#160;<span class="comment">//      if (current.degree() == 0)</span></div><div class="line"><a name="l00468"></a><span class="lineno">  468</span>&#160;        <span class="comment">// if (current.degree() == 0 ||</span></div><div class="line"><a name="l00469"></a><span class="lineno">  469</span>&#160;        <span class="comment">//  (Super::m_config.includeSelfLinks &amp;&amp;</span></div><div class="line"><a name="l00470"></a><span class="lineno">  470</span>&#160;        <span class="comment">//  (current.outDegree() == 1 &amp;&amp; current.inDegree() == 1) &amp;&amp;</span></div><div class="line"><a name="l00471"></a><span class="lineno">  471</span>&#160;        <span class="comment">//  (**current.begin_outEdge()).target == current))</span></div><div class="line"><a name="l00472"></a><span class="lineno">  472</span>&#160;        <span class="comment">// {</span></div><div class="line"><a name="l00473"></a><span class="lineno">  473</span>&#160;        <span class="comment">//  DEBUG_OUT(&quot;SKIPPING isolated node &quot; &lt;&lt; current &lt;&lt; &quot;\n&quot;);</span></div><div class="line"><a name="l00474"></a><span class="lineno">  474</span>&#160;        <span class="comment">//  //TODO: If not skipping self-links, this yields different results from moveNodesToPredefinedModules!!</span></div><div class="line"><a name="l00475"></a><span class="lineno">  475</span>&#160;        <span class="comment">//  ASSERT(!m_config.includeSelfLinks);</span></div><div class="line"><a name="l00476"></a><span class="lineno">  476</span>&#160;        <span class="comment">//  current.dirty = false;</span></div><div class="line"><a name="l00477"></a><span class="lineno">  477</span>&#160;        <span class="comment">//  continue;</span></div><div class="line"><a name="l00478"></a><span class="lineno">  478</span>&#160;        <span class="comment">// }</span></div><div class="line"><a name="l00479"></a><span class="lineno">  479</span>&#160;</div><div class="line"><a name="l00480"></a><span class="lineno">  480</span>&#160;        <span class="comment">// Create vector with module links</span></div><div class="line"><a name="l00481"></a><span class="lineno">  481</span>&#160;</div><div class="line"><a name="l00482"></a><span class="lineno">  482</span>&#160;        <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> numModuleLinks = 0;</div><div class="line"><a name="l00483"></a><span class="lineno">  483</span>&#160;        <span class="keywordflow">if</span> (current.isDangling())</div><div class="line"><a name="l00484"></a><span class="lineno">  484</span>&#160;        {</div><div class="line"><a name="l00485"></a><span class="lineno">  485</span>&#160;            redirect[current.index] = offset + numModuleLinks;</div><div class="line"><a name="l00486"></a><span class="lineno">  486</span>&#160;            moduleDeltaEnterExit[numModuleLinks] = DeltaFlowType(current.index, 0.0, 0.0);</div><div class="line"><a name="l00487"></a><span class="lineno">  487</span>&#160;            ++numModuleLinks;</div><div class="line"><a name="l00488"></a><span class="lineno">  488</span>&#160;        }</div><div class="line"><a name="l00489"></a><span class="lineno">  489</span>&#160;        <span class="keywordflow">else</span></div><div class="line"><a name="l00490"></a><span class="lineno">  490</span>&#160;        {</div><div class="line"><a name="l00491"></a><span class="lineno">  491</span>&#160;            <span class="comment">// For all outlinks</span></div><div class="line"><a name="l00492"></a><span class="lineno">  492</span>&#160;            <span class="keywordflow">for</span> (NodeBase::edge_iterator edgeIt(current.begin_outEdge()), endIt(current.end_outEdge());</div><div class="line"><a name="l00493"></a><span class="lineno">  493</span>&#160;                    edgeIt != endIt; ++edgeIt)</div><div class="line"><a name="l00494"></a><span class="lineno">  494</span>&#160;            {</div><div class="line"><a name="l00495"></a><span class="lineno">  495</span>&#160;                EdgeType&amp; edge = **edgeIt;</div><div class="line"><a name="l00496"></a><span class="lineno">  496</span>&#160;                <span class="keywordflow">if</span> (edge.isSelfPointing())</div><div class="line"><a name="l00497"></a><span class="lineno">  497</span>&#160;                    <span class="keywordflow">continue</span>;</div><div class="line"><a name="l00498"></a><span class="lineno">  498</span>&#160;                NodeType&amp; neighbour = getNode(edge.target);</div><div class="line"><a name="l00499"></a><span class="lineno">  499</span>&#160;</div><div class="line"><a name="l00500"></a><span class="lineno">  500</span>&#160;                <span class="keywordflow">if</span> (redirect[neighbour.index] &gt;= offset)</div><div class="line"><a name="l00501"></a><span class="lineno">  501</span>&#160;                {</div><div class="line"><a name="l00502"></a><span class="lineno">  502</span>&#160;                    moduleDeltaEnterExit[redirect[neighbour.index] - offset].deltaExit += edge.data.flow;</div><div class="line"><a name="l00503"></a><span class="lineno">  503</span>&#160;                }</div><div class="line"><a name="l00504"></a><span class="lineno">  504</span>&#160;                <span class="keywordflow">else</span></div><div class="line"><a name="l00505"></a><span class="lineno">  505</span>&#160;                {</div><div class="line"><a name="l00506"></a><span class="lineno">  506</span>&#160;                    redirect[neighbour.index] = offset + numModuleLinks;</div><div class="line"><a name="l00507"></a><span class="lineno">  507</span>&#160;                    moduleDeltaEnterExit[numModuleLinks] = DeltaFlowType(neighbour.index, edge.data.flow, 0.0);</div><div class="line"><a name="l00508"></a><span class="lineno">  508</span>&#160;                    ++numModuleLinks;</div><div class="line"><a name="l00509"></a><span class="lineno">  509</span>&#160;                }</div><div class="line"><a name="l00510"></a><span class="lineno">  510</span>&#160;            }</div><div class="line"><a name="l00511"></a><span class="lineno">  511</span>&#160;        }</div><div class="line"><a name="l00512"></a><span class="lineno">  512</span>&#160;        <span class="comment">// For all inlinks</span></div><div class="line"><a name="l00513"></a><span class="lineno">  513</span>&#160;        <span class="keywordflow">for</span> (NodeBase::edge_iterator edgeIt(current.begin_inEdge()), endIt(current.end_inEdge());</div><div class="line"><a name="l00514"></a><span class="lineno">  514</span>&#160;                edgeIt != endIt; ++edgeIt)</div><div class="line"><a name="l00515"></a><span class="lineno">  515</span>&#160;        {</div><div class="line"><a name="l00516"></a><span class="lineno">  516</span>&#160;            EdgeType&amp; edge = **edgeIt;</div><div class="line"><a name="l00517"></a><span class="lineno">  517</span>&#160;            <span class="keywordflow">if</span> (edge.isSelfPointing())</div><div class="line"><a name="l00518"></a><span class="lineno">  518</span>&#160;                <span class="keywordflow">continue</span>;</div><div class="line"><a name="l00519"></a><span class="lineno">  519</span>&#160;            NodeType&amp; neighbour = getNode(edge.source);</div><div class="line"><a name="l00520"></a><span class="lineno">  520</span>&#160;</div><div class="line"><a name="l00521"></a><span class="lineno">  521</span>&#160;            <span class="keywordflow">if</span> (redirect[neighbour.index] &gt;= offset)</div><div class="line"><a name="l00522"></a><span class="lineno">  522</span>&#160;            {</div><div class="line"><a name="l00523"></a><span class="lineno">  523</span>&#160;                moduleDeltaEnterExit[redirect[neighbour.index] - offset].deltaEnter += edge.data.flow;</div><div class="line"><a name="l00524"></a><span class="lineno">  524</span>&#160;            }</div><div class="line"><a name="l00525"></a><span class="lineno">  525</span>&#160;            <span class="keywordflow">else</span></div><div class="line"><a name="l00526"></a><span class="lineno">  526</span>&#160;            {</div><div class="line"><a name="l00527"></a><span class="lineno">  527</span>&#160;                redirect[neighbour.index] = offset + numModuleLinks;</div><div class="line"><a name="l00528"></a><span class="lineno">  528</span>&#160;                moduleDeltaEnterExit[numModuleLinks] = DeltaFlowType(neighbour.index, 0.0, edge.data.flow);</div><div class="line"><a name="l00529"></a><span class="lineno">  529</span>&#160;                ++numModuleLinks;</div><div class="line"><a name="l00530"></a><span class="lineno">  530</span>&#160;            }</div><div class="line"><a name="l00531"></a><span class="lineno">  531</span>&#160;        }</div><div class="line"><a name="l00532"></a><span class="lineno">  532</span>&#160;</div><div class="line"><a name="l00533"></a><span class="lineno">  533</span>&#160;        <span class="comment">// If alone in the module, add virtual link to the module (used when adding teleportation)</span></div><div class="line"><a name="l00534"></a><span class="lineno">  534</span>&#160;        <span class="keywordflow">if</span> (redirect[current.index] &lt; offset)</div><div class="line"><a name="l00535"></a><span class="lineno">  535</span>&#160;        {</div><div class="line"><a name="l00536"></a><span class="lineno">  536</span>&#160;            redirect[current.index] = offset + numModuleLinks;</div><div class="line"><a name="l00537"></a><span class="lineno">  537</span>&#160;            moduleDeltaEnterExit[numModuleLinks] = DeltaFlowType(current.index, 0.0, 0.0);</div><div class="line"><a name="l00538"></a><span class="lineno">  538</span>&#160;            ++numModuleLinks;</div><div class="line"><a name="l00539"></a><span class="lineno">  539</span>&#160;        }</div><div class="line"><a name="l00540"></a><span class="lineno">  540</span>&#160;</div><div class="line"><a name="l00541"></a><span class="lineno">  541</span>&#160;</div><div class="line"><a name="l00542"></a><span class="lineno">  542</span>&#160;        <span class="comment">// Empty function if no teleportation coding model</span></div><div class="line"><a name="l00543"></a><span class="lineno">  543</span>&#160;        Super::template addTeleportationDeltaFlowIfMove&lt;DeltaFlowType&gt;(current, moduleDeltaEnterExit, numModuleLinks);</div><div class="line"><a name="l00544"></a><span class="lineno">  544</span>&#160;</div><div class="line"><a name="l00545"></a><span class="lineno">  545</span>&#160;        <span class="comment">// Option to move to empty module (if node not already alone, and not already at the preferred number of modules)</span></div><div class="line"><a name="l00546"></a><span class="lineno">  546</span>&#160;        <span class="keywordflow">if</span> (Super::m_moduleMembers[current.index] &gt; 1 &amp;&amp; Super::m_emptyModules.size() &gt; 0 &amp;&amp;</div><div class="line"><a name="l00547"></a><span class="lineno">  547</span>&#160;                (m_config.preferredNumberOfModules == 0 || (Super::isTopLevel() &amp;&amp; Super::numActiveModules() != m_config.preferredNumberOfModules)))</div><div class="line"><a name="l00548"></a><span class="lineno">  548</span>&#160;        {</div><div class="line"><a name="l00549"></a><span class="lineno">  549</span>&#160;            moduleDeltaEnterExit[numModuleLinks] = DeltaFlowType(Super::m_emptyModules.back(), 0.0, 0.0);</div><div class="line"><a name="l00550"></a><span class="lineno">  550</span>&#160;            ++numModuleLinks;</div><div class="line"><a name="l00551"></a><span class="lineno">  551</span>&#160;        }</div><div class="line"><a name="l00552"></a><span class="lineno">  552</span>&#160;</div><div class="line"><a name="l00553"></a><span class="lineno">  553</span>&#160;        <span class="comment">// Store the DeltaFlow of the current module</span></div><div class="line"><a name="l00554"></a><span class="lineno">  554</span>&#160;        DeltaFlowType oldModuleDelta(moduleDeltaEnterExit[redirect[current.index] - offset]);</div><div class="line"><a name="l00555"></a><span class="lineno">  555</span>&#160;</div><div class="line"><a name="l00556"></a><span class="lineno">  556</span>&#160;</div><div class="line"><a name="l00557"></a><span class="lineno">  557</span>&#160;        <span class="comment">// For memory networks</span></div><div class="line"><a name="l00558"></a><span class="lineno">  558</span>&#160;        derived().addContributionOfMovingMemoryNodes(current, oldModuleDelta, moduleDeltaEnterExit, redirect, offset, numModuleLinks);</div><div class="line"><a name="l00559"></a><span class="lineno">  559</span>&#160;</div><div class="line"><a name="l00560"></a><span class="lineno">  560</span>&#160;</div><div class="line"><a name="l00561"></a><span class="lineno">  561</span>&#160;        <span class="comment">// Randomize link order for optimized search</span></div><div class="line"><a name="l00562"></a><span class="lineno">  562</span>&#160;        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; numModuleLinks - 1; ++j)</div><div class="line"><a name="l00563"></a><span class="lineno">  563</span>&#160;        {</div><div class="line"><a name="l00564"></a><span class="lineno">  564</span>&#160;            <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> randPos = j + Super::m_rand.randInt(numModuleLinks - j - 1);</div><div class="line"><a name="l00565"></a><span class="lineno">  565</span>&#160;            swap(moduleDeltaEnterExit[j], moduleDeltaEnterExit[randPos]);</div><div class="line"><a name="l00566"></a><span class="lineno">  566</span>&#160;        }</div><div class="line"><a name="l00567"></a><span class="lineno">  567</span>&#160;</div><div class="line"><a name="l00568"></a><span class="lineno">  568</span>&#160;        DeltaFlowType bestDeltaModule(oldModuleDelta);</div><div class="line"><a name="l00569"></a><span class="lineno">  569</span>&#160;        <span class="keywordtype">double</span> bestDeltaCodelength = 0.0;</div><div class="line"><a name="l00570"></a><span class="lineno">  570</span>&#160;        DeltaFlowType strongestConnectedModule(oldModuleDelta);</div><div class="line"><a name="l00571"></a><span class="lineno">  571</span>&#160;        <span class="keywordtype">double</span> deltaCodelengthOnStrongestConnectedModule = 0.0;</div><div class="line"><a name="l00572"></a><span class="lineno">  572</span>&#160;</div><div class="line"><a name="l00573"></a><span class="lineno">  573</span>&#160;        <span class="comment">// Find the move that minimizes the description length</span></div><div class="line"><a name="l00574"></a><span class="lineno">  574</span>&#160;        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; numModuleLinks; ++j)</div><div class="line"><a name="l00575"></a><span class="lineno">  575</span>&#160;        {</div><div class="line"><a name="l00576"></a><span class="lineno">  576</span>&#160;            <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> otherModule = moduleDeltaEnterExit[j].module;</div><div class="line"><a name="l00577"></a><span class="lineno">  577</span>&#160;            <span class="keywordflow">if</span>(otherModule != current.index)</div><div class="line"><a name="l00578"></a><span class="lineno">  578</span>&#160;            {</div><div class="line"><a name="l00579"></a><span class="lineno">  579</span>&#160;                <span class="keywordtype">double</span> deltaCodelength = Super::getDeltaCodelengthOnMovingNode(current, oldModuleDelta, moduleDeltaEnterExit[j]);</div><div class="line"><a name="l00580"></a><span class="lineno">  580</span>&#160;                deltaCodelength += derived().getDeltaCodelengthOnMovingMemoryNode(oldModuleDelta, moduleDeltaEnterExit[j]);</div><div class="line"><a name="l00581"></a><span class="lineno">  581</span>&#160;</div><div class="line"><a name="l00582"></a><span class="lineno">  582</span>&#160;                <span class="keywordflow">if</span> (deltaCodelength &lt; bestDeltaCodelength - Super::m_config.minimumSingleNodeCodelengthImprovement)</div><div class="line"><a name="l00583"></a><span class="lineno">  583</span>&#160;                {</div><div class="line"><a name="l00584"></a><span class="lineno">  584</span>&#160;                    bestDeltaModule = moduleDeltaEnterExit[j];</div><div class="line"><a name="l00585"></a><span class="lineno">  585</span>&#160;                    bestDeltaCodelength = deltaCodelength;</div><div class="line"><a name="l00586"></a><span class="lineno">  586</span>&#160;                }</div><div class="line"><a name="l00587"></a><span class="lineno">  587</span>&#160;</div><div class="line"><a name="l00588"></a><span class="lineno">  588</span>&#160;                <span class="comment">// Save strongest connected module to prefer if codelength improvement equal</span></div><div class="line"><a name="l00589"></a><span class="lineno">  589</span>&#160;                <span class="keywordflow">if</span> (moduleDeltaEnterExit[j].deltaExit &gt; strongestConnectedModule.deltaExit)</div><div class="line"><a name="l00590"></a><span class="lineno">  590</span>&#160;                {</div><div class="line"><a name="l00591"></a><span class="lineno">  591</span>&#160;                    strongestConnectedModule = moduleDeltaEnterExit[j];</div><div class="line"><a name="l00592"></a><span class="lineno">  592</span>&#160;                    deltaCodelengthOnStrongestConnectedModule = deltaCodelength;</div><div class="line"><a name="l00593"></a><span class="lineno">  593</span>&#160;                }</div><div class="line"><a name="l00594"></a><span class="lineno">  594</span>&#160;            }</div><div class="line"><a name="l00595"></a><span class="lineno">  595</span>&#160;        }</div><div class="line"><a name="l00596"></a><span class="lineno">  596</span>&#160;</div><div class="line"><a name="l00597"></a><span class="lineno">  597</span>&#160;        <span class="comment">// Prefer strongest connected module if equal delta codelength</span></div><div class="line"><a name="l00598"></a><span class="lineno">  598</span>&#160;        <span class="keywordflow">if</span> (strongestConnectedModule.module != bestDeltaModule.module &amp;&amp;</div><div class="line"><a name="l00599"></a><span class="lineno">  599</span>&#160;                deltaCodelengthOnStrongestConnectedModule &lt;= bestDeltaCodelength + Super::m_config.minimumCodelengthImprovement)</div><div class="line"><a name="l00600"></a><span class="lineno">  600</span>&#160;        {</div><div class="line"><a name="l00601"></a><span class="lineno">  601</span>&#160;            bestDeltaModule = strongestConnectedModule;</div><div class="line"><a name="l00602"></a><span class="lineno">  602</span>&#160;        }</div><div class="line"><a name="l00603"></a><span class="lineno">  603</span>&#160;</div><div class="line"><a name="l00604"></a><span class="lineno">  604</span>&#160;        <span class="comment">// Make best possible move</span></div><div class="line"><a name="l00605"></a><span class="lineno">  605</span>&#160;        <span class="keywordflow">if</span>(bestDeltaModule.module != current.index)</div><div class="line"><a name="l00606"></a><span class="lineno">  606</span>&#160;        {</div><div class="line"><a name="l00607"></a><span class="lineno">  607</span>&#160;            <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> bestModuleIndex = bestDeltaModule.module;</div><div class="line"><a name="l00608"></a><span class="lineno">  608</span>&#160;            <span class="comment">//Update empty module vector</span></div><div class="line"><a name="l00609"></a><span class="lineno">  609</span>&#160;            <span class="keywordflow">if</span>(Super::m_moduleMembers[bestModuleIndex] == 0)</div><div class="line"><a name="l00610"></a><span class="lineno">  610</span>&#160;            {</div><div class="line"><a name="l00611"></a><span class="lineno">  611</span>&#160;                Super::m_emptyModules.pop_back();</div><div class="line"><a name="l00612"></a><span class="lineno">  612</span>&#160;            }</div><div class="line"><a name="l00613"></a><span class="lineno">  613</span>&#160;            <span class="keywordflow">if</span>(Super::m_moduleMembers[current.index] == 1)</div><div class="line"><a name="l00614"></a><span class="lineno">  614</span>&#160;            {</div><div class="line"><a name="l00615"></a><span class="lineno">  615</span>&#160;                Super::m_emptyModules.push_back(current.index);</div><div class="line"><a name="l00616"></a><span class="lineno">  616</span>&#160;            }</div><div class="line"><a name="l00617"></a><span class="lineno">  617</span>&#160;</div><div class="line"><a name="l00618"></a><span class="lineno">  618</span>&#160;            <a class="code" href="classInfomapGreedySpecialized.html#a6f4ff75d89a26f1b474ca5a2190878c7">Super::updateCodelengthOnMovingNode</a>(current, oldModuleDelta, bestDeltaModule);</div><div class="line"><a name="l00619"></a><span class="lineno">  619</span>&#160;            derived().updateCodelengthOnMovingMemoryNode(oldModuleDelta, bestDeltaModule);</div><div class="line"><a name="l00620"></a><span class="lineno">  620</span>&#160;</div><div class="line"><a name="l00621"></a><span class="lineno">  621</span>&#160;            Super::m_moduleMembers[current.index] -= 1;</div><div class="line"><a name="l00622"></a><span class="lineno">  622</span>&#160;            Super::m_moduleMembers[bestModuleIndex] += 1;</div><div class="line"><a name="l00623"></a><span class="lineno">  623</span>&#160;</div><div class="line"><a name="l00624"></a><span class="lineno">  624</span>&#160;            <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> oldModuleIndex = current.index;</div><div class="line"><a name="l00625"></a><span class="lineno">  625</span>&#160;            current.index = bestModuleIndex;</div><div class="line"><a name="l00626"></a><span class="lineno">  626</span>&#160;</div><div class="line"><a name="l00627"></a><span class="lineno">  627</span>&#160;            <span class="comment">// Update physical node map on move for memory networks</span></div><div class="line"><a name="l00628"></a><span class="lineno">  628</span>&#160;            derived().performMoveOfMemoryNode(current, oldModuleIndex, bestModuleIndex);</div><div class="line"><a name="l00629"></a><span class="lineno">  629</span>&#160;</div><div class="line"><a name="l00630"></a><span class="lineno">  630</span>&#160;            ++numMoved;</div><div class="line"><a name="l00631"></a><span class="lineno">  631</span>&#160;</div><div class="line"><a name="l00632"></a><span class="lineno">  632</span>&#160;            <span class="comment">// Mark neighbours as dirty</span></div><div class="line"><a name="l00633"></a><span class="lineno">  633</span>&#160;            <span class="keywordflow">for</span> (NodeBase::edge_iterator edgeIt(current.begin_outEdge()), endIt(current.end_outEdge());</div><div class="line"><a name="l00634"></a><span class="lineno">  634</span>&#160;                    edgeIt != endIt; ++edgeIt)</div><div class="line"><a name="l00635"></a><span class="lineno">  635</span>&#160;                (*edgeIt)-&gt;target.dirty = <span class="keyword">true</span>;</div><div class="line"><a name="l00636"></a><span class="lineno">  636</span>&#160;            for (NodeBase::edge_iterator edgeIt(current.begin_inEdge()), endIt(current.end_inEdge());</div><div class="line"><a name="l00637"></a><span class="lineno">  637</span>&#160;                    edgeIt != endIt; ++edgeIt)</div><div class="line"><a name="l00638"></a><span class="lineno">  638</span>&#160;                (*edgeIt)-&gt;source.dirty = <span class="keyword">true</span>;</div><div class="line"><a name="l00639"></a><span class="lineno">  639</span>&#160;        }</div><div class="line"><a name="l00640"></a><span class="lineno">  640</span>&#160;        <span class="keywordflow">else</span></div><div class="line"><a name="l00641"></a><span class="lineno">  641</span>&#160;            current.dirty = <span class="keyword">false</span>;</div><div class="line"><a name="l00642"></a><span class="lineno">  642</span>&#160;</div><div class="line"><a name="l00643"></a><span class="lineno">  643</span>&#160;        offset += numNodes;</div><div class="line"><a name="l00644"></a><span class="lineno">  644</span>&#160;    }</div><div class="line"><a name="l00645"></a><span class="lineno">  645</span>&#160;</div><div class="line"><a name="l00646"></a><span class="lineno">  646</span>&#160;    <span class="keywordflow">return</span> numMoved;</div><div class="line"><a name="l00647"></a><span class="lineno">  647</span>&#160;}</div><div class="ttc" id="classInfomapGreedySpecialized_html_a6f4ff75d89a26f1b474ca5a2190878c7"><div class="ttname"><a href="classInfomapGreedySpecialized.html#a6f4ff75d89a26f1b474ca5a2190878c7">InfomapGreedySpecialized::updateCodelengthOnMovingNode</a></div><div class="ttdeci">void updateCodelengthOnMovingNode(NodeType &amp;current, DeltaFlow &amp;oldModuleDelta, DeltaFlow &amp;newModuleDelta)</div><div class="ttdef"><b>Definition:</b> InfomapGreedySpecialized.h:322</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="aebf032fcd793b9496e5b1952cb14c233"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebf032fcd793b9496e5b1952cb14c233">&#9670;&nbsp;</a></span>tryMoveEachNodeIntoBestModuleInParallel()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InfomapGreedyDerivedType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="classInfomapGreedyCommon.html">InfomapGreedyCommon</a>&lt; InfomapGreedyDerivedType &gt;::tryMoveEachNodeIntoBestModuleInParallel </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Minimize the codelength by trying to move each node into best module, in parallel.</p>
<p>For each node:</p><ol type="1">
<li>Calculate the change in codelength for a move to each of its neighbouring modules or to an empty module</li>
<li>Move to the one that reduces the codelength the most, if any.</li>
</ol>
<dl class="section return"><dt>Returns</dt><dd>The number of nodes moved. </dd></dl>
<div class="fragment"><div class="line"><a name="l00848"></a><span class="lineno">  848</span>&#160;{</div><div class="line"><a name="l00849"></a><span class="lineno">  849</span>&#160;    <span class="comment">// Don&#39;t nest parallelization</span></div><div class="line"><a name="l00850"></a><span class="lineno">  850</span>&#160;    <span class="keywordflow">if</span> (!Super::isTopLevel())</div><div class="line"><a name="l00851"></a><span class="lineno">  851</span>&#160;        <span class="keywordflow">return</span> <a class="code" href="classInfomapGreedyCommon.html#a25af363aae49138b379a823b6ab2ad5c">tryMoveEachNodeIntoBestModule</a>();</div><div class="line"><a name="l00852"></a><span class="lineno">  852</span>&#160;</div><div class="line"><a name="l00853"></a><span class="lineno">  853</span>&#160;    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> numNodes = Super::m_activeNetwork.size();</div><div class="line"><a name="l00854"></a><span class="lineno">  854</span>&#160;    <span class="comment">// Get random enumeration of nodes</span></div><div class="line"><a name="l00855"></a><span class="lineno">  855</span>&#160;    std::vector&lt;unsigned int&gt; randomOrder(numNodes);</div><div class="line"><a name="l00856"></a><span class="lineno">  856</span>&#160;    infomath::getRandomizedIndexVector(randomOrder, Super::m_rand);</div><div class="line"><a name="l00857"></a><span class="lineno">  857</span>&#160;</div><div class="line"><a name="l00858"></a><span class="lineno">  858</span>&#160;    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> numMoved = 0;</div><div class="line"><a name="l00859"></a><span class="lineno">  859</span>&#160;    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> numInvalidMoves = 0;</div><div class="line"><a name="l00860"></a><span class="lineno">  860</span>&#160;    <span class="keywordtype">double</span> diffSerialParallelCodelength = 0.0;</div><div class="line"><a name="l00861"></a><span class="lineno">  861</span>&#160;    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> emptyTarget = numNodes; <span class="comment">// Use last node index + 1 as index for empty module target.</span></div><div class="line"><a name="l00862"></a><span class="lineno">  862</span>&#160;    <span class="keywordtype">int</span> numNodesInt = <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(numNodes);</div><div class="line"><a name="l00863"></a><span class="lineno">  863</span>&#160;</div><div class="line"><a name="l00864"></a><span class="lineno">  864</span>&#160;<span class="comment">//#pragma omp parallel for schedule(static)</span></div><div class="line"><a name="l00865"></a><span class="lineno">  865</span>&#160;<span class="preprocessor">#pragma omp parallel for schedule(dynamic) // Use dynamic scheduling as some threads could end early</span></div><div class="line"><a name="l00866"></a><span class="lineno">  866</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; numNodesInt; ++i)</div><div class="line"><a name="l00867"></a><span class="lineno">  867</span>&#160;    {</div><div class="line"><a name="l00868"></a><span class="lineno">  868</span>&#160;<span class="comment">//      printf(&quot;Node %d processed by thread %d\n&quot;, i, omp_get_thread_num());</span></div><div class="line"><a name="l00869"></a><span class="lineno">  869</span>&#160;        <span class="comment">// Pick nodes in random order</span></div><div class="line"><a name="l00870"></a><span class="lineno">  870</span>&#160;        <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> flip = randomOrder[i];</div><div class="line"><a name="l00871"></a><span class="lineno">  871</span>&#160;        NodeType&amp; current = getNode(*Super::m_activeNetwork[flip]);</div><div class="line"><a name="l00872"></a><span class="lineno">  872</span>&#160;</div><div class="line"><a name="l00873"></a><span class="lineno">  873</span>&#160;        <span class="keywordflow">if</span> (!current.dirty)</div><div class="line"><a name="l00874"></a><span class="lineno">  874</span>&#160;            <span class="keywordflow">continue</span>;</div><div class="line"><a name="l00875"></a><span class="lineno">  875</span>&#160;</div><div class="line"><a name="l00876"></a><span class="lineno">  876</span>&#160;        <span class="comment">// If other nodes have moved here, don&#39;t move away on first loop</span></div><div class="line"><a name="l00877"></a><span class="lineno">  877</span>&#160;        <span class="keywordflow">if</span> (Super::m_moduleMembers[current.index] &gt; 1 &amp;&amp; Super::isFirstLoop() &amp;&amp; m_config.tuneIterationLimit != 1)</div><div class="line"><a name="l00878"></a><span class="lineno">  878</span>&#160;            <span class="keywordflow">continue</span>;</div><div class="line"><a name="l00879"></a><span class="lineno">  879</span>&#160;</div><div class="line"><a name="l00880"></a><span class="lineno">  880</span>&#160;        <span class="comment">// Don&#39;t decrease the number of modules if already equal the preferred number</span></div><div class="line"><a name="l00881"></a><span class="lineno">  881</span>&#160;        <span class="keywordflow">if</span> (Super::isTopLevel() &amp;&amp; Super::numActiveModules() == m_config.preferredNumberOfModules &amp;&amp; Super::m_moduleMembers[current.index] == 1)</div><div class="line"><a name="l00882"></a><span class="lineno">  882</span>&#160;            <span class="keywordflow">continue</span>;</div><div class="line"><a name="l00883"></a><span class="lineno">  883</span>&#160;</div><div class="line"><a name="l00884"></a><span class="lineno">  884</span>&#160;        <span class="comment">// If no links connecting this node with other nodes, it won&#39;t move into others,</span></div><div class="line"><a name="l00885"></a><span class="lineno">  885</span>&#160;        <span class="comment">// and others won&#39;t move into this. TODO: Always best leave it alone?</span></div><div class="line"><a name="l00886"></a><span class="lineno">  886</span>&#160;<span class="comment">//      if (current.degree() == 0)</span></div><div class="line"><a name="l00887"></a><span class="lineno">  887</span>&#160;        <span class="keywordflow">if</span> (current.degree() == 0 ||</div><div class="line"><a name="l00888"></a><span class="lineno">  888</span>&#160;            (Super::m_config.includeSelfLinks &amp;&amp;</div><div class="line"><a name="l00889"></a><span class="lineno">  889</span>&#160;            (current.outDegree() == 1 &amp;&amp; current.inDegree() == 1) &amp;&amp;</div><div class="line"><a name="l00890"></a><span class="lineno">  890</span>&#160;            (**current.begin_outEdge()).target == current))</div><div class="line"><a name="l00891"></a><span class="lineno">  891</span>&#160;        {</div><div class="line"><a name="l00892"></a><span class="lineno">  892</span>&#160;            DEBUG_OUT(<span class="stringliteral">&quot;SKIPPING isolated node &quot;</span> &lt;&lt; current &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>);</div><div class="line"><a name="l00893"></a><span class="lineno">  893</span>&#160;            <span class="comment">//TODO: If not skipping self-links, this yields different results from moveNodesToPredefinedModules!!</span></div><div class="line"><a name="l00894"></a><span class="lineno">  894</span>&#160;            ASSERT(!m_config.includeSelfLinks);</div><div class="line"><a name="l00895"></a><span class="lineno">  895</span>&#160;            current.dirty = <span class="keyword">false</span>;</div><div class="line"><a name="l00896"></a><span class="lineno">  896</span>&#160;            <span class="keywordflow">continue</span>;</div><div class="line"><a name="l00897"></a><span class="lineno">  897</span>&#160;        }</div><div class="line"><a name="l00898"></a><span class="lineno">  898</span>&#160;</div><div class="line"><a name="l00899"></a><span class="lineno">  899</span>&#160;        <span class="comment">// Create map with module links</span></div><div class="line"><a name="l00900"></a><span class="lineno">  900</span>&#160;        std::map&lt;unsigned int, DeltaFlowType&gt; deltaFlow;</div><div class="line"><a name="l00901"></a><span class="lineno">  901</span>&#160;</div><div class="line"><a name="l00902"></a><span class="lineno">  902</span>&#160;        <span class="comment">// If alone in the module, add virtual link to the module (used when adding teleportation)</span></div><div class="line"><a name="l00903"></a><span class="lineno">  903</span>&#160;        deltaFlow[current.index] += DeltaFlowType(current.index, 0.0, 0.0);</div><div class="line"><a name="l00904"></a><span class="lineno">  904</span>&#160;</div><div class="line"><a name="l00905"></a><span class="lineno">  905</span>&#160;        <span class="comment">// For all outlinks</span></div><div class="line"><a name="l00906"></a><span class="lineno">  906</span>&#160;        <span class="keywordflow">for</span> (NodeBase::edge_iterator edgeIt(current.begin_outEdge()), endIt(current.end_outEdge());</div><div class="line"><a name="l00907"></a><span class="lineno">  907</span>&#160;                edgeIt != endIt; ++edgeIt)</div><div class="line"><a name="l00908"></a><span class="lineno">  908</span>&#160;        {</div><div class="line"><a name="l00909"></a><span class="lineno">  909</span>&#160;            EdgeType&amp; edge = **edgeIt;</div><div class="line"><a name="l00910"></a><span class="lineno">  910</span>&#160;            <span class="keywordflow">if</span> (edge.isSelfPointing())</div><div class="line"><a name="l00911"></a><span class="lineno">  911</span>&#160;                <span class="keywordflow">continue</span>;</div><div class="line"><a name="l00912"></a><span class="lineno">  912</span>&#160;            NodeType&amp; neighbour = getNode(edge.target);</div><div class="line"><a name="l00913"></a><span class="lineno">  913</span>&#160;</div><div class="line"><a name="l00914"></a><span class="lineno">  914</span>&#160;            deltaFlow[neighbour.index] += DeltaFlowType(neighbour.index, edge.data.flow, 0.0);</div><div class="line"><a name="l00915"></a><span class="lineno">  915</span>&#160;        }</div><div class="line"><a name="l00916"></a><span class="lineno">  916</span>&#160;        <span class="comment">// For all inlinks</span></div><div class="line"><a name="l00917"></a><span class="lineno">  917</span>&#160;        <span class="keywordflow">for</span> (NodeBase::edge_iterator edgeIt(current.begin_inEdge()), endIt(current.end_inEdge());</div><div class="line"><a name="l00918"></a><span class="lineno">  918</span>&#160;                edgeIt != endIt; ++edgeIt)</div><div class="line"><a name="l00919"></a><span class="lineno">  919</span>&#160;        {</div><div class="line"><a name="l00920"></a><span class="lineno">  920</span>&#160;            EdgeType&amp; edge = **edgeIt;</div><div class="line"><a name="l00921"></a><span class="lineno">  921</span>&#160;            <span class="keywordflow">if</span> (edge.isSelfPointing())</div><div class="line"><a name="l00922"></a><span class="lineno">  922</span>&#160;                <span class="keywordflow">continue</span>;</div><div class="line"><a name="l00923"></a><span class="lineno">  923</span>&#160;            NodeType&amp; neighbour = getNode(edge.source);</div><div class="line"><a name="l00924"></a><span class="lineno">  924</span>&#160;</div><div class="line"><a name="l00925"></a><span class="lineno">  925</span>&#160;            deltaFlow[neighbour.index] += DeltaFlowType(neighbour.index, 0.0, edge.data.flow);</div><div class="line"><a name="l00926"></a><span class="lineno">  926</span>&#160;        }</div><div class="line"><a name="l00927"></a><span class="lineno">  927</span>&#160;</div><div class="line"><a name="l00928"></a><span class="lineno">  928</span>&#160;</div><div class="line"><a name="l00929"></a><span class="lineno">  929</span>&#160;        <span class="comment">// Empty function if no teleportation coding model</span></div><div class="line"><a name="l00930"></a><span class="lineno">  930</span>&#160;        Super::template addTeleportationDeltaFlowIfMove&lt;DeltaFlowType&gt;(current, deltaFlow);</div><div class="line"><a name="l00931"></a><span class="lineno">  931</span>&#160;</div><div class="line"><a name="l00932"></a><span class="lineno">  932</span>&#160;        <span class="comment">// Option to move to empty module (if node not already alone, and not already at the preferred number of modules)</span></div><div class="line"><a name="l00933"></a><span class="lineno">  933</span>&#160;        <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> emptyModuleIndex = emptyTarget;</div><div class="line"><a name="l00934"></a><span class="lineno">  934</span>&#160;        <span class="keywordflow">if</span> (Super::m_moduleMembers[current.index] &gt; 1 &amp;&amp; Super::m_emptyModules.size() &gt; 0 &amp;&amp;</div><div class="line"><a name="l00935"></a><span class="lineno">  935</span>&#160;                (m_config.preferredNumberOfModules == 0 || (Super::isTopLevel() &amp;&amp; Super::numActiveModules() != m_config.preferredNumberOfModules)))</div><div class="line"><a name="l00936"></a><span class="lineno">  936</span>&#160;        {</div><div class="line"><a name="l00937"></a><span class="lineno">  937</span>&#160;            emptyModuleIndex = Super::m_emptyModules.back();</div><div class="line"><a name="l00938"></a><span class="lineno">  938</span>&#160;            deltaFlow[emptyModuleIndex] += DeltaFlowType(emptyModuleIndex, 0.0, 0.0);</div><div class="line"><a name="l00939"></a><span class="lineno">  939</span>&#160;        }</div><div class="line"><a name="l00940"></a><span class="lineno">  940</span>&#160;</div><div class="line"><a name="l00941"></a><span class="lineno">  941</span>&#160;        <span class="comment">// Store the DeltaFlow of the current module</span></div><div class="line"><a name="l00942"></a><span class="lineno">  942</span>&#160;        DeltaFlowType oldModuleDelta(deltaFlow[current.index]);</div><div class="line"><a name="l00943"></a><span class="lineno">  943</span>&#160;</div><div class="line"><a name="l00944"></a><span class="lineno">  944</span>&#160;        <span class="comment">// For memory networks</span></div><div class="line"><a name="l00945"></a><span class="lineno">  945</span>&#160;        derived().addContributionOfMovingMemoryNodes(current, oldModuleDelta, deltaFlow);</div><div class="line"><a name="l00946"></a><span class="lineno">  946</span>&#160;</div><div class="line"><a name="l00947"></a><span class="lineno">  947</span>&#160;</div><div class="line"><a name="l00948"></a><span class="lineno">  948</span>&#160;        std::vector&lt;DeltaFlowType&gt; moduleDeltaEnterExit(deltaFlow.size());</div><div class="line"><a name="l00949"></a><span class="lineno">  949</span>&#160;        <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> numModuleLinks = 0;</div><div class="line"><a name="l00950"></a><span class="lineno">  950</span>&#160;        <span class="keywordflow">for</span> (<span class="keyword">typename</span> std::map&lt;unsigned int, DeltaFlowType&gt;::iterator it(deltaFlow.begin()); it != deltaFlow.end(); ++it)</div><div class="line"><a name="l00951"></a><span class="lineno">  951</span>&#160;        {</div><div class="line"><a name="l00952"></a><span class="lineno">  952</span>&#160;            moduleDeltaEnterExit[numModuleLinks] = it-&gt;second;</div><div class="line"><a name="l00953"></a><span class="lineno">  953</span>&#160;            ++numModuleLinks;</div><div class="line"><a name="l00954"></a><span class="lineno">  954</span>&#160;        }</div><div class="line"><a name="l00955"></a><span class="lineno">  955</span>&#160;</div><div class="line"><a name="l00956"></a><span class="lineno">  956</span>&#160;        <span class="comment">// Randomize link order for optimized search</span></div><div class="line"><a name="l00957"></a><span class="lineno">  957</span>&#160;        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; numModuleLinks - 1; ++j)</div><div class="line"><a name="l00958"></a><span class="lineno">  958</span>&#160;        {</div><div class="line"><a name="l00959"></a><span class="lineno">  959</span>&#160;            <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> randPos = j + Super::m_rand.randInt(numModuleLinks - j - 1);</div><div class="line"><a name="l00960"></a><span class="lineno">  960</span>&#160;            swap(moduleDeltaEnterExit[j], moduleDeltaEnterExit[randPos]);</div><div class="line"><a name="l00961"></a><span class="lineno">  961</span>&#160;        }</div><div class="line"><a name="l00962"></a><span class="lineno">  962</span>&#160;</div><div class="line"><a name="l00963"></a><span class="lineno">  963</span>&#160;        DeltaFlowType bestDeltaModule(oldModuleDelta);</div><div class="line"><a name="l00964"></a><span class="lineno">  964</span>&#160;        <span class="keywordtype">double</span> bestDeltaCodelength = 0.0;</div><div class="line"><a name="l00965"></a><span class="lineno">  965</span>&#160;        DeltaFlowType strongestConnectedModule(oldModuleDelta);</div><div class="line"><a name="l00966"></a><span class="lineno">  966</span>&#160;        <span class="keywordtype">double</span> deltaCodelengthOnStrongestConnectedModule = 0.0;</div><div class="line"><a name="l00967"></a><span class="lineno">  967</span>&#160;</div><div class="line"><a name="l00968"></a><span class="lineno">  968</span>&#160;        <span class="comment">// Find the move that minimizes the description length</span></div><div class="line"><a name="l00969"></a><span class="lineno">  969</span>&#160;        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; numModuleLinks; ++j)</div><div class="line"><a name="l00970"></a><span class="lineno">  970</span>&#160;        {</div><div class="line"><a name="l00971"></a><span class="lineno">  971</span>&#160;            <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> otherModule = moduleDeltaEnterExit[j].module;</div><div class="line"><a name="l00972"></a><span class="lineno">  972</span>&#160;            <span class="keywordflow">if</span>(otherModule != current.index)</div><div class="line"><a name="l00973"></a><span class="lineno">  973</span>&#160;            {</div><div class="line"><a name="l00974"></a><span class="lineno">  974</span>&#160;                <span class="keywordtype">double</span> deltaCodelength = Super::getDeltaCodelengthOnMovingNode(current, oldModuleDelta, moduleDeltaEnterExit[j]);</div><div class="line"><a name="l00975"></a><span class="lineno">  975</span>&#160;                deltaCodelength += derived().getDeltaCodelengthOnMovingMemoryNode(oldModuleDelta, moduleDeltaEnterExit[j]);</div><div class="line"><a name="l00976"></a><span class="lineno">  976</span>&#160;</div><div class="line"><a name="l00977"></a><span class="lineno">  977</span>&#160;                <span class="keywordflow">if</span> (deltaCodelength &lt; bestDeltaCodelength - Super::m_config.minimumSingleNodeCodelengthImprovement)</div><div class="line"><a name="l00978"></a><span class="lineno">  978</span>&#160;                {</div><div class="line"><a name="l00979"></a><span class="lineno">  979</span>&#160;                    bestDeltaModule = moduleDeltaEnterExit[j];</div><div class="line"><a name="l00980"></a><span class="lineno">  980</span>&#160;                    bestDeltaCodelength = deltaCodelength;</div><div class="line"><a name="l00981"></a><span class="lineno">  981</span>&#160;                }</div><div class="line"><a name="l00982"></a><span class="lineno">  982</span>&#160;</div><div class="line"><a name="l00983"></a><span class="lineno">  983</span>&#160;                <span class="comment">// Save strongest connected module to prefer if codelength improvement equal</span></div><div class="line"><a name="l00984"></a><span class="lineno">  984</span>&#160;                <span class="keywordflow">if</span> (moduleDeltaEnterExit[j].deltaExit &gt; strongestConnectedModule.deltaExit)</div><div class="line"><a name="l00985"></a><span class="lineno">  985</span>&#160;                {</div><div class="line"><a name="l00986"></a><span class="lineno">  986</span>&#160;                    strongestConnectedModule = moduleDeltaEnterExit[j];</div><div class="line"><a name="l00987"></a><span class="lineno">  987</span>&#160;                    deltaCodelengthOnStrongestConnectedModule = deltaCodelength;</div><div class="line"><a name="l00988"></a><span class="lineno">  988</span>&#160;                }</div><div class="line"><a name="l00989"></a><span class="lineno">  989</span>&#160;            }</div><div class="line"><a name="l00990"></a><span class="lineno">  990</span>&#160;        }</div><div class="line"><a name="l00991"></a><span class="lineno">  991</span>&#160;</div><div class="line"><a name="l00992"></a><span class="lineno">  992</span>&#160;        <span class="comment">// Prefer strongest connected module if equal delta codelength</span></div><div class="line"><a name="l00993"></a><span class="lineno">  993</span>&#160;        <span class="keywordflow">if</span> (strongestConnectedModule.module != bestDeltaModule.module &amp;&amp;</div><div class="line"><a name="l00994"></a><span class="lineno">  994</span>&#160;                deltaCodelengthOnStrongestConnectedModule &lt;= bestDeltaCodelength)<span class="comment">// + Super::m_config.minimumCodelengthImprovement)</span></div><div class="line"><a name="l00995"></a><span class="lineno">  995</span>&#160;        {</div><div class="line"><a name="l00996"></a><span class="lineno">  996</span>&#160;            bestDeltaModule = strongestConnectedModule;</div><div class="line"><a name="l00997"></a><span class="lineno">  997</span>&#160;        }</div><div class="line"><a name="l00998"></a><span class="lineno">  998</span>&#160;</div><div class="line"><a name="l00999"></a><span class="lineno">  999</span>&#160;        <span class="comment">// Make best possible move</span></div><div class="line"><a name="l01000"></a><span class="lineno"> 1000</span>&#160;        <span class="keywordflow">if</span>(bestDeltaModule.module == current.index)</div><div class="line"><a name="l01001"></a><span class="lineno"> 1001</span>&#160;        {</div><div class="line"><a name="l01002"></a><span class="lineno"> 1002</span>&#160;            current.dirty = <span class="keyword">false</span>;</div><div class="line"><a name="l01003"></a><span class="lineno"> 1003</span>&#160;            <span class="keywordflow">continue</span>;</div><div class="line"><a name="l01004"></a><span class="lineno"> 1004</span>&#160;        }</div><div class="line"><a name="l01005"></a><span class="lineno"> 1005</span>&#160;        <span class="keywordflow">else</span></div><div class="line"><a name="l01006"></a><span class="lineno"> 1006</span>&#160;        {</div><div class="line"><a name="l01007"></a><span class="lineno"> 1007</span>&#160;<span class="preprocessor">#pragma omp critical (moveUpdate)</span></div><div class="line"><a name="l01008"></a><span class="lineno"> 1008</span>&#160;            {</div><div class="line"><a name="l01009"></a><span class="lineno"> 1009</span>&#160;                <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> bestModuleIndex = bestDeltaModule.module;</div><div class="line"><a name="l01010"></a><span class="lineno"> 1010</span>&#160;                <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> oldModuleIndex = current.index;</div><div class="line"><a name="l01011"></a><span class="lineno"> 1011</span>&#160;</div><div class="line"><a name="l01012"></a><span class="lineno"> 1012</span>&#160;                <span class="keywordtype">bool</span> validMove = <span class="keyword">true</span>;</div><div class="line"><a name="l01013"></a><span class="lineno"> 1013</span>&#160;                <span class="keywordflow">if</span> (bestModuleIndex == emptyModuleIndex)    {</div><div class="line"><a name="l01014"></a><span class="lineno"> 1014</span>&#160;                    <span class="comment">// Check validity of move to empty target</span></div><div class="line"><a name="l01015"></a><span class="lineno"> 1015</span>&#160;                    validMove = Super::m_moduleMembers[current.index] &gt; 1 &amp;&amp; Super::m_emptyModules.size() &gt; 0;</div><div class="line"><a name="l01016"></a><span class="lineno"> 1016</span>&#160;                }</div><div class="line"><a name="l01017"></a><span class="lineno"> 1017</span>&#160;                <span class="keywordflow">else</span></div><div class="line"><a name="l01018"></a><span class="lineno"> 1018</span>&#160;                {</div><div class="line"><a name="l01019"></a><span class="lineno"> 1019</span>&#160;                    <span class="comment">// Not valid if the best module is empty now but not when decided</span></div><div class="line"><a name="l01020"></a><span class="lineno"> 1020</span>&#160;                    validMove = Super::m_moduleMembers[bestModuleIndex] &gt; 0;</div><div class="line"><a name="l01021"></a><span class="lineno"> 1021</span>&#160;                }</div><div class="line"><a name="l01022"></a><span class="lineno"> 1022</span>&#160;</div><div class="line"><a name="l01023"></a><span class="lineno"> 1023</span>&#160;                <span class="keywordflow">if</span> (validMove)</div><div class="line"><a name="l01024"></a><span class="lineno"> 1024</span>&#160;                {</div><div class="line"><a name="l01025"></a><span class="lineno"> 1025</span>&#160;</div><div class="line"><a name="l01026"></a><span class="lineno"> 1026</span>&#160;                    <span class="comment">// Recalculate delta codelength for proposed move to see if still an improvement</span></div><div class="line"><a name="l01027"></a><span class="lineno"> 1027</span>&#160;                    DeltaFlowType oldModuleDelta(oldModuleIndex, 0.0, 0.0, 0.0, 0.0);</div><div class="line"><a name="l01028"></a><span class="lineno"> 1028</span>&#160;                    DeltaFlowType newModuleDelta(bestModuleIndex, 0.0, 0.0, 0.0, 0.0);</div><div class="line"><a name="l01029"></a><span class="lineno"> 1029</span>&#160;</div><div class="line"><a name="l01030"></a><span class="lineno"> 1030</span>&#160;                    Super::addTeleportationDeltaFlowOnOldModuleIfMove(current, oldModuleDelta);</div><div class="line"><a name="l01031"></a><span class="lineno"> 1031</span>&#160;                    Super::addTeleportationDeltaFlowOnNewModuleIfMove(current, newModuleDelta);</div><div class="line"><a name="l01032"></a><span class="lineno"> 1032</span>&#160;</div><div class="line"><a name="l01033"></a><span class="lineno"> 1033</span>&#160;                    <span class="comment">// For all outlinks</span></div><div class="line"><a name="l01034"></a><span class="lineno"> 1034</span>&#160;                    <span class="keywordflow">for</span> (NodeBase::edge_iterator edgeIt(current.begin_outEdge()), endIt(current.end_outEdge());</div><div class="line"><a name="l01035"></a><span class="lineno"> 1035</span>&#160;                            edgeIt != endIt; ++edgeIt)</div><div class="line"><a name="l01036"></a><span class="lineno"> 1036</span>&#160;                    {</div><div class="line"><a name="l01037"></a><span class="lineno"> 1037</span>&#160;                        EdgeType&amp; edge = **edgeIt;</div><div class="line"><a name="l01038"></a><span class="lineno"> 1038</span>&#160;                        <span class="keywordflow">if</span> (edge.isSelfPointing())</div><div class="line"><a name="l01039"></a><span class="lineno"> 1039</span>&#160;                            <span class="keywordflow">continue</span>;</div><div class="line"><a name="l01040"></a><span class="lineno"> 1040</span>&#160;                        <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> otherModule = edge.target.index;</div><div class="line"><a name="l01041"></a><span class="lineno"> 1041</span>&#160;                        <span class="keywordflow">if</span> (otherModule == oldModuleIndex)</div><div class="line"><a name="l01042"></a><span class="lineno"> 1042</span>&#160;                            oldModuleDelta.deltaExit += edge.data.flow;</div><div class="line"><a name="l01043"></a><span class="lineno"> 1043</span>&#160;                        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (otherModule == bestModuleIndex)</div><div class="line"><a name="l01044"></a><span class="lineno"> 1044</span>&#160;                            newModuleDelta.deltaExit += edge.data.flow;</div><div class="line"><a name="l01045"></a><span class="lineno"> 1045</span>&#160;                    }</div><div class="line"><a name="l01046"></a><span class="lineno"> 1046</span>&#160;</div><div class="line"><a name="l01047"></a><span class="lineno"> 1047</span>&#160;                    <span class="comment">// For all inlinks</span></div><div class="line"><a name="l01048"></a><span class="lineno"> 1048</span>&#160;                    <span class="keywordflow">for</span> (NodeBase::edge_iterator edgeIt(current.begin_inEdge()), endIt(current.end_inEdge());</div><div class="line"><a name="l01049"></a><span class="lineno"> 1049</span>&#160;                            edgeIt != endIt; ++edgeIt)</div><div class="line"><a name="l01050"></a><span class="lineno"> 1050</span>&#160;                    {</div><div class="line"><a name="l01051"></a><span class="lineno"> 1051</span>&#160;                        EdgeType&amp; edge = **edgeIt;</div><div class="line"><a name="l01052"></a><span class="lineno"> 1052</span>&#160;                        <span class="keywordflow">if</span> (edge.isSelfPointing())</div><div class="line"><a name="l01053"></a><span class="lineno"> 1053</span>&#160;                            <span class="keywordflow">continue</span>;</div><div class="line"><a name="l01054"></a><span class="lineno"> 1054</span>&#160;                        <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> otherModule = edge.source.index;</div><div class="line"><a name="l01055"></a><span class="lineno"> 1055</span>&#160;                        <span class="keywordflow">if</span> (otherModule == oldModuleIndex)</div><div class="line"><a name="l01056"></a><span class="lineno"> 1056</span>&#160;                            oldModuleDelta.deltaEnter += edge.data.flow;</div><div class="line"><a name="l01057"></a><span class="lineno"> 1057</span>&#160;                        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (otherModule == bestModuleIndex)</div><div class="line"><a name="l01058"></a><span class="lineno"> 1058</span>&#160;                            newModuleDelta.deltaEnter += edge.data.flow;</div><div class="line"><a name="l01059"></a><span class="lineno"> 1059</span>&#160;                    }</div><div class="line"><a name="l01060"></a><span class="lineno"> 1060</span>&#160;</div><div class="line"><a name="l01061"></a><span class="lineno"> 1061</span>&#160;</div><div class="line"><a name="l01062"></a><span class="lineno"> 1062</span>&#160;                    <span class="keywordtype">double</span> deltaCodelength = Super::getDeltaCodelengthOnMovingNode(current, oldModuleDelta, newModuleDelta);</div><div class="line"><a name="l01063"></a><span class="lineno"> 1063</span>&#160;                    deltaCodelength += derived().getDeltaCodelengthOnMovingMemoryNode(oldModuleDelta, newModuleDelta);</div><div class="line"><a name="l01064"></a><span class="lineno"> 1064</span>&#160;</div><div class="line"><a name="l01065"></a><span class="lineno"> 1065</span>&#160;                    <span class="keywordflow">if</span> (deltaCodelength &lt;= 0.0 - Super::m_config.minimumSingleNodeCodelengthImprovement)</div><div class="line"><a name="l01066"></a><span class="lineno"> 1066</span>&#160;                    {</div><div class="line"><a name="l01067"></a><span class="lineno"> 1067</span>&#160;                        <span class="comment">//Update empty module vector</span></div><div class="line"><a name="l01068"></a><span class="lineno"> 1068</span>&#160;                        <span class="keywordflow">if</span>(Super::m_moduleMembers[bestModuleIndex] == 0)</div><div class="line"><a name="l01069"></a><span class="lineno"> 1069</span>&#160;                        {</div><div class="line"><a name="l01070"></a><span class="lineno"> 1070</span>&#160;                            Super::m_emptyModules.pop_back();</div><div class="line"><a name="l01071"></a><span class="lineno"> 1071</span>&#160;                        }</div><div class="line"><a name="l01072"></a><span class="lineno"> 1072</span>&#160;                        <span class="keywordflow">if</span>(Super::m_moduleMembers[oldModuleIndex] == 1)</div><div class="line"><a name="l01073"></a><span class="lineno"> 1073</span>&#160;                        {</div><div class="line"><a name="l01074"></a><span class="lineno"> 1074</span>&#160;                            Super::m_emptyModules.push_back(oldModuleIndex);</div><div class="line"><a name="l01075"></a><span class="lineno"> 1075</span>&#160;                        }</div><div class="line"><a name="l01076"></a><span class="lineno"> 1076</span>&#160;</div><div class="line"><a name="l01077"></a><span class="lineno"> 1077</span>&#160;                        <a class="code" href="classInfomapGreedySpecialized.html#a6f4ff75d89a26f1b474ca5a2190878c7">Super::updateCodelengthOnMovingNode</a>(current, oldModuleDelta, newModuleDelta);</div><div class="line"><a name="l01078"></a><span class="lineno"> 1078</span>&#160;                        derived().updateCodelengthOnMovingMemoryNode(oldModuleDelta, newModuleDelta);</div><div class="line"><a name="l01079"></a><span class="lineno"> 1079</span>&#160;</div><div class="line"><a name="l01080"></a><span class="lineno"> 1080</span>&#160;                        <span class="comment">// Update physical node map on move for memory networks</span></div><div class="line"><a name="l01081"></a><span class="lineno"> 1081</span>&#160;                        derived().performMoveOfMemoryNode(current, oldModuleIndex, bestModuleIndex);</div><div class="line"><a name="l01082"></a><span class="lineno"> 1082</span>&#160;</div><div class="line"><a name="l01083"></a><span class="lineno"> 1083</span>&#160;                        <span class="comment">// Mark neighbours as dirty</span></div><div class="line"><a name="l01084"></a><span class="lineno"> 1084</span>&#160;                        <span class="keywordflow">for</span> (NodeBase::edge_iterator edgeIt(current.begin_outEdge()), endIt(current.end_outEdge());</div><div class="line"><a name="l01085"></a><span class="lineno"> 1085</span>&#160;                                edgeIt != endIt; ++edgeIt)</div><div class="line"><a name="l01086"></a><span class="lineno"> 1086</span>&#160;                            (*edgeIt)-&gt;target.dirty = <span class="keyword">true</span>;</div><div class="line"><a name="l01087"></a><span class="lineno"> 1087</span>&#160;                        for (NodeBase::edge_iterator edgeIt(current.begin_inEdge()), endIt(current.end_inEdge());</div><div class="line"><a name="l01088"></a><span class="lineno"> 1088</span>&#160;                                edgeIt != endIt; ++edgeIt)</div><div class="line"><a name="l01089"></a><span class="lineno"> 1089</span>&#160;                            (*edgeIt)-&gt;source.dirty = <span class="keyword">true</span>;</div><div class="line"><a name="l01090"></a><span class="lineno"> 1090</span>&#160;</div><div class="line"><a name="l01091"></a><span class="lineno"> 1091</span>&#160;                        Super::m_moduleMembers[oldModuleIndex] -= 1;</div><div class="line"><a name="l01092"></a><span class="lineno"> 1092</span>&#160;                        Super::m_moduleMembers[bestModuleIndex] += 1;</div><div class="line"><a name="l01093"></a><span class="lineno"> 1093</span>&#160;</div><div class="line"><a name="l01094"></a><span class="lineno"> 1094</span>&#160;                        current.index = bestModuleIndex;</div><div class="line"><a name="l01095"></a><span class="lineno"> 1095</span>&#160;                        ++numMoved;</div><div class="line"><a name="l01096"></a><span class="lineno"> 1096</span>&#160;                        diffSerialParallelCodelength += bestDeltaCodelength - deltaCodelength;</div><div class="line"><a name="l01097"></a><span class="lineno"> 1097</span>&#160;                    }</div><div class="line"><a name="l01098"></a><span class="lineno"> 1098</span>&#160;                    <span class="keywordflow">else</span></div><div class="line"><a name="l01099"></a><span class="lineno"> 1099</span>&#160;                    {</div><div class="line"><a name="l01100"></a><span class="lineno"> 1100</span>&#160;                        ++numInvalidMoves;</div><div class="line"><a name="l01101"></a><span class="lineno"> 1101</span>&#160;                    }</div><div class="line"><a name="l01102"></a><span class="lineno"> 1102</span>&#160;                }</div><div class="line"><a name="l01103"></a><span class="lineno"> 1103</span>&#160;                <span class="keywordflow">else</span></div><div class="line"><a name="l01104"></a><span class="lineno"> 1104</span>&#160;                {</div><div class="line"><a name="l01105"></a><span class="lineno"> 1105</span>&#160;                    ++numInvalidMoves;</div><div class="line"><a name="l01106"></a><span class="lineno"> 1106</span>&#160;                }</div><div class="line"><a name="l01107"></a><span class="lineno"> 1107</span>&#160;            }</div><div class="line"><a name="l01108"></a><span class="lineno"> 1108</span>&#160;        }</div><div class="line"><a name="l01109"></a><span class="lineno"> 1109</span>&#160;</div><div class="line"><a name="l01110"></a><span class="lineno"> 1110</span>&#160;    }</div><div class="line"><a name="l01111"></a><span class="lineno"> 1111</span>&#160;</div><div class="line"><a name="l01112"></a><span class="lineno"> 1112</span>&#160;<span class="comment">//  Log() &lt;&lt; &quot;\n(#invalidMoves: &quot; &lt;&lt; numInvalidMoves &lt;&lt;</span></div><div class="line"><a name="l01113"></a><span class="lineno"> 1113</span>&#160;<span class="comment">//          &quot;, diffSerialParallelCodelength: &quot; &lt;&lt; diffSerialParallelCodelength &lt;&lt; &quot;) &quot;;</span></div><div class="line"><a name="l01114"></a><span class="lineno"> 1114</span>&#160;</div><div class="line"><a name="l01115"></a><span class="lineno"> 1115</span>&#160;<span class="comment">//  return numMoved;</span></div><div class="line"><a name="l01116"></a><span class="lineno"> 1116</span>&#160;    <span class="keywordflow">return</span> numMoved + numInvalidMoves;</div><div class="line"><a name="l01117"></a><span class="lineno"> 1117</span>&#160;}</div><div class="ttc" id="classInfomapGreedyCommon_html_a25af363aae49138b379a823b6ab2ad5c"><div class="ttname"><a href="classInfomapGreedyCommon.html#a25af363aae49138b379a823b6ab2ad5c">InfomapGreedyCommon::tryMoveEachNodeIntoBestModule</a></div><div class="ttdeci">unsigned int tryMoveEachNodeIntoBestModule()</div><div class="ttdef"><b>Definition:</b> InfomapGreedyCommon.h:426</div></div>
<div class="ttc" id="classInfomapGreedySpecialized_html_a6f4ff75d89a26f1b474ca5a2190878c7"><div class="ttname"><a href="classInfomapGreedySpecialized.html#a6f4ff75d89a26f1b474ca5a2190878c7">InfomapGreedySpecialized::updateCodelengthOnMovingNode</a></div><div class="ttdeci">void updateCodelengthOnMovingNode(NodeType &amp;current, DeltaFlow &amp;oldModuleDelta, DeltaFlow &amp;newModuleDelta)</div><div class="ttdef"><b>Definition:</b> InfomapGreedySpecialized.h:322</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a5d0eb8fd059c6d308c53f8c4ed8f10f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d0eb8fd059c6d308c53f8c4ed8f10f9">&#9670;&nbsp;</a></span>tryMoveEachNodeIntoBestModuleParallelizable()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InfomapGreedyDerivedType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="classInfomapGreedyCommon.html">InfomapGreedyCommon</a>&lt; InfomapGreedyDerivedType &gt;::tryMoveEachNodeIntoBestModuleParallelizable </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Minimize the codelength by trying to move each node into best module.</p>
<p>For each node:</p><ol type="1">
<li>Calculate the change in codelength for a move to each of its neighbouring modules or to an empty module</li>
<li>Move to the one that reduces the codelength the most, if any.</li>
</ol>
<dl class="section return"><dt>Returns</dt><dd>The number of nodes moved. </dd></dl>
<div class="fragment"><div class="line"><a name="l00661"></a><span class="lineno">  661</span>&#160;{</div><div class="line"><a name="l00662"></a><span class="lineno">  662</span>&#160;    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> numNodes = Super::m_activeNetwork.size();</div><div class="line"><a name="l00663"></a><span class="lineno">  663</span>&#160;    <span class="comment">// Get random enumeration of nodes</span></div><div class="line"><a name="l00664"></a><span class="lineno">  664</span>&#160;    std::vector&lt;unsigned int&gt; randomOrder(numNodes);</div><div class="line"><a name="l00665"></a><span class="lineno">  665</span>&#160;    infomath::getRandomizedIndexVector(randomOrder, Super::m_rand);</div><div class="line"><a name="l00666"></a><span class="lineno">  666</span>&#160;</div><div class="line"><a name="l00667"></a><span class="lineno">  667</span>&#160;    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> numMoved = 0;</div><div class="line"><a name="l00668"></a><span class="lineno">  668</span>&#160;    <span class="keywordtype">int</span> numNodesInt = <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(numNodes);</div><div class="line"><a name="l00669"></a><span class="lineno">  669</span>&#160;</div><div class="line"><a name="l00670"></a><span class="lineno">  670</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; numNodesInt; ++i)</div><div class="line"><a name="l00671"></a><span class="lineno">  671</span>&#160;    {</div><div class="line"><a name="l00672"></a><span class="lineno">  672</span>&#160;        <span class="comment">// Pick nodes in random order</span></div><div class="line"><a name="l00673"></a><span class="lineno">  673</span>&#160;        <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> flip = randomOrder[i];</div><div class="line"><a name="l00674"></a><span class="lineno">  674</span>&#160;        NodeType&amp; current = getNode(*Super::m_activeNetwork[flip]);</div><div class="line"><a name="l00675"></a><span class="lineno">  675</span>&#160;</div><div class="line"><a name="l00676"></a><span class="lineno">  676</span>&#160;        <span class="keywordflow">if</span> (!current.dirty)</div><div class="line"><a name="l00677"></a><span class="lineno">  677</span>&#160;            <span class="keywordflow">continue</span>;</div><div class="line"><a name="l00678"></a><span class="lineno">  678</span>&#160;</div><div class="line"><a name="l00679"></a><span class="lineno">  679</span>&#160;        <span class="keywordflow">if</span> (Super::m_moduleMembers[current.index] &gt; 1 &amp;&amp; Super::isFirstLoop() &amp;&amp; m_config.tuneIterationLimit != 1)</div><div class="line"><a name="l00680"></a><span class="lineno">  680</span>&#160;            <span class="keywordflow">continue</span>;</div><div class="line"><a name="l00681"></a><span class="lineno">  681</span>&#160;</div><div class="line"><a name="l00682"></a><span class="lineno">  682</span>&#160;        <span class="comment">// If no links connecting this node with other nodes, it won&#39;t move into others,</span></div><div class="line"><a name="l00683"></a><span class="lineno">  683</span>&#160;        <span class="comment">// and others won&#39;t move into this. TODO: Always best leave it alone?</span></div><div class="line"><a name="l00684"></a><span class="lineno">  684</span>&#160;<span class="comment">//      if (current.degree() == 0)</span></div><div class="line"><a name="l00685"></a><span class="lineno">  685</span>&#160;        <span class="keywordflow">if</span> (current.degree() == 0 ||</div><div class="line"><a name="l00686"></a><span class="lineno">  686</span>&#160;            (Super::m_config.includeSelfLinks &amp;&amp;</div><div class="line"><a name="l00687"></a><span class="lineno">  687</span>&#160;            (current.outDegree() == 1 &amp;&amp; current.inDegree() == 1) &amp;&amp;</div><div class="line"><a name="l00688"></a><span class="lineno">  688</span>&#160;            (**current.begin_outEdge()).target == current))</div><div class="line"><a name="l00689"></a><span class="lineno">  689</span>&#160;        {</div><div class="line"><a name="l00690"></a><span class="lineno">  690</span>&#160;            DEBUG_OUT(<span class="stringliteral">&quot;SKIPPING isolated node &quot;</span> &lt;&lt; current &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>);</div><div class="line"><a name="l00691"></a><span class="lineno">  691</span>&#160;            <span class="comment">//TODO: If not skipping self-links, this yields different results from moveNodesToPredefinedModules!!</span></div><div class="line"><a name="l00692"></a><span class="lineno">  692</span>&#160;            ASSERT(!m_config.includeSelfLinks);</div><div class="line"><a name="l00693"></a><span class="lineno">  693</span>&#160;            current.dirty = <span class="keyword">false</span>;</div><div class="line"><a name="l00694"></a><span class="lineno">  694</span>&#160;            <span class="keywordflow">continue</span>;</div><div class="line"><a name="l00695"></a><span class="lineno">  695</span>&#160;        }</div><div class="line"><a name="l00696"></a><span class="lineno">  696</span>&#160;</div><div class="line"><a name="l00697"></a><span class="lineno">  697</span>&#160;        <span class="comment">// Create map with module links</span></div><div class="line"><a name="l00698"></a><span class="lineno">  698</span>&#160;        std::map&lt;unsigned int, DeltaFlowType&gt; deltaFlow;</div><div class="line"><a name="l00699"></a><span class="lineno">  699</span>&#160;</div><div class="line"><a name="l00700"></a><span class="lineno">  700</span>&#160;        <span class="comment">// If alone in the module, add virtual link to the module (used when adding teleportation)</span></div><div class="line"><a name="l00701"></a><span class="lineno">  701</span>&#160;        deltaFlow[current.index] += DeltaFlowType(current.index, 0.0, 0.0);</div><div class="line"><a name="l00702"></a><span class="lineno">  702</span>&#160;</div><div class="line"><a name="l00703"></a><span class="lineno">  703</span>&#160;        <span class="comment">// For all outlinks</span></div><div class="line"><a name="l00704"></a><span class="lineno">  704</span>&#160;        <span class="keywordflow">for</span> (NodeBase::edge_iterator edgeIt(current.begin_outEdge()), endIt(current.end_outEdge());</div><div class="line"><a name="l00705"></a><span class="lineno">  705</span>&#160;                edgeIt != endIt; ++edgeIt)</div><div class="line"><a name="l00706"></a><span class="lineno">  706</span>&#160;        {</div><div class="line"><a name="l00707"></a><span class="lineno">  707</span>&#160;            EdgeType&amp; edge = **edgeIt;</div><div class="line"><a name="l00708"></a><span class="lineno">  708</span>&#160;            <span class="keywordflow">if</span> (edge.isSelfPointing())</div><div class="line"><a name="l00709"></a><span class="lineno">  709</span>&#160;                <span class="keywordflow">continue</span>;</div><div class="line"><a name="l00710"></a><span class="lineno">  710</span>&#160;            NodeType&amp; neighbour = getNode(edge.target);</div><div class="line"><a name="l00711"></a><span class="lineno">  711</span>&#160;</div><div class="line"><a name="l00712"></a><span class="lineno">  712</span>&#160;            deltaFlow[neighbour.index] += DeltaFlowType(neighbour.index, edge.data.flow, 0.0);</div><div class="line"><a name="l00713"></a><span class="lineno">  713</span>&#160;        }</div><div class="line"><a name="l00714"></a><span class="lineno">  714</span>&#160;        <span class="comment">// For all inlinks</span></div><div class="line"><a name="l00715"></a><span class="lineno">  715</span>&#160;        <span class="keywordflow">for</span> (NodeBase::edge_iterator edgeIt(current.begin_inEdge()), endIt(current.end_inEdge());</div><div class="line"><a name="l00716"></a><span class="lineno">  716</span>&#160;                edgeIt != endIt; ++edgeIt)</div><div class="line"><a name="l00717"></a><span class="lineno">  717</span>&#160;        {</div><div class="line"><a name="l00718"></a><span class="lineno">  718</span>&#160;            EdgeType&amp; edge = **edgeIt;</div><div class="line"><a name="l00719"></a><span class="lineno">  719</span>&#160;            <span class="keywordflow">if</span> (edge.isSelfPointing())</div><div class="line"><a name="l00720"></a><span class="lineno">  720</span>&#160;                <span class="keywordflow">continue</span>;</div><div class="line"><a name="l00721"></a><span class="lineno">  721</span>&#160;            NodeType&amp; neighbour = getNode(edge.source);</div><div class="line"><a name="l00722"></a><span class="lineno">  722</span>&#160;</div><div class="line"><a name="l00723"></a><span class="lineno">  723</span>&#160;            deltaFlow[neighbour.index] += DeltaFlowType(neighbour.index, 0.0, edge.data.flow);</div><div class="line"><a name="l00724"></a><span class="lineno">  724</span>&#160;        }</div><div class="line"><a name="l00725"></a><span class="lineno">  725</span>&#160;</div><div class="line"><a name="l00726"></a><span class="lineno">  726</span>&#160;</div><div class="line"><a name="l00727"></a><span class="lineno">  727</span>&#160;        <span class="comment">// Empty function if no teleportation coding model</span></div><div class="line"><a name="l00728"></a><span class="lineno">  728</span>&#160;        Super::template addTeleportationDeltaFlowIfMove&lt;DeltaFlowType&gt;(current, deltaFlow);</div><div class="line"><a name="l00729"></a><span class="lineno">  729</span>&#160;</div><div class="line"><a name="l00730"></a><span class="lineno">  730</span>&#160;        <span class="comment">// Option to move to empty module (if node not already alone)</span></div><div class="line"><a name="l00731"></a><span class="lineno">  731</span>&#160;        <span class="keywordflow">if</span> (Super::m_moduleMembers[current.index] &gt; 1 &amp;&amp; Super::m_emptyModules.size() &gt; 0)</div><div class="line"><a name="l00732"></a><span class="lineno">  732</span>&#160;            deltaFlow[Super::m_emptyModules.back()] += DeltaFlowType(Super::m_emptyModules.back(), 0.0, 0.0);</div><div class="line"><a name="l00733"></a><span class="lineno">  733</span>&#160;</div><div class="line"><a name="l00734"></a><span class="lineno">  734</span>&#160;        <span class="comment">// Store the DeltaFlow of the current module</span></div><div class="line"><a name="l00735"></a><span class="lineno">  735</span>&#160;        DeltaFlowType oldModuleDelta(deltaFlow[current.index]);</div><div class="line"><a name="l00736"></a><span class="lineno">  736</span>&#160;</div><div class="line"><a name="l00737"></a><span class="lineno">  737</span>&#160;        <span class="comment">// For memory networks</span></div><div class="line"><a name="l00738"></a><span class="lineno">  738</span>&#160;        derived().addContributionOfMovingMemoryNodes(current, oldModuleDelta, deltaFlow);</div><div class="line"><a name="l00739"></a><span class="lineno">  739</span>&#160;</div><div class="line"><a name="l00740"></a><span class="lineno">  740</span>&#160;</div><div class="line"><a name="l00741"></a><span class="lineno">  741</span>&#160;        std::vector&lt;DeltaFlowType&gt; moduleDeltaEnterExit(deltaFlow.size());</div><div class="line"><a name="l00742"></a><span class="lineno">  742</span>&#160;        <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> numModuleLinks = 0;</div><div class="line"><a name="l00743"></a><span class="lineno">  743</span>&#160;        <span class="keywordflow">for</span> (<span class="keyword">typename</span> std::map&lt;unsigned int, DeltaFlowType&gt;::iterator it(deltaFlow.begin()); it != deltaFlow.end(); ++it)</div><div class="line"><a name="l00744"></a><span class="lineno">  744</span>&#160;        {</div><div class="line"><a name="l00745"></a><span class="lineno">  745</span>&#160;            moduleDeltaEnterExit[numModuleLinks] = it-&gt;second;</div><div class="line"><a name="l00746"></a><span class="lineno">  746</span>&#160;            ++numModuleLinks;</div><div class="line"><a name="l00747"></a><span class="lineno">  747</span>&#160;        }</div><div class="line"><a name="l00748"></a><span class="lineno">  748</span>&#160;</div><div class="line"><a name="l00749"></a><span class="lineno">  749</span>&#160;        <span class="comment">// Randomize link order for optimized search</span></div><div class="line"><a name="l00750"></a><span class="lineno">  750</span>&#160;        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; numModuleLinks - 1; ++j)</div><div class="line"><a name="l00751"></a><span class="lineno">  751</span>&#160;        {</div><div class="line"><a name="l00752"></a><span class="lineno">  752</span>&#160;            <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> randPos = j + Super::m_rand.randInt(numModuleLinks - j - 1);</div><div class="line"><a name="l00753"></a><span class="lineno">  753</span>&#160;            swap(moduleDeltaEnterExit[j], moduleDeltaEnterExit[randPos]);</div><div class="line"><a name="l00754"></a><span class="lineno">  754</span>&#160;        }</div><div class="line"><a name="l00755"></a><span class="lineno">  755</span>&#160;</div><div class="line"><a name="l00756"></a><span class="lineno">  756</span>&#160;        DeltaFlowType bestDeltaModule(oldModuleDelta);</div><div class="line"><a name="l00757"></a><span class="lineno">  757</span>&#160;        <span class="keywordtype">double</span> bestDeltaCodelength = 0.0;</div><div class="line"><a name="l00758"></a><span class="lineno">  758</span>&#160;        DeltaFlowType strongestConnectedModule(oldModuleDelta);</div><div class="line"><a name="l00759"></a><span class="lineno">  759</span>&#160;        <span class="keywordtype">double</span> deltaCodelengthOnStrongestConnectedModule = 0.0;</div><div class="line"><a name="l00760"></a><span class="lineno">  760</span>&#160;</div><div class="line"><a name="l00761"></a><span class="lineno">  761</span>&#160;        <span class="comment">// Find the move that minimizes the description length</span></div><div class="line"><a name="l00762"></a><span class="lineno">  762</span>&#160;        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; numModuleLinks; ++j)</div><div class="line"><a name="l00763"></a><span class="lineno">  763</span>&#160;        {</div><div class="line"><a name="l00764"></a><span class="lineno">  764</span>&#160;            <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> otherModule = moduleDeltaEnterExit[j].module;</div><div class="line"><a name="l00765"></a><span class="lineno">  765</span>&#160;            <span class="keywordflow">if</span>(otherModule != current.index)</div><div class="line"><a name="l00766"></a><span class="lineno">  766</span>&#160;            {</div><div class="line"><a name="l00767"></a><span class="lineno">  767</span>&#160;                <span class="keywordtype">double</span> deltaCodelength = Super::getDeltaCodelengthOnMovingNode(current, oldModuleDelta, moduleDeltaEnterExit[j]);</div><div class="line"><a name="l00768"></a><span class="lineno">  768</span>&#160;                deltaCodelength += derived().getDeltaCodelengthOnMovingMemoryNode(oldModuleDelta, moduleDeltaEnterExit[j]);</div><div class="line"><a name="l00769"></a><span class="lineno">  769</span>&#160;</div><div class="line"><a name="l00770"></a><span class="lineno">  770</span>&#160;                <span class="keywordflow">if</span> (deltaCodelength &lt; bestDeltaCodelength - Super::m_config.minimumSingleNodeCodelengthImprovement)</div><div class="line"><a name="l00771"></a><span class="lineno">  771</span>&#160;                {</div><div class="line"><a name="l00772"></a><span class="lineno">  772</span>&#160;                    bestDeltaModule = moduleDeltaEnterExit[j];</div><div class="line"><a name="l00773"></a><span class="lineno">  773</span>&#160;                    bestDeltaCodelength = deltaCodelength;</div><div class="line"><a name="l00774"></a><span class="lineno">  774</span>&#160;                }</div><div class="line"><a name="l00775"></a><span class="lineno">  775</span>&#160;</div><div class="line"><a name="l00776"></a><span class="lineno">  776</span>&#160;                <span class="comment">// Save strongest connected module to prefer if codelength improvement equal</span></div><div class="line"><a name="l00777"></a><span class="lineno">  777</span>&#160;                <span class="keywordflow">if</span> (moduleDeltaEnterExit[j].deltaExit &gt; strongestConnectedModule.deltaExit)</div><div class="line"><a name="l00778"></a><span class="lineno">  778</span>&#160;                {</div><div class="line"><a name="l00779"></a><span class="lineno">  779</span>&#160;                    strongestConnectedModule = moduleDeltaEnterExit[j];</div><div class="line"><a name="l00780"></a><span class="lineno">  780</span>&#160;                    deltaCodelengthOnStrongestConnectedModule = deltaCodelength;</div><div class="line"><a name="l00781"></a><span class="lineno">  781</span>&#160;                }</div><div class="line"><a name="l00782"></a><span class="lineno">  782</span>&#160;            }</div><div class="line"><a name="l00783"></a><span class="lineno">  783</span>&#160;        }</div><div class="line"><a name="l00784"></a><span class="lineno">  784</span>&#160;</div><div class="line"><a name="l00785"></a><span class="lineno">  785</span>&#160;        <span class="comment">// Prefer strongest connected module if equal delta codelength</span></div><div class="line"><a name="l00786"></a><span class="lineno">  786</span>&#160;        <span class="keywordflow">if</span> (strongestConnectedModule.module != bestDeltaModule.module &amp;&amp;</div><div class="line"><a name="l00787"></a><span class="lineno">  787</span>&#160;                deltaCodelengthOnStrongestConnectedModule &lt;= bestDeltaCodelength + Super::m_config.minimumCodelengthImprovement)</div><div class="line"><a name="l00788"></a><span class="lineno">  788</span>&#160;        {</div><div class="line"><a name="l00789"></a><span class="lineno">  789</span>&#160;            bestDeltaModule = strongestConnectedModule;</div><div class="line"><a name="l00790"></a><span class="lineno">  790</span>&#160;        }</div><div class="line"><a name="l00791"></a><span class="lineno">  791</span>&#160;</div><div class="line"><a name="l00792"></a><span class="lineno">  792</span>&#160;        <span class="comment">// Make best possible move</span></div><div class="line"><a name="l00793"></a><span class="lineno">  793</span>&#160;        <span class="keywordflow">if</span>(bestDeltaModule.module != current.index)</div><div class="line"><a name="l00794"></a><span class="lineno">  794</span>&#160;        {</div><div class="line"><a name="l00795"></a><span class="lineno">  795</span>&#160;            <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> bestModuleIndex = bestDeltaModule.module;</div><div class="line"><a name="l00796"></a><span class="lineno">  796</span>&#160;            <span class="comment">//Update empty module vector</span></div><div class="line"><a name="l00797"></a><span class="lineno">  797</span>&#160;            <span class="keywordflow">if</span>(Super::m_moduleMembers[bestModuleIndex] == 0)</div><div class="line"><a name="l00798"></a><span class="lineno">  798</span>&#160;            {</div><div class="line"><a name="l00799"></a><span class="lineno">  799</span>&#160;                Super::m_emptyModules.pop_back();</div><div class="line"><a name="l00800"></a><span class="lineno">  800</span>&#160;            }</div><div class="line"><a name="l00801"></a><span class="lineno">  801</span>&#160;            <span class="keywordflow">if</span>(Super::m_moduleMembers[current.index] == 1)</div><div class="line"><a name="l00802"></a><span class="lineno">  802</span>&#160;            {</div><div class="line"><a name="l00803"></a><span class="lineno">  803</span>&#160;                Super::m_emptyModules.push_back(current.index);</div><div class="line"><a name="l00804"></a><span class="lineno">  804</span>&#160;            }</div><div class="line"><a name="l00805"></a><span class="lineno">  805</span>&#160;</div><div class="line"><a name="l00806"></a><span class="lineno">  806</span>&#160;            <a class="code" href="classInfomapGreedySpecialized.html#a6f4ff75d89a26f1b474ca5a2190878c7">Super::updateCodelengthOnMovingNode</a>(current, oldModuleDelta, bestDeltaModule);</div><div class="line"><a name="l00807"></a><span class="lineno">  807</span>&#160;            derived().updateCodelengthOnMovingMemoryNode(oldModuleDelta, bestDeltaModule);</div><div class="line"><a name="l00808"></a><span class="lineno">  808</span>&#160;</div><div class="line"><a name="l00809"></a><span class="lineno">  809</span>&#160;            Super::m_moduleMembers[current.index] -= 1;</div><div class="line"><a name="l00810"></a><span class="lineno">  810</span>&#160;            Super::m_moduleMembers[bestModuleIndex] += 1;</div><div class="line"><a name="l00811"></a><span class="lineno">  811</span>&#160;</div><div class="line"><a name="l00812"></a><span class="lineno">  812</span>&#160;            <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> oldModuleIndex = current.index;</div><div class="line"><a name="l00813"></a><span class="lineno">  813</span>&#160;            current.index = bestModuleIndex;</div><div class="line"><a name="l00814"></a><span class="lineno">  814</span>&#160;</div><div class="line"><a name="l00815"></a><span class="lineno">  815</span>&#160;            <span class="comment">// Update physical node map on move for memory networks</span></div><div class="line"><a name="l00816"></a><span class="lineno">  816</span>&#160;            derived().performMoveOfMemoryNode(current, oldModuleIndex, bestModuleIndex);</div><div class="line"><a name="l00817"></a><span class="lineno">  817</span>&#160;</div><div class="line"><a name="l00818"></a><span class="lineno">  818</span>&#160;            ++numMoved;</div><div class="line"><a name="l00819"></a><span class="lineno">  819</span>&#160;</div><div class="line"><a name="l00820"></a><span class="lineno">  820</span>&#160;            <span class="comment">// Mark neighbours as dirty</span></div><div class="line"><a name="l00821"></a><span class="lineno">  821</span>&#160;            <span class="keywordflow">for</span> (NodeBase::edge_iterator edgeIt(current.begin_outEdge()), endIt(current.end_outEdge());</div><div class="line"><a name="l00822"></a><span class="lineno">  822</span>&#160;                    edgeIt != endIt; ++edgeIt)</div><div class="line"><a name="l00823"></a><span class="lineno">  823</span>&#160;                (*edgeIt)-&gt;target.dirty = <span class="keyword">true</span>;</div><div class="line"><a name="l00824"></a><span class="lineno">  824</span>&#160;            for (NodeBase::edge_iterator edgeIt(current.begin_inEdge()), endIt(current.end_inEdge());</div><div class="line"><a name="l00825"></a><span class="lineno">  825</span>&#160;                    edgeIt != endIt; ++edgeIt)</div><div class="line"><a name="l00826"></a><span class="lineno">  826</span>&#160;                (*edgeIt)-&gt;source.dirty = <span class="keyword">true</span>;</div><div class="line"><a name="l00827"></a><span class="lineno">  827</span>&#160;        }</div><div class="line"><a name="l00828"></a><span class="lineno">  828</span>&#160;        <span class="keywordflow">else</span></div><div class="line"><a name="l00829"></a><span class="lineno">  829</span>&#160;            current.dirty = <span class="keyword">false</span>;</div><div class="line"><a name="l00830"></a><span class="lineno">  830</span>&#160;</div><div class="line"><a name="l00831"></a><span class="lineno">  831</span>&#160;    }</div><div class="line"><a name="l00832"></a><span class="lineno">  832</span>&#160;</div><div class="line"><a name="l00833"></a><span class="lineno">  833</span>&#160;    <span class="keywordflow">return</span> numMoved;</div><div class="line"><a name="l00834"></a><span class="lineno">  834</span>&#160;}</div><div class="ttc" id="classInfomapGreedySpecialized_html_a6f4ff75d89a26f1b474ca5a2190878c7"><div class="ttname"><a href="classInfomapGreedySpecialized.html#a6f4ff75d89a26f1b474ca5a2190878c7">InfomapGreedySpecialized::updateCodelengthOnMovingNode</a></div><div class="ttdeci">void updateCodelengthOnMovingNode(NodeType &amp;current, DeltaFlow &amp;oldModuleDelta, DeltaFlow &amp;newModuleDelta)</div><div class="ttdef"><b>Definition:</b> InfomapGreedySpecialized.h:322</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ac1026d8aaeb5a5ceeb6c272d6adba431"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1026d8aaeb5a5ceeb6c272d6adba431">&#9670;&nbsp;</a></span>tryMoveEachNodeIntoStrongestConnectedModule()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InfomapGreedyDerivedType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="classInfomapGreedyCommon.html">InfomapGreedyCommon</a>&lt; InfomapGreedyDerivedType &gt;::tryMoveEachNodeIntoStrongestConnectedModule </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Try fast and crude minimization of the codelength by trying to move nodes into strongest connected modules. </p><dl class="section return"><dt>Returns</dt><dd>The number of nodes moved. </dd></dl>
<div class="fragment"><div class="line"><a name="l01127"></a><span class="lineno"> 1127</span>&#160;{</div><div class="line"><a name="l01128"></a><span class="lineno"> 1128</span>&#160;    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> numNodes = Super::m_activeNetwork.size();</div><div class="line"><a name="l01129"></a><span class="lineno"> 1129</span>&#160;    <span class="comment">// Get random enumeration of nodes</span></div><div class="line"><a name="l01130"></a><span class="lineno"> 1130</span>&#160;    std::vector&lt;unsigned int&gt; randomOrder(numNodes);</div><div class="line"><a name="l01131"></a><span class="lineno"> 1131</span>&#160;    infomath::getRandomizedIndexVector(randomOrder, Super::m_rand);</div><div class="line"><a name="l01132"></a><span class="lineno"> 1132</span>&#160;</div><div class="line"><a name="l01133"></a><span class="lineno"> 1133</span>&#160;    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> numMoved = 0;</div><div class="line"><a name="l01134"></a><span class="lineno"> 1134</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; numNodes; ++i)</div><div class="line"><a name="l01135"></a><span class="lineno"> 1135</span>&#160;    {</div><div class="line"><a name="l01136"></a><span class="lineno"> 1136</span>&#160;        <span class="comment">// Pick nodes in random order</span></div><div class="line"><a name="l01137"></a><span class="lineno"> 1137</span>&#160;        <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> flip = randomOrder[i];</div><div class="line"><a name="l01138"></a><span class="lineno"> 1138</span>&#160;        NodeType&amp; current = getNode(*Super::m_activeNetwork[flip]);</div><div class="line"><a name="l01139"></a><span class="lineno"> 1139</span>&#160;</div><div class="line"><a name="l01140"></a><span class="lineno"> 1140</span>&#160;        <span class="keywordflow">if</span> (!current.dirty) <span class="comment">//TODO: Only skip stable nodes until converged, then start over as a fine tune?</span></div><div class="line"><a name="l01141"></a><span class="lineno"> 1141</span>&#160;            <span class="keywordflow">continue</span>;</div><div class="line"><a name="l01142"></a><span class="lineno"> 1142</span>&#160;</div><div class="line"><a name="l01143"></a><span class="lineno"> 1143</span>&#160;        <span class="keywordflow">if</span> (Super::m_moduleMembers[current.index] &gt; 1 &amp;&amp; Super::isFirstLoop() &amp;&amp; m_config.tuneIterationLimit != 1)</div><div class="line"><a name="l01144"></a><span class="lineno"> 1144</span>&#160;            <span class="keywordflow">continue</span>;</div><div class="line"><a name="l01145"></a><span class="lineno"> 1145</span>&#160;</div><div class="line"><a name="l01146"></a><span class="lineno"> 1146</span>&#160;        <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> strongestConnectedModule = current.index;</div><div class="line"><a name="l01147"></a><span class="lineno"> 1147</span>&#160;        <span class="keywordtype">double</span> maxFlow = 0.0;</div><div class="line"><a name="l01148"></a><span class="lineno"> 1148</span>&#160;</div><div class="line"><a name="l01149"></a><span class="lineno"> 1149</span>&#160;        <span class="comment">// For all outlinks</span></div><div class="line"><a name="l01150"></a><span class="lineno"> 1150</span>&#160;        <span class="keywordflow">for</span> (NodeBase::edge_iterator edgeIt(current.begin_outEdge()), endIt(current.end_outEdge());</div><div class="line"><a name="l01151"></a><span class="lineno"> 1151</span>&#160;                edgeIt != endIt; ++edgeIt)</div><div class="line"><a name="l01152"></a><span class="lineno"> 1152</span>&#160;        {</div><div class="line"><a name="l01153"></a><span class="lineno"> 1153</span>&#160;            EdgeType&amp; edge = **edgeIt;</div><div class="line"><a name="l01154"></a><span class="lineno"> 1154</span>&#160;            <span class="keywordflow">if</span> (edge.data.flow &gt; maxFlow) {</div><div class="line"><a name="l01155"></a><span class="lineno"> 1155</span>&#160;                maxFlow = edge.data.flow;</div><div class="line"><a name="l01156"></a><span class="lineno"> 1156</span>&#160;                strongestConnectedModule = edge.target.index;</div><div class="line"><a name="l01157"></a><span class="lineno"> 1157</span>&#160;            }</div><div class="line"><a name="l01158"></a><span class="lineno"> 1158</span>&#160;        }</div><div class="line"><a name="l01159"></a><span class="lineno"> 1159</span>&#160;        <span class="comment">// For all inlinks</span></div><div class="line"><a name="l01160"></a><span class="lineno"> 1160</span>&#160;        <span class="keywordflow">for</span> (NodeBase::edge_iterator edgeIt(current.begin_inEdge()), endIt(current.end_inEdge());</div><div class="line"><a name="l01161"></a><span class="lineno"> 1161</span>&#160;                edgeIt != endIt; ++edgeIt)</div><div class="line"><a name="l01162"></a><span class="lineno"> 1162</span>&#160;        {</div><div class="line"><a name="l01163"></a><span class="lineno"> 1163</span>&#160;            EdgeType&amp; edge = **edgeIt;</div><div class="line"><a name="l01164"></a><span class="lineno"> 1164</span>&#160;            <span class="keywordflow">if</span> (edge.data.flow &gt; maxFlow) {</div><div class="line"><a name="l01165"></a><span class="lineno"> 1165</span>&#160;                maxFlow = edge.data.flow;</div><div class="line"><a name="l01166"></a><span class="lineno"> 1166</span>&#160;                strongestConnectedModule = edge.source.index;</div><div class="line"><a name="l01167"></a><span class="lineno"> 1167</span>&#160;            }</div><div class="line"><a name="l01168"></a><span class="lineno"> 1168</span>&#160;        }</div><div class="line"><a name="l01169"></a><span class="lineno"> 1169</span>&#160;</div><div class="line"><a name="l01170"></a><span class="lineno"> 1170</span>&#160;        <span class="comment">// Move to strongest connected module</span></div><div class="line"><a name="l01171"></a><span class="lineno"> 1171</span>&#160;        <span class="keywordflow">if</span>(strongestConnectedModule != current.index)</div><div class="line"><a name="l01172"></a><span class="lineno"> 1172</span>&#160;        {</div><div class="line"><a name="l01173"></a><span class="lineno"> 1173</span>&#160;</div><div class="line"><a name="l01174"></a><span class="lineno"> 1174</span>&#160;            <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> newM = strongestConnectedModule;</div><div class="line"><a name="l01175"></a><span class="lineno"> 1175</span>&#160;            <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> oldM = current.index;</div><div class="line"><a name="l01176"></a><span class="lineno"> 1176</span>&#160;</div><div class="line"><a name="l01177"></a><span class="lineno"> 1177</span>&#160;            DeltaFlowType oldModuleDelta(oldM, 0.0, 0.0, 0.0, 0.0);</div><div class="line"><a name="l01178"></a><span class="lineno"> 1178</span>&#160;            DeltaFlowType newModuleDelta(newM, 0.0, 0.0, 0.0, 0.0);</div><div class="line"><a name="l01179"></a><span class="lineno"> 1179</span>&#160;</div><div class="line"><a name="l01180"></a><span class="lineno"> 1180</span>&#160;            <span class="comment">// For all outlinks</span></div><div class="line"><a name="l01181"></a><span class="lineno"> 1181</span>&#160;            <span class="keywordflow">for</span> (NodeBase::edge_iterator edgeIt(current.begin_outEdge()), endIt(current.end_outEdge());</div><div class="line"><a name="l01182"></a><span class="lineno"> 1182</span>&#160;                    edgeIt != endIt; ++edgeIt)</div><div class="line"><a name="l01183"></a><span class="lineno"> 1183</span>&#160;            {</div><div class="line"><a name="l01184"></a><span class="lineno"> 1184</span>&#160;                EdgeType&amp; edge = **edgeIt;</div><div class="line"><a name="l01185"></a><span class="lineno"> 1185</span>&#160;                <span class="keywordflow">if</span> (edge.isSelfPointing())</div><div class="line"><a name="l01186"></a><span class="lineno"> 1186</span>&#160;                    <span class="keywordflow">continue</span>;</div><div class="line"><a name="l01187"></a><span class="lineno"> 1187</span>&#160;                <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> otherModule = edge.target.index;</div><div class="line"><a name="l01188"></a><span class="lineno"> 1188</span>&#160;                <span class="keywordflow">if</span> (otherModule == oldM)</div><div class="line"><a name="l01189"></a><span class="lineno"> 1189</span>&#160;                    oldModuleDelta.deltaExit += edge.data.flow;</div><div class="line"><a name="l01190"></a><span class="lineno"> 1190</span>&#160;                <span class="keywordflow">else</span> <span class="keywordflow">if</span> (otherModule == newM)</div><div class="line"><a name="l01191"></a><span class="lineno"> 1191</span>&#160;                    newModuleDelta.deltaExit += edge.data.flow;</div><div class="line"><a name="l01192"></a><span class="lineno"> 1192</span>&#160;            }</div><div class="line"><a name="l01193"></a><span class="lineno"> 1193</span>&#160;</div><div class="line"><a name="l01194"></a><span class="lineno"> 1194</span>&#160;            <span class="comment">// For all inlinks</span></div><div class="line"><a name="l01195"></a><span class="lineno"> 1195</span>&#160;            <span class="keywordflow">for</span> (NodeBase::edge_iterator edgeIt(current.begin_inEdge()), endIt(current.end_inEdge());</div><div class="line"><a name="l01196"></a><span class="lineno"> 1196</span>&#160;                    edgeIt != endIt; ++edgeIt)</div><div class="line"><a name="l01197"></a><span class="lineno"> 1197</span>&#160;            {</div><div class="line"><a name="l01198"></a><span class="lineno"> 1198</span>&#160;                EdgeType&amp; edge = **edgeIt;</div><div class="line"><a name="l01199"></a><span class="lineno"> 1199</span>&#160;                <span class="keywordflow">if</span> (edge.isSelfPointing())</div><div class="line"><a name="l01200"></a><span class="lineno"> 1200</span>&#160;                    <span class="keywordflow">continue</span>;</div><div class="line"><a name="l01201"></a><span class="lineno"> 1201</span>&#160;                <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> otherModule = edge.source.index;</div><div class="line"><a name="l01202"></a><span class="lineno"> 1202</span>&#160;                <span class="keywordflow">if</span> (otherModule == oldM)</div><div class="line"><a name="l01203"></a><span class="lineno"> 1203</span>&#160;                    oldModuleDelta.deltaEnter += edge.data.flow;</div><div class="line"><a name="l01204"></a><span class="lineno"> 1204</span>&#160;                <span class="keywordflow">else</span> <span class="keywordflow">if</span> (otherModule == newM)</div><div class="line"><a name="l01205"></a><span class="lineno"> 1205</span>&#160;                    newModuleDelta.deltaEnter += edge.data.flow;</div><div class="line"><a name="l01206"></a><span class="lineno"> 1206</span>&#160;            }</div><div class="line"><a name="l01207"></a><span class="lineno"> 1207</span>&#160;</div><div class="line"><a name="l01208"></a><span class="lineno"> 1208</span>&#160;</div><div class="line"><a name="l01209"></a><span class="lineno"> 1209</span>&#160;            <span class="comment">//Update empty module vector</span></div><div class="line"><a name="l01210"></a><span class="lineno"> 1210</span>&#160;            <span class="keywordflow">if</span>(Super::m_moduleMembers[newM] == 0)</div><div class="line"><a name="l01211"></a><span class="lineno"> 1211</span>&#160;            {</div><div class="line"><a name="l01212"></a><span class="lineno"> 1212</span>&#160;                Super::m_emptyModules.pop_back();</div><div class="line"><a name="l01213"></a><span class="lineno"> 1213</span>&#160;            }</div><div class="line"><a name="l01214"></a><span class="lineno"> 1214</span>&#160;            <span class="keywordflow">if</span>(Super::m_moduleMembers[oldM] == 1)</div><div class="line"><a name="l01215"></a><span class="lineno"> 1215</span>&#160;            {</div><div class="line"><a name="l01216"></a><span class="lineno"> 1216</span>&#160;                Super::m_emptyModules.push_back(oldM);</div><div class="line"><a name="l01217"></a><span class="lineno"> 1217</span>&#160;            }</div><div class="line"><a name="l01218"></a><span class="lineno"> 1218</span>&#160;</div><div class="line"><a name="l01219"></a><span class="lineno"> 1219</span>&#160;            derived().performMoveOfMemoryNode(current, oldM, newM);</div><div class="line"><a name="l01220"></a><span class="lineno"> 1220</span>&#160;            Super::updateFlowOnMovingNode(current, oldModuleDelta, newModuleDelta);</div><div class="line"><a name="l01221"></a><span class="lineno"> 1221</span>&#160;</div><div class="line"><a name="l01222"></a><span class="lineno"> 1222</span>&#160;            Super::m_moduleMembers[oldM] -= 1;</div><div class="line"><a name="l01223"></a><span class="lineno"> 1223</span>&#160;            Super::m_moduleMembers[newM] += 1;</div><div class="line"><a name="l01224"></a><span class="lineno"> 1224</span>&#160;</div><div class="line"><a name="l01225"></a><span class="lineno"> 1225</span>&#160;            current.index = strongestConnectedModule;</div><div class="line"><a name="l01226"></a><span class="lineno"> 1226</span>&#160;</div><div class="line"><a name="l01227"></a><span class="lineno"> 1227</span>&#160;            ++numMoved;</div><div class="line"><a name="l01228"></a><span class="lineno"> 1228</span>&#160;</div><div class="line"><a name="l01229"></a><span class="lineno"> 1229</span>&#160;            <span class="comment">// Mark neighbours as dirty</span></div><div class="line"><a name="l01230"></a><span class="lineno"> 1230</span>&#160;            <span class="keywordflow">for</span> (NodeBase::edge_iterator edgeIt(current.begin_outEdge()), endIt(current.end_outEdge());</div><div class="line"><a name="l01231"></a><span class="lineno"> 1231</span>&#160;                    edgeIt != endIt; ++edgeIt)</div><div class="line"><a name="l01232"></a><span class="lineno"> 1232</span>&#160;                (*edgeIt)-&gt;target.dirty = <span class="keyword">true</span>;</div><div class="line"><a name="l01233"></a><span class="lineno"> 1233</span>&#160;            for (NodeBase::edge_iterator edgeIt(current.begin_inEdge()), endIt(current.end_inEdge());</div><div class="line"><a name="l01234"></a><span class="lineno"> 1234</span>&#160;                    edgeIt != endIt; ++edgeIt)</div><div class="line"><a name="l01235"></a><span class="lineno"> 1235</span>&#160;                (*edgeIt)-&gt;source.dirty = <span class="keyword">true</span>;</div><div class="line"><a name="l01236"></a><span class="lineno"> 1236</span>&#160;        }</div><div class="line"><a name="l01237"></a><span class="lineno"> 1237</span>&#160;        <span class="keywordflow">else</span></div><div class="line"><a name="l01238"></a><span class="lineno"> 1238</span>&#160;            current.dirty = <span class="keyword">false</span>;</div><div class="line"><a name="l01239"></a><span class="lineno"> 1239</span>&#160;    }</div><div class="line"><a name="l01240"></a><span class="lineno"> 1240</span>&#160;</div><div class="line"><a name="l01241"></a><span class="lineno"> 1241</span>&#160;    <span class="keywordflow">return</span> numMoved;</div><div class="line"><a name="l01242"></a><span class="lineno"> 1242</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>dsmacc/graph/infomap/src/infomap/<a class="el" href="InfomapGreedyCommon_8h_source.html">InfomapGreedyCommon.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
