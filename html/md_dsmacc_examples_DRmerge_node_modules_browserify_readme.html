<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DSMACC: browserify</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">DSMACC
   &#160;<span id="projectnumber">2019</span>
   </div>
   <div id="projectbrief">Changes to DSMACC for the thesis of Daniel Ellis</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">browserify </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>&lsquo;require('modules&rsquo;)` in the browser</p>
<p>Use a <a href="http://nodejs.org">node</a>-style <code>require()</code> to organize your browser code and load modules installed by <a href="https://www.npmjs.com">npm</a>.</p>
<p>browserify will recursively analyze all the <code>require()</code> calls in your app in order to build a bundle you can serve up to the browser in a single <code>&lt;script&gt;</code> tag.</p>
<p><a href="https://travis-ci.org/browserify/browserify"></a></p>
<div class="image">
<img src="./assets/logo.png" alt="browserify!"/>
</div>
<h1>getting started</h1>
<p>If you're new to browserify, check out the <a href="https://github.com/browserify/browserify-handbook">browserify handbook</a> and the resources on <a href="http://browserify.org/">browserify.org</a>.</p>
<h1>example</h1>
<p>Whip up a file, <code>main.js</code> with some <code>require()</code>s in it. You can use relative paths like &lsquo;&rsquo;./foo.js'<code>and</code>'../lib/bar.js'<code>or module paths like</code>'gamma'<code> that will search</code>node_modules/` using <a href="https://github.com/browserify/resolve">node's module lookup algorithm</a>.</p>
<div class="fragment"><div class="line">var foo = require(&#39;./foo.js&#39;);</div><div class="line">var bar = require(&#39;../lib/bar.js&#39;);</div><div class="line">var gamma = require(&#39;gamma&#39;);</div><div class="line"></div><div class="line">var elem = document.getElementById(&#39;result&#39;);</div><div class="line">var x = foo(100) + bar(&#39;baz&#39;);</div><div class="line">elem.textContent = gamma(x);</div></div><!-- fragment --><p>Export functionality by assigning onto <code>module.exports</code> or <code>exports</code>:</p>
<div class="fragment"><div class="line">module.exports = function (n) { return n * 111 }</div></div><!-- fragment --><p>Now just use the <code>browserify</code> command to build a bundle starting at <code>main.js</code>:</p>
<div class="fragment"><div class="line">$ browserify main.js &gt; bundle.js</div></div><!-- fragment --><p>All of the modules that <code>main.js</code> needs are included in the <code>bundle.js</code> from a recursive walk of the <code>require()</code> graph using <a href="https://github.com/defunctzombie/node-required">required</a>.</p>
<p>To use this bundle, just toss a <code>&lt;script src="bundle.js"&gt;&lt;/script&gt;</code> into your html!</p>
<h1>install</h1>
<p>With <a href="https://www.npmjs.com/">npm</a> do:</p>
<div class="fragment"><div class="line">npm install -g browserify</div></div><!-- fragment --><h1>usage</h1>
<div class="fragment"><div class="line">Usage: browserify [entry files] {OPTIONS}</div><div class="line"></div><div class="line">Standard Options:</div><div class="line"></div><div class="line">    --outfile, -o  Write the browserify bundle to this file.</div><div class="line">                   If unspecified, browserify prints to stdout.</div><div class="line"></div><div class="line">    --require, -r  A module name or file to bundle.require()</div><div class="line">                   Optionally use a colon separator to set the target.</div><div class="line"></div><div class="line">      --entry, -e  An entry point of your app</div><div class="line"></div><div class="line">     --ignore, -i  Replace a file with an empty stub. Files can be globs.</div><div class="line"></div><div class="line">    --exclude, -u  Omit a file from the output bundle. Files can be globs.</div><div class="line"></div><div class="line">   --external, -x  Reference a file from another bundle. Files can be globs.</div><div class="line"></div><div class="line">  --transform, -t  Use a transform module on top-level files.</div><div class="line"></div><div class="line">    --command, -c  Use a transform command on top-level files.</div><div class="line"></div><div class="line">  --standalone -s  Generate a UMD bundle for the supplied export name.</div><div class="line">                   This bundle works with other module systems and sets the name</div><div class="line">                   given as a window global if no module system is found.</div><div class="line"></div><div class="line">       --debug -d  Enable source maps that allow you to debug your files</div><div class="line">                   separately.</div><div class="line"></div><div class="line">       --help, -h  Show this message</div><div class="line"></div><div class="line">For advanced options, type `browserify --help advanced`.</div><div class="line"></div><div class="line">Specify a parameter.</div></div><!-- fragment --><p>``` Advanced Options:</p>
<p>&ndash;insert-globals, &ndash;ig, &ndash;fast [default: false]</p>
<p>Skip detection and always insert definitions for process, global, __filename, and __dirname.</p>
<p>benefit: faster builds cost: extra bytes</p>
<p>&ndash;insert-global-vars, &ndash;igv</p>
<p>Comma-separated list of global variables to detect and define. Default: __filename,__dirname,process,Buffer,global</p>
<p>&ndash;detect-globals, &ndash;dg [default: true]</p>
<p>Detect the presence of process, global, __filename, and __dirname and define these values when present.</p>
<p>benefit: npm modules more likely to work cost: slower builds</p>
<p>&ndash;ignore-missing, &ndash;im [default: false]</p>
<p>Ignore <code>require()</code> statements that don't resolve to anything.</p>
<p>&ndash;noparse=FILE</p>
<p>Don't parse FILE at all. This will make bundling much, much faster for giant libs like jquery or threejs.</p>
<p>&ndash;no-builtins</p>
<p>Turn off builtins. This is handy when you want to run a bundle in node which provides the core builtins.</p>
<p>&ndash;no-commondir</p>
<p>Turn off setting a commondir. This is useful if you want to preserve the original paths that a bundle was generated with.</p>
<p>&ndash;no-bundle-external</p>
<p>Turn off bundling of all external modules. This is useful if you only want to bundle your local files.</p>
<p>&ndash;bare</p>
<p>Alias for both &ndash;no-builtins, &ndash;no-commondir, and sets &ndash;insert-global-vars to just "__filename,__dirname". This is handy if you want to run bundles in node.</p>
<p>&ndash;no-browser-field, &ndash;no-bf</p>
<p>Turn off package.json browser field resolution. This is also handy if you need to run a bundle in node.</p>
<p>&ndash;transform-key</p>
<p>Instead of the default package.json::browserify::transform field to list all transforms to apply when running browserify, a custom field, like, e.g. package.json::browserify::production or package.json::browserify::staging can be used, by for example running:</p><ul>
<li><code>browserify index.js --transform-key=production &gt; bundle.js</code></li>
<li><code>browserify index.js --transform-key=staging &gt; bundle.js</code></li>
</ul>
<p>&ndash;node</p>
<p>Alias for &ndash;bare and &ndash;no-browser-field.</p>
<p>&ndash;full-paths</p>
<p>Turn off converting module ids into numerical indexes. This is useful for preserving the original paths that a bundle was generated with.</p>
<p>&ndash;deps</p>
<p>Instead of standard bundle output, print the dependency array generated by module-deps.</p>
<p>&ndash;no-dedupe</p>
<p>Turn off deduping.</p>
<p>&ndash;list</p>
<p>Print each file in the dependency graph. Useful for makefiles.</p>
<p>&ndash;extension=EXTENSION</p>
<p>Consider files with specified EXTENSION as modules, this option can used multiple times.</p>
<p>&ndash;global-transform=MODULE, -g MODULE</p>
<p>Use a transform module on all files after any ordinary transforms have run.</p>
<p>&ndash;ignore-transform=MODULE, -it MODULE</p>
<p>Do not run certain transformations, even if specified elsewhere.</p>
<p>&ndash;plugin=MODULE, -p MODULE</p>
<p>Register MODULE as a plugin.</p>
<p>Passing arguments to transforms and plugins:</p>
<p>For -t, -g, and -p, you may use subarg syntax to pass options to the transforms or plugin function as the second parameter. For example:</p>
<p>-t [ foo -x 3 &ndash;beep ]</p>
<p>will call the <code>foo</code> transform for each applicable file by calling:</p>
<p>foo(file, { x: 3, beep: true })</p>
<div class="fragment"><div class="line"># compatibility</div><div class="line"></div><div class="line">Many [npm](https://www.npmjs.com/) modules that don&#39;t do IO will just work after being</div><div class="line">browserified. Others take more work.</div><div class="line"></div><div class="line">Many node built-in modules have been wrapped to work in the browser, but only</div><div class="line">when you explicitly `require()` or use their functionality.</div><div class="line"></div><div class="line">When you `require()` any of these modules, you will get a browser-specific shim:</div><div class="line"></div><div class="line">* [assert](https://www.npmjs.com/package/assert)</div><div class="line">* [buffer](https://www.npmjs.com/package/buffer)</div><div class="line">* [console](https://www.npmjs.com/package/console-browserify)</div><div class="line">* [constants](https://www.npmjs.com/package/constants-browserify)</div><div class="line">* [crypto](https://www.npmjs.com/package/crypto-browserify)</div><div class="line">* [domain](https://www.npmjs.com/package/domain-browser)</div><div class="line">* [events](https://www.npmjs.com/package/events)</div><div class="line">* [http](https://www.npmjs.com/package/stream-http)</div><div class="line">* [https](https://www.npmjs.com/package/https-browserify)</div><div class="line">* [os](https://www.npmjs.com/package/os-browserify)</div><div class="line">* [path](https://www.npmjs.com/package/path-browserify)</div><div class="line">* [punycode](https://www.npmjs.com/package/punycode)</div><div class="line">* [querystring](https://www.npmjs.com/package/querystring-es3)</div><div class="line">* [stream](https://www.npmjs.com/package/stream-browserify)</div><div class="line">* [string_decoder](https://www.npmjs.com/package/string_decoder)</div><div class="line">* [timers](https://www.npmjs.com/package/timers-browserify)</div><div class="line">* [tty](https://www.npmjs.com/package/tty-browserify)</div><div class="line">* [url](https://www.npmjs.com/package/url)</div><div class="line">* [util](https://www.npmjs.com/package/util)</div><div class="line">* [vm](https://www.npmjs.com/package/vm-browserify)</div><div class="line">* [zlib](https://www.npmjs.com/package/browserify-zlib)</div><div class="line"></div><div class="line">Additionally, if you use any of these variables, they</div><div class="line">[will be defined](https://github.com/browserify/insert-module-globals)</div><div class="line">in the bundled output in a browser-appropriate way:</div><div class="line"></div><div class="line">* [process](https://www.npmjs.com/package/process)</div><div class="line">* [Buffer](https://www.npmjs.com/package/buffer)</div><div class="line">* global - top-level scope object (window)</div><div class="line">* __filename - file path of the currently executing file</div><div class="line">* __dirname - directory path of the currently executing file</div><div class="line"></div><div class="line"># more examples</div><div class="line"></div><div class="line">## external requires</div><div class="line"></div><div class="line">You can just as easily create a bundle that will export a `require()` function so</div><div class="line">you can `require()` modules from another script tag. Here we&#39;ll create a</div><div class="line">`bundle.js` with the [through](https://www.npmjs.com/package/through)</div><div class="line">and [duplexer](https://www.npmjs.com/package/duplexer) modules.</div></div><!-- fragment --><p> $ browserify -r through -r duplexer -r ./my-file.js:my-module &gt; bundle.js </p><div class="fragment"><div class="line">Then in your page you can do:</div><div class="line"></div><div class="line">``` html</div><div class="line">&lt;script src=&quot;bundle.js&quot;&gt;&lt;/script&gt;</div><div class="line">&lt;script&gt;</div><div class="line">  var through = require(&#39;through&#39;);</div><div class="line">  var duplexer = require(&#39;duplexer&#39;);</div><div class="line">  var myModule = require(&#39;my-module&#39;);</div><div class="line">  /* ... */</div><div class="line">&lt;/script&gt;</div></div><!-- fragment --><h2>external source maps</h2>
<p>If you prefer the source maps be saved to a separate <code>.js.map</code> source map file, you may use <a href="https://github.com/thlorenz/exorcist">exorcist</a> in order to achieve that. It's as simple as:</p>
<div class="fragment"><div class="line">$ browserify main.js --debug | exorcist bundle.js.map &gt; bundle.js</div></div><!-- fragment --><p>Learn about additional options <a href="https://github.com/thlorenz/exorcist#usage">here</a>.</p>
<h2>multiple bundles</h2>
<p>If browserify finds a <code>require</code>d function already defined in the page scope, it will fall back to that function if it didn't find any matches in its own set of bundled modules.</p>
<p>In this way, you can use browserify to split up bundles among multiple pages to get the benefit of caching for shared, infrequently-changing modules, while still being able to use <code>require()</code>. Just use a combination of <code>--external</code> and <code>--require</code> to factor out common dependencies.</p>
<p>For example, if a website with 2 pages, <code>beep.js</code>:</p>
<div class="fragment"><div class="line">var robot = require(&#39;./robot.js&#39;);</div><div class="line">console.log(robot(&#39;beep&#39;));</div></div><!-- fragment --><p>and <code>boop.js</code>:</p>
<div class="fragment"><div class="line">var robot = require(&#39;./robot.js&#39;);</div><div class="line">console.log(robot(&#39;boop&#39;));</div></div><!-- fragment --><p>both depend on <code>robot.js</code>:</p>
<div class="fragment"><div class="line">module.exports = function (s) { return s.toUpperCase() + &#39;!&#39; };</div></div><!-- fragment --><div class="fragment"><div class="line">$ browserify -r ./robot.js &gt; static/common.js</div><div class="line">$ browserify -x ./robot.js beep.js &gt; static/beep.js</div><div class="line">$ browserify -x ./robot.js boop.js &gt; static/boop.js</div></div><!-- fragment --><p>Then on the beep page you can have:</p>
<div class="fragment"><div class="line">&lt;script src=&quot;common.js&quot;&gt;&lt;/script&gt;</div><div class="line">&lt;script src=&quot;beep.js&quot;&gt;&lt;/script&gt;</div></div><!-- fragment --><p>while the boop page can have:</p>
<div class="fragment"><div class="line">&lt;script src=&quot;common.js&quot;&gt;&lt;/script&gt;</div><div class="line">&lt;script src=&quot;boop.js&quot;&gt;&lt;/script&gt;</div></div><!-- fragment --><p>This approach using <code>-r</code> and <code>-x</code> works fine for a small number of split assets, but there are plugins for automatically factoring out components which are described in the <a href="https://github.com/browserify/browserify-handbook#partitioning">partitioning section of the browserify handbook</a>.</p>
<h2>api example</h2>
<p>You can use the API directly too:</p>
<div class="fragment"><div class="line">var browserify = require(&#39;browserify&#39;);</div><div class="line">var b = browserify();</div><div class="line">b.add(&#39;./browser/main.js&#39;);</div><div class="line">b.bundle().pipe(process.stdout);</div></div><!-- fragment --><h1>methods</h1>
<div class="fragment"><div class="line">var browserify = require(&#39;browserify&#39;)</div></div><!-- fragment --><h2><code>browserify([files] [, opts])</code></h2>
<p>Returns a new browserify instance.</p>
<dl>
<dt>files  </dt>
<dd><p class="startdd">String, file object, or array of those types (they may be mixed) specifying entry file(s). </p>
<p class="enddd"></p>
</dd>
<dt>opts  </dt>
<dd>Object.  </dd>
</dl>
<p><code>files</code> and <code>opts</code> are both optional, but must be in the order shown if both are passed.</p>
<p>Entry files may be passed in <code>files</code> and / or <code>opts.entries</code>.</p>
<p>External requires may be specified in <code>opts.require</code>, accepting the same formats that the <code>files</code> argument does.</p>
<p>If an entry file is a stream, its contents will be used. You should pass <code>opts.basedir</code> when using streaming files so that relative requires can be resolved.</p>
<p><code>opts.entries</code> has the same definition as <code>files</code>.</p>
<p><code>opts.noParse</code> is an array which will skip all require() and global parsing for each file in the array. Use this for giant libs like jquery or threejs that don't have any requires or node-style globals but take forever to parse.</p>
<p><code>opts.transform</code> is an array of transform functions or modules names which will transform the source code before the parsing.</p>
<p><code>opts.ignoreTransform</code> is an array of transformations that will not be run, even if specified elsewhere.</p>
<p><code>opts.plugin</code> is an array of plugin functions or module names to use. See the plugins section below for details.</p>
<p><code>opts.extensions</code> is an array of optional extra extensions for the module lookup machinery to use when the extension has not been specified. By default browserify considers only <code>.js</code> and <code>.json</code> files in such cases.</p>
<p><code>opts.basedir</code> is the directory that browserify starts bundling from for filenames that start with <code>.</code>.</p>
<p><code>opts.paths</code> is an array of directories that browserify searches when looking for modules which are not referenced using relative path. Can be absolute or relative to <code>basedir</code>. Equivalent of setting <code>NODE_PATH</code> environmental variable when calling <code>browserify</code> command.</p>
<p><code>opts.commondir</code> sets the algorithm used to parse out the common paths. Use <code>false</code> to turn this off, otherwise it uses the <a href="https://www.npmjs.com/package/commondir">commondir</a> module.</p>
<p><code>opts.fullPaths</code> disables converting module ids into numerical indexes. This is useful for preserving the original paths that a bundle was generated with.</p>
<p><code>opts.builtins</code> sets the list of built-ins to use, which by default is set in <code>lib/builtins.js</code> in this distribution.</p>
<p><code>opts.bundleExternal</code> boolean option to set if external modules should be bundled. Defaults to true.</p>
<p>When <code>opts.browserField</code> is false, the package.json browser field will be ignored. When <code>opts.browserField</code> is set to a <code>string</code>, then a custom field name can be used instead of the default <code>"browser"</code> field.</p>
<p>When <code>opts.insertGlobals</code> is true, always insert <code>process</code>, <code>global</code>, <code>__filename</code>, and <code>__dirname</code> without analyzing the AST for faster builds but larger output bundles. Default false.</p>
<p>When <code>opts.detectGlobals</code> is true, scan all files for <code>process</code>, <code>global</code>, <code>__filename</code>, and <code>__dirname</code>, defining as necessary. With this option npm modules are more likely to work but bundling takes longer. Default true.</p>
<p>When <code>opts.ignoreMissing</code> is true, ignore <code>require()</code> statements that don't resolve to anything.</p>
<p>When <code>opts.debug</code> is true, add a source map inline to the end of the bundle. This makes debugging easier because you can see all the original files if you are in a modern enough browser.</p>
<p>When <code>opts.standalone</code> is a non-empty string, a standalone module is created with that name and a <a href="https://github.com/forbeslindesay/umd">umd</a> wrapper. You can use namespaces in the standalone global export using a <code>.</code> in the string name as a separator, for example &lsquo;'A.B.C&rsquo;`. The global export will be <a href="https://github.com/ForbesLindesay/umd#name-casing-and-characters">sanitized and camel cased</a>.</p>
<p>Note that in standalone mode the <code>require()</code> calls from the original source will still be around, which may trip up AMD loaders scanning for <code>require()</code> calls. You can remove these calls with <a href="https://www.npmjs.com/package/derequire">derequire</a>:</p>
<div class="fragment"><div class="line">$ npm install -g derequire</div><div class="line">$ browserify main.js --standalone Foo | derequire &gt; bundle.js</div></div><!-- fragment --><p><code>opts.insertGlobalVars</code> will be passed to <a href="https://www.npmjs.com/package/insert-module-globals">insert-module-globals</a> as the <code>opts.vars</code> parameter.</p>
<p><code>opts.externalRequireName</code> defaults to &lsquo;'require&rsquo;<code>in</code>expose` mode but you can use another name.</p>
<p><code>opts.bare</code> creates a bundle that does not include <a class="el" href="classNode.html">Node</a> builtins, and does not replace global <a class="el" href="classNode.html">Node</a> variables except for <code>__dirname</code> and <code>__filename</code>.</p>
<p><code>opts.node</code> creates a bundle that runs in <a class="el" href="classNode.html">Node</a> and does not use the browser versions of dependencies. Same as passing <code>{ bare: true, browserField: false }</code>.</p>
<p>Note that if files do not contain javascript source code then you also need to specify a corresponding transform for them.</p>
<p>All other options are forwarded along to <a href="https://www.npmjs.com/package/module-deps">module-deps</a> and <a href="https://www.npmjs.com/package/browser-pack">browser-pack</a> directly.</p>
<h2>b.add(file, opts)</h2>
<p>Add an entry file from <code>file</code> that will be executed when the bundle loads.</p>
<p>If <code>file</code> is an array, each item in <code>file</code> will be added as an entry file.</p>
<h2>b.require(file, opts)</h2>
<p>Make <code>file</code> available from outside the bundle with <code>require(file)</code>.</p>
<p>The <code>file</code> param is anything that can be resolved by <code>require.resolve()</code>, including files from <code>node_modules</code>. Like with <code>require.resolve()</code>, you must prefix <code>file</code> with <code>./</code> to require a local file (not in <code>node_modules</code>).</p>
<p><code>file</code> can also be a stream, but you should also use <code>opts.basedir</code> so that relative requires will be resolvable.</p>
<p>If <code>file</code> is an array, each item in <code>file</code> will be required. In <code>file</code> array form, you can use a string or object for each item. Object items should have a <code>file</code> property and the rest of the parameters will be used for the <code>opts</code>.</p>
<p>Use the <code>expose</code> property of opts to specify a custom dependency name. &lsquo;require(&rsquo;./vendor/angular/angular.js', {expose: 'angular'})<code>enables</code>require('angular')`</p>
<h2>b.bundle(cb)</h2>
<p>Bundle the files and their dependencies into a single javascript file.</p>
<p>Return a readable stream with the javascript file contents or optionally specify a <code>cb(err, buf)</code> to get the buffered results.</p>
<h2>b.external(file)</h2>
<p>Prevent <code>file</code> from being loaded into the current bundle, instead referencing from another bundle.</p>
<p>If <code>file</code> is an array, each item in <code>file</code> will be externalized.</p>
<p>If <code>file</code> is another bundle, that bundle's contents will be read and excluded from the current bundle as the bundle in <code>file</code> gets bundled.</p>
<h2>b.ignore(file)</h2>
<p>Prevent the module name or file at <code>file</code> from showing up in the output bundle.</p>
<p>If <code>file</code> is an array, each item in <code>file</code> will be ignored.</p>
<p>Instead you will get a file with <code>module.exports = {}</code>.</p>
<h2>b.exclude(file)</h2>
<p>Prevent the module name or file at <code>file</code> from showing up in the output bundle.</p>
<p>If <code>file</code> is an array, each item in <code>file</code> will be excluded.</p>
<p>If your code tries to <code>require()</code> that file it will throw unless you've provided another mechanism for loading it.</p>
<h2>b.transform(tr, opts={})</h2>
<p>Transform source code before parsing it for <code>require()</code> calls with the transform function or module name <code>tr</code>.</p>
<p>If <code>tr</code> is a function, it will be called with <code>tr(file)</code> and it should return a <a href="https://github.com/substack/stream-handbook#through">through-stream</a> that takes the raw file contents and produces the transformed source.</p>
<p>If <code>tr</code> is a string, it should be a module name or file path of a <a href="https://github.com/browserify/module-deps#transforms">transform module</a> with a signature of:</p>
<div class="fragment"><div class="line">var through = require(&#39;through&#39;);</div><div class="line">module.exports = function (file) { return through() };</div></div><!-- fragment --><p>You don't need to necessarily use the <a href="https://www.npmjs.com/package/through">through</a> module. Browserify is compatible with the newer, more verbose <a href="http://nodejs.org/api/stream.html#stream_class_stream_transform_1">Transform streams</a> built into <a class="el" href="classNode.html">Node</a> v0.10.</p>
<p>Here's how you might compile coffee script on the fly using <code>.transform()</code>:</p>
<div class="fragment"><div class="line">var coffee = require(&#39;coffee-script&#39;);</div><div class="line">var through = require(&#39;through&#39;);</div><div class="line"></div><div class="line">b.transform(function (file) {</div><div class="line">    var data = &#39;&#39;;</div><div class="line">    return through(write, end);</div><div class="line"></div><div class="line">    function write (buf) { data += buf }</div><div class="line">    function end () {</div><div class="line">        this.queue(coffee.compile(data));</div><div class="line">        this.queue(null);</div><div class="line">    }</div><div class="line">});</div></div><!-- fragment --><p>Note that on the command-line with the <code>-c</code> flag you can just do:</p>
<div class="fragment"><div class="line">$ browserify -c &#39;coffee -sc&#39; main.coffee &gt; bundle.js</div></div><!-- fragment --><p>Or better still, use the <a href="https://github.com/jnordberg/coffeeify">coffeeify</a> module:</p>
<div class="fragment"><div class="line">$ npm install coffeeify</div><div class="line">$ browserify -t coffeeify main.coffee &gt; bundle.js</div></div><!-- fragment --><p>If <code>opts.global</code> is <code>true</code>, the transform will operate on ALL files, despite whether they exist up a level in a <code>node_modules/</code> directory. Use global transforms cautiously and sparingly, since most of the time an ordinary transform will suffice. You can also not configure global transforms in a <code>package.json</code> like you can with ordinary transforms.</p>
<p>Global transforms always run after any ordinary transforms have run.</p>
<p>Transforms may obtain options from the command-line with <a href="https://www.npmjs.com/package/subarg">subarg</a> syntax:</p>
<div class="fragment"><div class="line">$ browserify -t [ foo --bar=555 ] main.js</div></div><!-- fragment --><p>or from the api:</p>
<div class="fragment"><div class="line">b.transform(&#39;foo&#39;, { bar: 555 })</div></div><!-- fragment --><p>In both cases, these options are provided as the second argument to the transform function:</p>
<div class="fragment"><div class="line">module.exports = function (file, opts) { /* opts.bar === 555 */ }</div></div><!-- fragment --><p>Options sent to the browserify constructor are also provided under <code>opts._flags</code>. These browserify options are sometimes required if your transform needs to do something different when browserify is run in debug mode, for example.</p>
<h2>b.plugin(plugin, opts)</h2>
<p>Register a <code>plugin</code> with <code>opts</code>. Plugins can be a string module name or a function the same as transforms.</p>
<p><code>plugin(b, opts)</code> is called with the browserify instance <code>b</code>.</p>
<p>For more information, consult the plugins section below.</p>
<h2>b.pipeline</h2>
<p>There is an internal <a href="https://www.npmjs.com/package/labeled-stream-splicer">labeled-stream-splicer</a> pipeline with these labels:</p>
<ul>
<li>&lsquo;'record&rsquo;<code>- save inputs to play back later on subsequent</code>bundle()<code>calls *</code>'deps'<code>- [module-deps](<a href="https://www.npmjs.com/package/module-deps">https://www.npmjs.com/package/module-deps</a>) *</code>'json'<code>- adds</code>module.exports=<code>to the beginning of json files *</code>'unbom'<code>- remove byte-order markers *</code>'unshebang'<code>- remove #! labels on the first line *</code>'syntax'<code>- check for syntax errors *</code>'sort'<code>- sort the dependencies for deterministic bundles *</code>'dedupe'<code>- remove duplicate source contents *</code>'label'<code>- apply integer labels to files *</code>'emit-deps'<code>- emit</code>'dep'<code>event *</code>'debug'<code>- apply source maps *</code>'pack'<code>- [browser-pack](<a href="https://www.npmjs.com/package/browser-pack">https://www.npmjs.com/package/browser-pack</a>) *</code>'wrap'<code>- apply final wrapping,</code>require=` and a newline and semicolon</li>
</ul>
<p>You can call <code>b.pipeline.get()</code> with a label name to get a handle on a stream pipeline that you can <code>push()</code>, <code>unshift()</code>, or <code>splice()</code> to insert your own transform streams.</p>
<h2>b.reset(opts)</h2>
<p>Reset the pipeline back to a normal state. This function is called automatically when <code>bundle()</code> is called multiple times.</p>
<p>This function triggers a 'reset' event.</p>
<h1>package.json</h1>
<p>browserify uses the <code>package.json</code> in its module resolution algorithm, just like node. If there is a <code>"main"</code> field, browserify will start resolving the package at that point. If there is no <code>"main"</code> field, browserify will look for an <code>"index.js"</code> file in the module root directory. Here are some more sophisticated things you can do in the package.json:</p>
<h2>browser field</h2>
<p>There is a special "[browser](https://github.com/defunctzombie/package-browser-field-spec)" field you can set in your package.json on a per-module basis to override file resolution for browser-specific versions of files.</p>
<p>For example, if you want to have a browser-specific module entry point for your <code>"main"</code> field you can just set the <code>"browser"</code> field to a string:</p>
<div class="fragment"><div class="line">&quot;browser&quot;: &quot;./browser.js&quot;</div></div><!-- fragment --><p>or you can have overrides on a per-file basis:</p>
<div class="fragment"><div class="line">&quot;browser&quot;: {</div><div class="line">  &quot;fs&quot;: &quot;level-fs&quot;,</div><div class="line">  &quot;./lib/ops.js&quot;: &quot;./browser/opts.js&quot;</div><div class="line">}</div></div><!-- fragment --><p>Note that the browser field only applies to files in the local module, and like transforms, it doesn't apply into <code>node_modules</code> directories.</p>
<h2>browserify.transform</h2>
<p>You can specify source transforms in the package.json in the <code>browserify.transform</code> field. There is more information about how source transforms work in package.json on the <a href="https://github.com/browserify/module-deps#transforms">module-deps readme</a>.</p>
<p>For example, if your module requires <a href="https://www.npmjs.com/package/brfs">brfs</a>, you can add</p>
<div class="fragment"><div class="line">&quot;browserify&quot;: { &quot;transform&quot;: [ &quot;brfs&quot; ] }</div></div><!-- fragment --><p>to your package.json. Now when somebody <code>require()</code>s your module, brfs will automatically be applied to the files in your module without explicit intervention by the person using your module. Make sure to add transforms to your package.json dependencies field.</p>
<h1>events</h1>
<h2>b.on('file', function (file, id, parent) {})</h2>
<h2>b.pipeline.on('file', function (file, id, parent) {})</h2>
<p>When a file is resolved for the bundle, the bundle emits a &lsquo;'file&rsquo;<code>event with the full</code>file<code>path, the</code>id<code>string passed to</code>require()<code>, and the</code>parent` object used by <a href="https://github.com/defunctzombie/node-browser-resolve">browser-resolve</a>.</p>
<p>You could use the <code>file</code> event to implement a file watcher to regenerate bundles when files change.</p>
<h2>b.on('package', function (pkg) {})</h2>
<h2>b.pipeline.on('package', function (pkg) {})</h2>
<p>When a package file is read, this event fires with the contents. The package directory is available at <code>pkg.__dirname</code>.</p>
<h2>b.on('bundle', function (bundle) {})</h2>
<p>When <code>.bundle()</code> is called, this event fires with the <code>bundle</code> output stream.</p>
<h2>b.on('reset', function () {})</h2>
<p>When the <code>.reset()</code> method is called or implicitly called by another call to <code>.bundle()</code>, this event fires.</p>
<h2>b.on('transform', function (tr, file) {})</h2>
<h2>b.pipeline.on('transform', function (tr, file) {})</h2>
<p>When a transform is applied to a file, the &lsquo;'transform&rsquo;<code>event fires on the bundle stream with the transform stream</code>tr<code>and the</code>file` that the transform is being applied to.</p>
<h1>plugins</h1>
<p>For some more advanced use-cases, a transform is not sufficiently extensible. Plugins are modules that take the bundle instance as their first parameter and an option hash as their second.</p>
<p>Plugins can be used to do perform some fancy features that transforms can't do. For example, <a href="https://www.npmjs.com/package/factor-bundle">factor-bundle</a> is a plugin that can factor out common dependencies from multiple entry-points into a common bundle. Use plugins with <code>-p</code> and pass options to plugins with <a href="https://www.npmjs.com/package/subarg">subarg</a> syntax:</p>
<div class="fragment"><div class="line">browserify x.js y.js -p [ factor-bundle -o bundle/x.js -o bundle/y.js ] \</div><div class="line">  &gt; bundle/common.js</div></div><!-- fragment --><p>For a list of plugins, consult the <a href="https://www.npmjs.com/browse/keyword/browserify-plugin">browserify-plugin tag</a> on npm.</p>
<h1>list of source transforms</h1>
<p>There is a <a href="https://github.com/browserify/browserify/wiki/list-of-transforms">wiki page that lists the known browserify transforms</a>.</p>
<p>If you write a transform, make sure to add your transform to that wiki page and add a package.json keyword of <code>browserify-transform</code> so that <a href="https://www.npmjs.com/browse/keyword/browserify-transform">people can browse for all the browserify transforms</a> on npmjs.org.</p>
<h1>third-party tools</h1>
<p>There is a <a href="https://github.com/browserify/browserify/wiki/browserify-tools">wiki page that lists the known browserify tools</a>.</p>
<p>If you write a tool, make sure to add it to that wiki page and add a package.json keyword of <code>browserify-tool</code> so that <a href="https://www.npmjs.com/browse/keyword/browserify-tool">people can browse for all the browserify tools</a> on npmjs.org.</p>
<h1>changelog</h1>
<p>Releases are documented in changelog.markdown and on the <a href="https://twitter.com/browserify">browserify twitter feed</a>.</p>
<h1>license</h1>
<p><a href="./LICENSE">MIT</a></p>
<div class="image">
<img src="./assets/browserify.png" alt="browserify!"/>
</div>
 </div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
