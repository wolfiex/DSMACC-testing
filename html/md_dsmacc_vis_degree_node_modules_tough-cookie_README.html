<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DSMACC: README</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">DSMACC
   &#160;<span id="projectnumber">2019</span>
   </div>
   <div id="projectbrief">Changes to DSMACC for the thesis of Daniel Ellis</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">README </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a href="https://tools.ietf.org/html/rfc6265">RFC6265</a> Cookies and CookieJar for Node.js</p>
<p><a href="https://nodei.co/npm/tough-cookie/"></a></p>
<p><a href="https://travis-ci.org/salesforce/tough-cookie"></a></p>
<h1>Synopsis</h1>
<div class="fragment"><div class="line">var tough = require(&#39;tough-cookie&#39;);</div><div class="line">var Cookie = tough.Cookie;</div><div class="line">var cookie = Cookie.parse(header);</div><div class="line">cookie.value = &#39;somethingdifferent&#39;;</div><div class="line">header = cookie.toString();</div><div class="line"></div><div class="line">var cookiejar = new tough.CookieJar();</div><div class="line">cookiejar.setCookie(cookie, &#39;http://currentdomain.example.com/path&#39;, cb);</div><div class="line">// ...</div><div class="line">cookiejar.getCookies(&#39;http://example.com/otherpath&#39;,function(err,cookies) {</div><div class="line">  res.headers[&#39;cookie&#39;] = cookies.join(&#39;; &#39;);</div><div class="line">});</div></div><!-- fragment --><h1>Installation</h1>
<p>It's <em>so</em> easy!</p>
<p><code>npm install tough-cookie</code></p>
<p>Why the name? NPM modules <code>cookie</code>, <code>cookies</code> and <code>cookiejar</code> were already taken.</p>
<h2>Version Support</h2>
<p>Support for versions of node.js will follow that of the <a href="https://www.npmjs.com/package/request">request</a> module.</p>
<h1>API</h1>
<h2>tough</h2>
<p>Functions on the module you get from &lsquo;require('tough-cookie&rsquo;)`. All can be used as pure functions and don't need to be "bound".</p>
<p><b>Note</b>: prior to 1.0.x, several of these functions took a <code>strict</code> parameter. This has since been removed from the API as it was no longer necessary.</p>
<h3><code>parseDate(string)</code></h3>
<p>Parse a cookie date string into a <code><a class="el" href="classDate.html">Date</a></code>. Parses according to RFC6265 Section 5.1.1, not <code>Date.parse()</code>.</p>
<h3><code>formatDate(date)</code></h3>
<p>Format a <a class="el" href="classDate.html">Date</a> into a RFC1123 string (the RFC6265-recommended format).</p>
<h3><code>canonicalDomain(str)</code></h3>
<p>Transforms a domain-name into a canonical domain-name. The canonical domain-name is a trimmed, lowercased, stripped-of-leading-dot and optionally punycode-encoded domain-name (Section 5.1.2 of RFC6265). For the most part, this function is idempotent (can be run again on its output without ill effects).</p>
<h3><code>domainMatch(str,domStr[,canonicalize=true])</code></h3>
<p>Answers "does this real domain match the domain in a cookie?". The <code>str</code> is the "current" domain-name and the <code>domStr</code> is the "cookie" domain-name. Matches according to RFC6265 Section 5.1.3, but it helps to think of it as a "suffix match".</p>
<p>The <code>canonicalize</code> parameter will run the other two parameters through <code>canonicalDomain</code> or not.</p>
<h3><code>defaultPath(path)</code></h3>
<p>Given a current request/response path, gives the Path apropriate for storing in a cookie. This is basically the "directory" of a "file" in the path, but is specified by Section 5.1.4 of the RFC.</p>
<p>The <code>path</code> parameter MUST be <em>only</em> the pathname part of a URI (i.e. excludes the hostname, query, fragment, etc.). This is the <code>.pathname</code> property of node's <code>uri.parse()</code> output.</p>
<h3><code>pathMatch(reqPath,cookiePath)</code></h3>
<p>Answers "does the request-path path-match a given cookie-path?" as per RFC6265 Section 5.1.4. Returns a boolean.</p>
<p>This is essentially a prefix-match where <code>cookiePath</code> is a prefix of <code>reqPath</code>.</p>
<h3><code>parse(cookieString[, options])</code></h3>
<p>alias for <code>Cookie.parse(cookieString[, options])</code></p>
<h3><code>fromJSON(string)</code></h3>
<p>alias for <code>Cookie.fromJSON(string)</code></p>
<h3><code>getPublicSuffix(hostname)</code></h3>
<p>Returns the public suffix of this hostname. The public suffix is the shortest domain-name upon which a cookie can be set. Returns <code>null</code> if the hostname cannot have cookies set for it.</p>
<p>For example: <code>www.example.com</code> and <code>www.subdomain.example.com</code> both have public suffix <code>example.com</code>.</p>
<p>For further information, see <a href="http://publicsuffix.org/">http://publicsuffix.org/</a>. This module derives its list from that site. This call is currently a wrapper around <a href="https://www.npmjs.com/package/psl"><code>psl</code></a>'s <a href="https://www.npmjs.com/package/psl#pslgetdomain">get() method</a>.</p>
<h3><code>cookieCompare(a,b)</code></h3>
<p>For use with <code>.sort()</code>, sorts a list of cookies into the recommended order given in the RFC (Section 5.4 step 2). The sort algorithm is, in order of precedence:</p>
<ul>
<li>Longest <code>.path</code></li>
<li>oldest <code>.creation</code> (which has a 1ms precision, same as <code><a class="el" href="classDate.html">Date</a></code>)</li>
<li>lowest <code>.creationIndex</code> (to get beyond the 1ms precision)</li>
</ul>
<div class="fragment"><div class="line">var cookies = [ /* unsorted array of Cookie objects */ ];</div><div class="line">cookies = cookies.sort(cookieCompare);</div></div><!-- fragment --><p><b>Note</b>: Since JavaScript's <code><a class="el" href="classDate.html">Date</a></code> is limited to a 1ms precision, cookies within the same milisecond are entirely possible. This is especially true when using the <code>now</code> option to <code>.setCookie()</code>. The <code>.creationIndex</code> property is a per-process global counter, assigned during construction with <code>new Cookie()</code>. This preserves the spirit of the RFC sorting: older cookies go first. This works great for <code>MemoryCookieStore</code>, since <code>Set-Cookie</code> headers are parsed in order, but may not be so great for distributed systems. Sophisticated <code>Store</code>s may wish to set this to some other <em>logical clock</em> such that if cookies A and B are created in the same millisecond, but cookie A is created before cookie B, then <code>A.creationIndex &lt; B.creationIndex</code>. If you want to alter the global counter, which you probably <em>shouldn't</em> do, it's stored in <code>Cookie.cookiesCreated</code>.</p>
<h3><code>permuteDomain(domain)</code></h3>
<p>Generates a list of all possible domains that <code>domainMatch()</code> the parameter. May be handy for implementing cookie stores.</p>
<h3><code>permutePath(path)</code></h3>
<p>Generates a list of all possible paths that <code>pathMatch()</code> the parameter. May be handy for implementing cookie stores.</p>
<h2>Cookie</h2>
<p>Exported via <code>tough.Cookie</code>.</p>
<h3><code>Cookie.parse(cookieString[, options])</code></h3>
<p>Parses a single Cookie or Set-Cookie HTTP header into a <code>Cookie</code> object. Returns <code>undefined</code> if the string can't be parsed.</p>
<p>The options parameter is not required and currently has only one property:</p>
<ul>
<li><em>loose</em> - boolean - if <code>true</code> enable parsing of key-less cookies like <code>=abc</code> and <code>=</code>, which are not RFC-compliant.</li>
</ul>
<p>If options is not an object, it is ignored, which means you can use <code>Array::map</code> with it.</p>
<p>Here's how to process the Set-Cookie header(s) on a node HTTP/HTTPS response:</p>
<div class="fragment"><div class="line">if (res.headers[&#39;set-cookie&#39;] instanceof Array)</div><div class="line">  cookies = res.headers[&#39;set-cookie&#39;].map(Cookie.parse);</div><div class="line">else</div><div class="line">  cookies = [Cookie.parse(res.headers[&#39;set-cookie&#39;])];</div></div><!-- fragment --><p><em>Note:</em> in version 2.3.3, tough-cookie limited the number of spaces before the <code>=</code> to 256 characters. This limitation has since been removed. See <a href="https://github.com/salesforce/tough-cookie/issues/92">Issue 92</a></p>
<h3>Properties</h3>
<p>Cookie object properties:</p>
<ul>
<li><em>key</em> - string - the name or key of the cookie (default "")</li>
<li><em>value</em> - string - the value of the cookie (default "")</li>
<li><em>expires</em> - <code><a class="el" href="classDate.html">Date</a></code> - if set, the <code>Expires=</code> attribute of the cookie (defaults to the string <code>"Infinity"</code>). See <code>setExpires()</code></li>
<li><em>maxAge</em> - seconds - if set, the <code>Max-Age=</code> attribute <em>in seconds</em> of the cookie. May also be set to strings <code>"Infinity"</code> and <code>"-Infinity"</code> for non-expiry and immediate-expiry, respectively. See <code>setMaxAge()</code></li>
<li><em>domain</em> - string - the <code>Domain=</code> attribute of the cookie</li>
<li><em>path</em> - string - the <code>Path=</code> of the cookie</li>
<li><em>secure</em> - boolean - the <code>Secure</code> cookie flag</li>
<li><em>httpOnly</em> - boolean - the <code>HttpOnly</code> cookie flag</li>
<li><em>extensions</em> - <code>Array</code> - any unrecognized cookie attributes as strings (even if equal-signs inside)</li>
<li><em>creation</em> - <code><a class="el" href="classDate.html">Date</a></code> - when this cookie was constructed</li>
<li><em>creationIndex</em> - number - set at construction, used to provide greater sort precision (please see <code>cookieCompare(a,b)</code> for a full explanation)</li>
</ul>
<p>After a cookie has been passed through <code>CookieJar.setCookie()</code> it will have the following additional attributes:</p>
<ul>
<li><em>hostOnly</em> - boolean - is this a host-only cookie (i.e. no Domain field was set, but was instead implied)</li>
<li><em>pathIsDefault</em> - boolean - if true, there was no Path field on the cookie and <code>defaultPath()</code> was used to derive one.</li>
<li><em>creation</em> - <code><a class="el" href="classDate.html">Date</a></code> - <b>modified</b> from construction to when the cookie was added to the jar</li>
<li><em>lastAccessed</em> - <code><a class="el" href="classDate.html">Date</a></code> - last time the cookie got accessed. Will affect cookie cleaning once implemented. Using <code>cookiejar.getCookies(...)</code> will update this attribute.</li>
</ul>
<h3><code>Cookie([{properties}])</code></h3>
<p>Receives an options object that can contain any of the above Cookie properties, uses the default for unspecified properties.</p>
<h3><code>.toString()</code></h3>
<p>encode to a Set-Cookie header value. The Expires cookie field is set using <code>formatDate()</code>, but is omitted entirely if <code>.expires</code> is <code>Infinity</code>.</p>
<h3><code>.cookieString()</code></h3>
<p>encode to a Cookie header value (i.e. the <code>.key</code> and <code>.value</code> properties joined with '=').</p>
<h3><code>.setExpires(String)</code></h3>
<p>sets the expiry based on a date-string passed through <code>parseDate()</code>. If parseDate returns <code>null</code> (i.e. can't parse this date string), <code>.expires</code> is set to <code>"Infinity"</code> (a string) is set.</p>
<h3><code>.setMaxAge(number)</code></h3>
<p>sets the maxAge in seconds. Coerces <code>-Infinity</code> to <code>"-Infinity"</code> and <code>Infinity</code> to <code>"Infinity"</code> so it JSON serializes correctly.</p>
<h3><code>.expiryTime([now=Date.now()])</code></h3>
<h3><code>.expiryDate([now=Date.now()])</code></h3>
<p>expiryTime() Computes the absolute unix-epoch milliseconds that this cookie expires. expiryDate() works similarly, except it returns a <code><a class="el" href="classDate.html">Date</a></code> object. Note that in both cases the <code>now</code> parameter should be milliseconds.</p>
<p>Max-Age takes precedence over Expires (as per the RFC). The <code>.creation</code> attribute &ndash; or, by default, the <code>now</code> parameter &ndash; is used to offset the <code>.maxAge</code> attribute.</p>
<p>If Expires (<code>.expires</code>) is set, that's returned.</p>
<p>Otherwise, <code>expiryTime()</code> returns <code>Infinity</code> and <code>expiryDate()</code> returns a <code><a class="el" href="classDate.html">Date</a></code> object for "Tue, 19 Jan 2038 03:14:07 GMT" (latest date that can be expressed by a 32-bit <code>time_t</code>; the common limit for most user-agents).</p>
<h3><code>.TTL([now=Date.now()])</code></h3>
<p>compute the TTL relative to <code>now</code> (milliseconds). The same precedence rules as for <code>expiryTime</code>/<code>expiryDate</code> apply.</p>
<p>The "number" <code>Infinity</code> is returned for cookies without an explicit expiry and <code>0</code> is returned if the cookie is expired. Otherwise a time-to-live in milliseconds is returned.</p>
<h3><code>.canonicalizedDoman()</code></h3>
<h3><code>.cdomain()</code></h3>
<p>return the canonicalized <code>.domain</code> field. This is lower-cased and punycode (RFC3490) encoded if the domain has any non-ASCII characters.</p>
<h3><code>.toJSON()</code></h3>
<p>For convenience in using <code>JSON.serialize(cookie)</code>. Returns a plain-old <code>Object</code> that can be JSON-serialized.</p>
<p>Any <code><a class="el" href="classDate.html">Date</a></code> properties (i.e., <code>.expires</code>, <code>.creation</code>, and <code>.lastAccessed</code>) are exported in ISO format (<code>.toISOString()</code>).</p>
<p><b>NOTE</b>: Custom <code>Cookie</code> properties will be discarded. In tough-cookie 1.x, since there was no <code>.toJSON</code> method explicitly defined, all enumerable properties were captured. If you want a property to be serialized, add the property name to the <code>Cookie.serializableProperties</code> Array.</p>
<h3><code>Cookie.fromJSON(strOrObj)</code></h3>
<p>Does the reverse of <code>cookie.toJSON()</code>. If passed a string, will <code>JSON.parse()</code> that first.</p>
<p>Any <code><a class="el" href="classDate.html">Date</a></code> properties (i.e., <code>.expires</code>, <code>.creation</code>, and <code>.lastAccessed</code>) are parsed via <code>Date.parse()</code>, not the tough-cookie <code>parseDate</code>, since it's JavaScript/JSON-y timestamps being handled at this layer.</p>
<p>Returns <code>null</code> upon JSON parsing error.</p>
<h3><code>.clone()</code></h3>
<p>Does a deep clone of this cookie, exactly implemented as <code>Cookie.fromJSON(cookie.toJSON())</code>.</p>
<h3><code>.validate()</code></h3>
<p>Status: <em>IN PROGRESS</em>. Works for a few things, but is by no means comprehensive.</p>
<p>validates cookie attributes for semantic correctness. Useful for "lint" checking any Set-Cookie headers you generate. For now, it returns a boolean, but eventually could return a reason string &ndash; you can future-proof with this construct:</p>
<div class="fragment"><div class="line">if (cookie.validate() === true) {</div><div class="line">  // it&#39;s tasty</div><div class="line">} else {</div><div class="line">  // yuck!</div><div class="line">}</div></div><!-- fragment --><h2>CookieJar</h2>
<p>Exported via <code>tough.CookieJar</code>.</p>
<h3><code>CookieJar([store],[options])</code></h3>
<p>Simply use <code>new CookieJar()</code>. If you'd like to use a custom store, pass that to the constructor otherwise a <code>MemoryCookieStore</code> will be created and used.</p>
<p>The <code>options</code> object can be omitted and can have the following properties:</p>
<ul>
<li><em>rejectPublicSuffixes</em> - boolean - default <code>true</code> - reject cookies with domains like "com" and "co.uk"</li>
<li><em>looseMode</em> - boolean - default <code>false</code> - accept malformed cookies like <code>bar</code> and <code>=bar</code>, which have an implied empty name. This is not in the standard, but is used sometimes on the web and is accepted by (most) browsers.</li>
</ul>
<p>Since eventually this module would like to support database/remote/etc. CookieJars, continuation passing style is used for CookieJar methods.</p>
<h3><code>.setCookie(cookieOrString, currentUrl, [{options},] cb(err,cookie))</code></h3>
<p>Attempt to set the cookie in the cookie jar. If the operation fails, an error will be given to the callback <code>cb</code>, otherwise the cookie is passed through. The cookie will have updated <code>.creation</code>, <code>.lastAccessed</code> and <code>.hostOnly</code> properties.</p>
<p>The <code>options</code> object can be omitted and can have the following properties:</p>
<ul>
<li><em>http</em> - boolean - default <code>true</code> - indicates if this is an HTTP or non-HTTP API. Affects HttpOnly cookies.</li>
<li><em>secure</em> - boolean - autodetect from url - indicates if this is a "Secure" API. If the currentUrl starts with <code>https:</code> or <code>wss:</code> then this is defaulted to <code>true</code>, otherwise <code>false</code>.</li>
<li><em>now</em> - <a class="el" href="classDate.html">Date</a> - default <code>new <a class="el" href="classDate.html">Date()</a></code> - what to use for the creation/access time of cookies</li>
<li><em>ignoreError</em> - boolean - default <code>false</code> - silently ignore things like parse errors and invalid domains. <code>Store</code> errors aren't ignored by this option.</li>
</ul>
<p>As per the RFC, the <code>.hostOnly</code> property is set if there was no "Domain=" parameter in the cookie string (or <code>.domain</code> was null on the Cookie object). The <code>.domain</code> property is set to the fully-qualified hostname of <code>currentUrl</code> in this case. Matching this cookie requires an exact hostname match (not a <code>domainMatch</code> as per usual).</p>
<h3><code>.setCookieSync(cookieOrString, currentUrl, [{options}])</code></h3>
<p>Synchronous version of <code>setCookie</code>; only works with synchronous stores (e.g. the default <code>MemoryCookieStore</code>).</p>
<h3><code>.getCookies(currentUrl, [{options},] cb(err,cookies))</code></h3>
<p>Retrieve the list of cookies that can be sent in a Cookie header for the current url.</p>
<p>If an error is encountered, that's passed as <code>err</code> to the callback, otherwise an <code>Array</code> of <code>Cookie</code> objects is passed. The array is sorted with <code>cookieCompare()</code> unless the <code>{sort:false}</code> option is given.</p>
<p>The <code>options</code> object can be omitted and can have the following properties:</p>
<ul>
<li><em>http</em> - boolean - default <code>true</code> - indicates if this is an HTTP or non-HTTP API. Affects HttpOnly cookies.</li>
<li><em>secure</em> - boolean - autodetect from url - indicates if this is a "Secure" API. If the currentUrl starts with <code>https:</code> or <code>wss:</code> then this is defaulted to <code>true</code>, otherwise <code>false</code>.</li>
<li><em>now</em> - <a class="el" href="classDate.html">Date</a> - default <code>new <a class="el" href="classDate.html">Date()</a></code> - what to use for the creation/access time of cookies</li>
<li><em>expire</em> - boolean - default <code>true</code> - perform expiry-time checking of cookies and asynchronously remove expired cookies from the store. Using <code>false</code> will return expired cookies and <b>not</b> remove them from the store (which is useful for replaying Set-Cookie headers, potentially).</li>
<li><em>allPaths</em> - boolean - default <code>false</code> - if <code>true</code>, do not scope cookies by path. The default uses RFC-compliant path scoping. <b>Note</b>: may not be supported by the underlying store (the default <code>MemoryCookieStore</code> supports it).</li>
</ul>
<p>The <code>.lastAccessed</code> property of the returned cookies will have been updated.</p>
<h3><code>.getCookiesSync(currentUrl, [{options}])</code></h3>
<p>Synchronous version of <code>getCookies</code>; only works with synchronous stores (e.g. the default <code>MemoryCookieStore</code>).</p>
<h3><code>.getCookieString(...)</code></h3>
<p>Accepts the same options as <code>.getCookies()</code> but passes a string suitable for a Cookie header rather than an array to the callback. Simply maps the <code>Cookie</code> array via <code>.cookieString()</code>.</p>
<h3><code>.getCookieStringSync(...)</code></h3>
<p>Synchronous version of <code>getCookieString</code>; only works with synchronous stores (e.g. the default <code>MemoryCookieStore</code>).</p>
<h3><code>.getSetCookieStrings(...)</code></h3>
<p>Returns an array of strings suitable for <b>Set-Cookie</b> headers. Accepts the same options as <code>.getCookies()</code>. Simply maps the cookie array via <code>.toString()</code>.</p>
<h3><code>.getSetCookieStringsSync(...)</code></h3>
<p>Synchronous version of <code>getSetCookieStrings</code>; only works with synchronous stores (e.g. the default <code>MemoryCookieStore</code>).</p>
<h3><code>.serialize(cb(err,serializedObject))</code></h3>
<p>Serialize the Jar if the underlying store supports <code>.getAllCookies</code>.</p>
<p><b>NOTE</b>: Custom <code>Cookie</code> properties will be discarded. If you want a property to be serialized, add the property name to the <code>Cookie.serializableProperties</code> Array.</p>
<p>See [Serialization Format].</p>
<h3><code>.serializeSync()</code></h3>
<p>Sync version of .serialize</p>
<h3><code>.toJSON()</code></h3>
<p>Alias of .serializeSync() for the convenience of <code>JSON.stringify(cookiejar)</code>.</p>
<h3><code>CookieJar.deserialize(serialized, [store], cb(err,object))</code></h3>
<p>A new Jar is created and the serialized Cookies are added to the underlying store. Each <code>Cookie</code> is added via <code>store.putCookie</code> in the order in which they appear in the serialization.</p>
<p>The <code>store</code> argument is optional, but should be an instance of <code>Store</code>. By default, a new instance of <code>MemoryCookieStore</code> is created.</p>
<p>As a convenience, if <code>serialized</code> is a string, it is passed through <code>JSON.parse</code> first. If that throws an error, this is passed to the callback.</p>
<h3><code>CookieJar.deserializeSync(serialized, [store])</code></h3>
<p>Sync version of <code>.deserialize</code>. <em>Note</em> that the <code>store</code> must be synchronous for this to work.</p>
<h3><code>CookieJar.fromJSON(string)</code></h3>
<p>Alias of <code>.deserializeSync</code> to provide consistency with <code>Cookie.fromJSON()</code>.</p>
<h3><code>.clone([store,]cb(err,newJar))</code></h3>
<p>Produces a deep clone of this jar. Modifications to the original won't affect the clone, and vice versa.</p>
<p>The <code>store</code> argument is optional, but should be an instance of <code>Store</code>. By default, a new instance of <code>MemoryCookieStore</code> is created. Transferring between store types is supported so long as the source implements <code>.getAllCookies()</code> and the destination implements <code>.putCookie()</code>.</p>
<h3><code>.cloneSync([store])</code></h3>
<p>Synchronous version of <code>.clone</code>, returning a new <code>CookieJar</code> instance.</p>
<p>The <code>store</code> argument is optional, but must be a <em>synchronous</em> <code>Store</code> instance if specified. If not passed, a new instance of <code>MemoryCookieStore</code> is used.</p>
<p>The <em>source</em> and <em>destination</em> must both be synchronous <code>Store</code>s. If one or both stores are asynchronous, use <code>.clone</code> instead. Recall that <code>MemoryCookieStore</code> supports both synchronous and asynchronous API calls.</p>
<h2>Store</h2>
<p>Base class for CookieJar stores. Available as <code>tough.Store</code>.</p>
<h2>Store API</h2>
<p>The storage model for each <code>CookieJar</code> instance can be replaced with a custom implementation. The default is <code>MemoryCookieStore</code> which can be found in the <code>lib/memstore.js</code> file. The API uses continuation-passing-style to allow for asynchronous stores.</p>
<p>Stores should inherit from the base <code>Store</code> class, which is available as &lsquo;require('tough-cookie&rsquo;).Store`.</p>
<p>Stores are asynchronous by default, but if <code>store.synchronous</code> is set to <code>true</code>, then the <code>*Sync</code> methods on the of the containing <code>CookieJar</code> can be used (however, the continuation-passing style</p>
<p>All <code>domain</code> parameters will have been normalized before calling.</p>
<p>The Cookie store must have all of the following methods.</p>
<h3><code>store.findCookie(domain, path, key, cb(err,cookie))</code></h3>
<p>Retrieve a cookie with the given domain, path and key (a.k.a. name). The RFC maintains that exactly one of these cookies should exist in a store. If the store is using versioning, this means that the latest/newest such cookie should be returned.</p>
<p>Callback takes an error and the resulting <code>Cookie</code> object. If no cookie is found then <code>null</code> MUST be passed instead (i.e. not an error).</p>
<h3><code>store.findCookies(domain, path, cb(err,cookies))</code></h3>
<p>Locates cookies matching the given domain and path. This is most often called in the context of <code>cookiejar.getCookies()</code> above.</p>
<p>If no cookies are found, the callback MUST be passed an empty array.</p>
<p>The resulting list will be checked for applicability to the current request according to the RFC (domain-match, path-match, http-only-flag, secure-flag, expiry, etc.), so it's OK to use an optimistic search algorithm when implementing this method. However, the search algorithm used SHOULD try to find cookies that <code>domainMatch()</code> the domain and <code>pathMatch()</code> the path in order to limit the amount of checking that needs to be done.</p>
<p>As of version 0.9.12, the <code>allPaths</code> option to <code>cookiejar.getCookies()</code> above will cause the path here to be <code>null</code>. If the path is <code>null</code>, path-matching MUST NOT be performed (i.e. domain-matching only).</p>
<h3><code>store.putCookie(cookie, cb(err))</code></h3>
<p>Adds a new cookie to the store. The implementation SHOULD replace any existing cookie with the same <code>.domain</code>, <code>.path</code>, and <code>.key</code> properties &ndash; depending on the nature of the implementation, it's possible that between the call to <code>fetchCookie</code> and <code>putCookie</code> that a duplicate <code>putCookie</code> can occur.</p>
<p>The <code>cookie</code> object MUST NOT be modified; the caller will have already updated the <code>.creation</code> and <code>.lastAccessed</code> properties.</p>
<p>Pass an error if the cookie cannot be stored.</p>
<h3><code>store.updateCookie(oldCookie, newCookie, cb(err))</code></h3>
<p>Update an existing cookie. The implementation MUST update the <code>.value</code> for a cookie with the same <code>domain</code>, <code>.path</code> and <code>.key</code>. The implementation SHOULD check that the old value in the store is equivalent to <code>oldCookie</code> - how the conflict is resolved is up to the store.</p>
<p>The <code>.lastAccessed</code> property will always be different between the two objects (to the precision possible via JavaScript's clock). Both <code>.creation</code> and <code>.creationIndex</code> are guaranteed to be the same. Stores MAY ignore or defer the <code>.lastAccessed</code> change at the cost of affecting how cookies are selected for automatic deletion (e.g., least-recently-used, which is up to the store to implement).</p>
<p>Stores may wish to optimize changing the <code>.value</code> of the cookie in the store versus storing a new cookie. If the implementation doesn't define this method a stub that calls <code>putCookie(newCookie,cb)</code> will be added to the store object.</p>
<p>The <code>newCookie</code> and <code>oldCookie</code> objects MUST NOT be modified.</p>
<p>Pass an error if the newCookie cannot be stored.</p>
<h3><code>store.removeCookie(domain, path, key, cb(err))</code></h3>
<p>Remove a cookie from the store (see notes on <code>findCookie</code> about the uniqueness constraint).</p>
<p>The implementation MUST NOT pass an error if the cookie doesn't exist; only pass an error due to the failure to remove an existing cookie.</p>
<h3><code>store.removeCookies(domain, path, cb(err))</code></h3>
<p>Removes matching cookies from the store. The <code>path</code> parameter is optional, and if missing means all paths in a domain should be removed.</p>
<p>Pass an error ONLY if removing any existing cookies failed.</p>
<h3><code>store.getAllCookies(cb(err, cookies))</code></h3>
<p>Produces an <code>Array</code> of all cookies during <code>jar.serialize()</code>. The items in the array can be true <code>Cookie</code> objects or generic <code>Object</code>s with the [Serialization Format] data structure.</p>
<p>Cookies SHOULD be returned in creation order to preserve sorting via <code>compareCookies()</code>. For reference, <code>MemoryCookieStore</code> will sort by <code>.creationIndex</code> since it uses true <code>Cookie</code> objects internally. If you don't return the cookies in creation order, they'll still be sorted by creation time, but this only has a precision of 1ms. See <code>compareCookies</code> for more detail.</p>
<p>Pass an error if retrieval fails.</p>
<h2>MemoryCookieStore</h2>
<p>Inherits from <code>Store</code>.</p>
<p>A just-in-memory CookieJar synchronous store implementation, used by default. Despite being a synchronous implementation, it's usable with both the synchronous and asynchronous forms of the <code>CookieJar</code> API.</p>
<h2>Community Cookie Stores</h2>
<p>These are some Store implementations authored and maintained by the community. They aren't official and we don't vouch for them but you may be interested to have a look:</p>
<ul>
<li><a href="https://github.com/JSBizon/db-cookie-store"><code>db-cookie-store</code></a>: SQL including SQLite-based databases</li>
<li><a href="https://github.com/JSBizon/file-cookie-store"><code>file-cookie-store</code></a>: Netscape cookie file format on disk</li>
<li><a href="https://github.com/benkroeger/redis-cookie-store"><code>redis-cookie-store</code></a>: Redis</li>
<li><a href="https://github.com/mitsuru/tough-cookie-filestore"><code>tough-cookie-filestore</code></a>: JSON on disk</li>
<li><a href="https://github.com/exponentjs/tough-cookie-web-storage-store"><code>tough-cookie-web-storage-store</code></a>: DOM localStorage and sessionStorage</li>
</ul>
<h1>Serialization Format</h1>
<p><b>NOTE</b>: if you want to have custom <code>Cookie</code> properties serialized, add the property name to <code>Cookie.serializableProperties</code>.</p>
<div class="fragment"><div class="line">{</div><div class="line">  // The version of tough-cookie that serialized this jar.</div><div class="line">  version: &#39;tough-cookie@1.x.y&#39;,</div><div class="line"></div><div class="line">  // add the store type, to make humans happy:</div><div class="line">  storeType: &#39;MemoryCookieStore&#39;,</div><div class="line"></div><div class="line">  // CookieJar configuration:</div><div class="line">  rejectPublicSuffixes: true,</div><div class="line">  // ... future items go here</div><div class="line"></div><div class="line">  // Gets filled from jar.store.getAllCookies():</div><div class="line">  cookies: [</div><div class="line">    {</div><div class="line">      key: &#39;string&#39;,</div><div class="line">      value: &#39;string&#39;,</div><div class="line">      // ...</div><div class="line">      /* other Cookie.serializableProperties go here */</div><div class="line">    }</div><div class="line">  ]</div><div class="line">}</div></div><!-- fragment --><h1>Copyright and License</h1>
<p>(tl;dr: BSD-3-Clause with some MPL/2.0)</p>
<div class="fragment"><div class="line">Copyright (c) 2015, Salesforce.com, Inc.</div><div class="line">All rights reserved.</div><div class="line"></div><div class="line">Redistribution and use in source and binary forms, with or without</div><div class="line">modification, are permitted provided that the following conditions are met:</div><div class="line"></div><div class="line">1. Redistributions of source code must retain the above copyright notice,</div><div class="line">this list of conditions and the following disclaimer.</div><div class="line"></div><div class="line">2. Redistributions in binary form must reproduce the above copyright notice,</div><div class="line">this list of conditions and the following disclaimer in the documentation</div><div class="line">and/or other materials provided with the distribution.</div><div class="line"></div><div class="line">3. Neither the name of Salesforce.com nor the names of its contributors may</div><div class="line">be used to endorse or promote products derived from this software without</div><div class="line">specific prior written permission.</div><div class="line"></div><div class="line">THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;</div><div class="line">AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE</div><div class="line">IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE</div><div class="line">ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE</div><div class="line">LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR</div><div class="line">CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF</div><div class="line">SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS</div><div class="line">INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN</div><div class="line">CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)</div><div class="line">ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE</div><div class="line">POSSIBILITY OF SUCH DAMAGE.</div></div><!-- fragment --> </div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
