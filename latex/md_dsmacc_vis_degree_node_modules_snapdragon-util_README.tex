{\bfseries Table of Contents}

\begin{quote}
Utilities for the snapdragon parser/compiler. \end{quote}


$<$details$>$


\begin{DoxyItemize}
\item \href{#install}{\tt Install}
\item \href{#usage}{\tt Usage}
\item \href{#api}{\tt A\+PI}
\item \href{#release-history}{\tt Release history}
\begin{DoxyItemize}
\item \href{#300---2017-05-01}{\tt \mbox{[}3.\+0.\+0\mbox{]} -\/ 2017-\/05-\/01}
\item \href{#010}{\tt \mbox{[}0.\+1.\+0\mbox{]}}
\end{DoxyItemize}
\item \href{#about}{\tt About}
\end{DoxyItemize}

$<$/details$>$

\subsection*{Install}

Install with \href{https://www.npmjs.com/}{\tt npm}\+:


\begin{DoxyCode}
$ npm install --save snapdragon-util
\end{DoxyCode}


Install with \href{https://yarnpkg.com}{\tt yarn}\+:


\begin{DoxyCode}
$ yarn add snapdragon-util
\end{DoxyCode}


\subsection*{Usage}


\begin{DoxyCode}
var util = require('snapdragon-util');
\end{DoxyCode}


\subsection*{A\+PI}

\subsubsection*{\href{index.js#L21}{\tt .is\+Node}}

Returns true if the given value is a node.

{\bfseries Params}


\begin{DoxyItemize}
\item {\ttfamily node} $\ast$$\ast$\{Object\}$\ast$$\ast$\+: Instance of \href{https://github.com/jonschlinkert/snapdragon-node}{\tt snapdragon-\/node}
\item {\ttfamily returns} $\ast$$\ast$\{Boolean\}$\ast$$\ast$
\end{DoxyItemize}

{\bfseries Example}


\begin{DoxyCode}
var Node = require('snapdragon-node');
var node = new Node(\{type: 'foo'\});
console.log(utils.isNode(node)); //=> true
console.log(utils.isNode(\{\})); //=> false
\end{DoxyCode}


\subsubsection*{\href{index.js#L37}{\tt .noop}}

Emit an empty string for the given {\ttfamily node}.

{\bfseries Params}


\begin{DoxyItemize}
\item {\ttfamily node} $\ast$$\ast$\{Object\}$\ast$$\ast$\+: Instance of \href{https://github.com/jonschlinkert/snapdragon-node}{\tt snapdragon-\/node}
\item {\ttfamily returns} $\ast$$\ast$\{undefined\}$\ast$$\ast$
\end{DoxyItemize}

{\bfseries Example}


\begin{DoxyCode}
// do nothing for beginning-of-string
snapdragon.compiler.set('bos', utils.noop);
\end{DoxyCode}


\subsubsection*{\href{index.js#L53}{\tt .identity}}

Appdend {\ttfamily node.\+val} to {\ttfamily compiler.\+output}, exactly as it was created by the parser.

{\bfseries Params}


\begin{DoxyItemize}
\item {\ttfamily node} $\ast$$\ast$\{Object\}$\ast$$\ast$\+: Instance of \href{https://github.com/jonschlinkert/snapdragon-node}{\tt snapdragon-\/node}
\item {\ttfamily returns} $\ast$$\ast$\{undefined\}$\ast$$\ast$
\end{DoxyItemize}

{\bfseries Example}


\begin{DoxyCode}
snapdragon.compiler.set('text', utils.identity);
\end{DoxyCode}


\subsubsection*{\href{index.js#L76}{\tt .append}}

Previously named {\ttfamily .emit}, this method appends the given {\ttfamily val} to {\ttfamily compiler.\+output} for the given node. Useful when you know what value should be appended advance, regardless of the actual value of {\ttfamily node.\+val}.

{\bfseries Params}


\begin{DoxyItemize}
\item {\ttfamily node} $\ast$$\ast$\{Object\}$\ast$$\ast$\+: Instance of \href{https://github.com/jonschlinkert/snapdragon-node}{\tt snapdragon-\/node}
\item {\ttfamily returns} $\ast$$\ast$\{Function\}$\ast$$\ast$\+: Returns a compiler middleware function.
\end{DoxyItemize}

{\bfseries Example}


\begin{DoxyCode}
snapdragon.compiler
  .set('i', function(node) \{
    this.mapVisit(node);
  \})
  .set('i.open', utils.append('<i>'))
  .set('i.close', utils.append('</i>'))
\end{DoxyCode}


\subsubsection*{\href{index.js#L99}{\tt .to\+Noop}}

Used in compiler middleware, this onverts an A\+ST node into an empty {\ttfamily text} node and deletes {\ttfamily node.\+nodes} if it exists. The advantage of this method is that, as opposed to completely removing the node, indices will not need to be re-\/calculated in sibling nodes, and nothing is appended to the output.

{\bfseries Params}


\begin{DoxyItemize}
\item {\ttfamily node} $\ast$$\ast$\{Object\}$\ast$$\ast$\+: Instance of \href{https://github.com/jonschlinkert/snapdragon-node}{\tt snapdragon-\/node}
\item {\ttfamily nodes} $\ast$$\ast$\{Array\}$\ast$$\ast$\+: Optionally pass a new {\ttfamily nodes} value, to replace the existing {\ttfamily node.\+nodes} array.
\end{DoxyItemize}

{\bfseries Example}


\begin{DoxyCode}
utils.toNoop(node);
// convert `node.nodes` to the given value instead of deleting it
utils.toNoop(node, []);
\end{DoxyCode}


\subsubsection*{\href{index.js#L128}{\tt .visit}}

Visit {\ttfamily node} with the given {\ttfamily fn}. The built-\/in {\ttfamily .visit} method in snapdragon automatically calls registered compilers, this allows you to pass a visitor function.

{\bfseries Params}


\begin{DoxyItemize}
\item {\ttfamily node} $\ast$$\ast$\{Object\}$\ast$$\ast$\+: Instance of \href{https://github.com/jonschlinkert/snapdragon-node}{\tt snapdragon-\/node}
\item {\ttfamily fn} $\ast$$\ast$\{Function\}$\ast$$\ast$
\item {\ttfamily returns} $\ast$$\ast$\{Object\}$\ast$$\ast$\+: returns the node after recursively visiting all child nodes.
\end{DoxyItemize}

{\bfseries Example}


\begin{DoxyCode}
snapdragon.compiler.set('i', function(node) \{
  utils.visit(node, function(childNode) \{
    // do stuff with "childNode"
    return childNode;
  \});
\});
\end{DoxyCode}


\subsubsection*{\href{index.js#L155}{\tt .map\+Visit}}

Map \href{#visit}{\tt visit} the given {\ttfamily fn} over {\ttfamily node.\+nodes}. This is called by \href{#visit}{\tt visit}, use this method if you do not want {\ttfamily fn} to be called on the first node.

{\bfseries Params}


\begin{DoxyItemize}
\item {\ttfamily node} $\ast$$\ast$\{Object\}$\ast$$\ast$\+: Instance of \href{https://github.com/jonschlinkert/snapdragon-node}{\tt snapdragon-\/node}
\item {\ttfamily options} $\ast$$\ast$\{Object\}$\ast$$\ast$
\item {\ttfamily fn} $\ast$$\ast$\{Function\}$\ast$$\ast$
\item {\ttfamily returns} $\ast$$\ast$\{Object\}$\ast$$\ast$\+: returns the node
\end{DoxyItemize}

{\bfseries Example}


\begin{DoxyCode}
snapdragon.compiler.set('i', function(node) \{
  utils.mapVisit(node, function(childNode) \{
    // do stuff with "childNode"
    return childNode;
  \});
\});
\end{DoxyCode}


\subsubsection*{\href{index.js#L194}{\tt .add\+Open}}

Unshift an {\ttfamily $\ast$.open} node onto {\ttfamily node.\+nodes}.

{\bfseries Params}


\begin{DoxyItemize}
\item {\ttfamily node} $\ast$$\ast$\{Object\}$\ast$$\ast$\+: Instance of \href{https://github.com/jonschlinkert/snapdragon-node}{\tt snapdragon-\/node}
\item {\ttfamily \mbox{\hyperlink{classNode}{Node}}} $\ast$$\ast$\{Function\}$\ast$$\ast$\+: (required) \mbox{\hyperlink{classNode}{Node}} constructor function from \href{https://github.com/jonschlinkert/snapdragon-node}{\tt snapdragon-\/node}.
\item {\ttfamily filter} $\ast$$\ast$\{Function\}$\ast$$\ast$\+: Optionaly specify a filter function to exclude the node.
\item {\ttfamily returns} $\ast$$\ast$\{Object\}$\ast$$\ast$\+: Returns the created opening node.
\end{DoxyItemize}

{\bfseries Example}


\begin{DoxyCode}
var Node = require('snapdragon-node');
snapdragon.parser.set('brace', function(node) \{
  var match = this.match(/^\{/);
  if (match) \{
    var parent = new Node(\{type: 'brace'\});
    utils.addOpen(parent, Node);
    console.log(parent.nodes[0]):
    // \{ type: 'brace.open', val: '' \};

    // push the parent "brace" node onto the stack
    this.push(parent);

    // return the parent node, so it's also added to the AST
    return brace;
  \}
\});
\end{DoxyCode}


\subsubsection*{\href{index.js#L244}{\tt .add\+Close}}

Push a {\ttfamily $\ast$.close} node onto {\ttfamily node.\+nodes}.

{\bfseries Params}


\begin{DoxyItemize}
\item {\ttfamily node} $\ast$$\ast$\{Object\}$\ast$$\ast$\+: Instance of \href{https://github.com/jonschlinkert/snapdragon-node}{\tt snapdragon-\/node}
\item {\ttfamily \mbox{\hyperlink{classNode}{Node}}} $\ast$$\ast$\{Function\}$\ast$$\ast$\+: (required) \mbox{\hyperlink{classNode}{Node}} constructor function from \href{https://github.com/jonschlinkert/snapdragon-node}{\tt snapdragon-\/node}.
\item {\ttfamily filter} $\ast$$\ast$\{Function\}$\ast$$\ast$\+: Optionaly specify a filter function to exclude the node.
\item {\ttfamily returns} $\ast$$\ast$\{Object\}$\ast$$\ast$\+: Returns the created closing node.
\end{DoxyItemize}

{\bfseries Example}


\begin{DoxyCode}
var Node = require('snapdragon-node');
snapdragon.parser.set('brace', function(node) \{
  var match = this.match(/^\}/);
  if (match) \{
    var parent = this.parent();
    if (parent.type !== 'brace') \{
      throw new Error('missing opening: ' + '\}');
    \}

    utils.addClose(parent, Node);
    console.log(parent.nodes[parent.nodes.length - 1]):
    // \{ type: 'brace.close', val: '' \};

    // no need to return a node, since the parent
    // was already added to the AST
    return;
  \}
\});
\end{DoxyCode}


\subsubsection*{\href{index.js#L274}{\tt .wrap\+Nodes}}

Wraps the given {\ttfamily node} with {\ttfamily $\ast$.open} and {\ttfamily $\ast$.close} nodes.

{\bfseries Params}


\begin{DoxyItemize}
\item {\ttfamily node} $\ast$$\ast$\{Object\}$\ast$$\ast$\+: Instance of \href{https://github.com/jonschlinkert/snapdragon-node}{\tt snapdragon-\/node}
\item {\ttfamily \mbox{\hyperlink{classNode}{Node}}} $\ast$$\ast$\{Function\}$\ast$$\ast$\+: (required) \mbox{\hyperlink{classNode}{Node}} constructor function from \href{https://github.com/jonschlinkert/snapdragon-node}{\tt snapdragon-\/node}.
\item {\ttfamily filter} $\ast$$\ast$\{Function\}$\ast$$\ast$\+: Optionaly specify a filter function to exclude the node.
\item {\ttfamily returns} $\ast$$\ast$\{Object\}$\ast$$\ast$\+: Returns the node
\end{DoxyItemize}

\subsubsection*{\href{index.js#L299}{\tt .push\+Node}}

Push the given {\ttfamily node} onto {\ttfamily parent.\+nodes}, and set {\ttfamily parent} as \`{}node.parent.

{\bfseries Params}


\begin{DoxyItemize}
\item {\ttfamily parent} $\ast$$\ast$\{Object\}$\ast$$\ast$
\item {\ttfamily node} $\ast$$\ast$\{Object\}$\ast$$\ast$\+: Instance of \href{https://github.com/jonschlinkert/snapdragon-node}{\tt snapdragon-\/node}
\item {\ttfamily returns} $\ast$$\ast$\{Object\}$\ast$$\ast$\+: Returns the child node
\end{DoxyItemize}

{\bfseries Example}


\begin{DoxyCode}
var parent = new Node(\{type: 'foo'\});
var node = new Node(\{type: 'bar'\});
utils.pushNode(parent, node);
console.log(parent.nodes[0].type) // 'bar'
console.log(node.parent.type) // 'foo'
\end{DoxyCode}


\subsubsection*{\href{index.js#L325}{\tt .unshift\+Node}}

Unshift {\ttfamily node} onto {\ttfamily parent.\+nodes}, and set {\ttfamily parent} as \`{}node.parent.

{\bfseries Params}


\begin{DoxyItemize}
\item {\ttfamily parent} $\ast$$\ast$\{Object\}$\ast$$\ast$
\item {\ttfamily node} $\ast$$\ast$\{Object\}$\ast$$\ast$\+: Instance of \href{https://github.com/jonschlinkert/snapdragon-node}{\tt snapdragon-\/node}
\item {\ttfamily returns} $\ast$$\ast$\{undefined\}$\ast$$\ast$
\end{DoxyItemize}

{\bfseries Example}


\begin{DoxyCode}
var parent = new Node(\{type: 'foo'\});
var node = new Node(\{type: 'bar'\});
utils.unshiftNode(parent, node);
console.log(parent.nodes[0].type) // 'bar'
console.log(node.parent.type) // 'foo'
\end{DoxyCode}


\subsubsection*{\href{index.js#L354}{\tt .pop\+Node}}

Pop the last {\ttfamily node} off of {\ttfamily parent.\+nodes}. The advantage of using this method is that it checks for {\ttfamily node.\+nodes} and works with any version of {\ttfamily snapdragon-\/node}.

{\bfseries Params}


\begin{DoxyItemize}
\item {\ttfamily parent} $\ast$$\ast$\{Object\}$\ast$$\ast$
\item {\ttfamily node} $\ast$$\ast$\{Object\}$\ast$$\ast$\+: Instance of \href{https://github.com/jonschlinkert/snapdragon-node}{\tt snapdragon-\/node}
\item {\ttfamily returns} $\ast$$\ast$\{Number$\vert$\+Undefined\}$\ast$$\ast$\+: Returns the length of {\ttfamily node.\+nodes} or undefined.
\end{DoxyItemize}

{\bfseries Example}


\begin{DoxyCode}
var parent = new Node(\{type: 'foo'\});
utils.pushNode(parent, new Node(\{type: 'foo'\}));
utils.pushNode(parent, new Node(\{type: 'bar'\}));
utils.pushNode(parent, new Node(\{type: 'baz'\}));
console.log(parent.nodes.length); //=> 3
utils.popNode(parent);
console.log(parent.nodes.length); //=> 2
\end{DoxyCode}


\subsubsection*{\href{index.js#L382}{\tt .shift\+Node}}

Shift the first {\ttfamily node} off of {\ttfamily parent.\+nodes}. The advantage of using this method is that it checks for {\ttfamily node.\+nodes} and works with any version of {\ttfamily snapdragon-\/node}.

{\bfseries Params}


\begin{DoxyItemize}
\item {\ttfamily parent} $\ast$$\ast$\{Object\}$\ast$$\ast$
\item {\ttfamily node} $\ast$$\ast$\{Object\}$\ast$$\ast$\+: Instance of \href{https://github.com/jonschlinkert/snapdragon-node}{\tt snapdragon-\/node}
\item {\ttfamily returns} $\ast$$\ast$\{Number$\vert$\+Undefined\}$\ast$$\ast$\+: Returns the length of {\ttfamily node.\+nodes} or undefined.
\end{DoxyItemize}

{\bfseries Example}


\begin{DoxyCode}
var parent = new Node(\{type: 'foo'\});
utils.pushNode(parent, new Node(\{type: 'foo'\}));
utils.pushNode(parent, new Node(\{type: 'bar'\}));
utils.pushNode(parent, new Node(\{type: 'baz'\}));
console.log(parent.nodes.length); //=> 3
utils.shiftNode(parent);
console.log(parent.nodes.length); //=> 2
\end{DoxyCode}


\subsubsection*{\href{index.js#L409}{\tt .remove\+Node}}

Remove the specified {\ttfamily node} from {\ttfamily parent.\+nodes}.

{\bfseries Params}


\begin{DoxyItemize}
\item {\ttfamily parent} $\ast$$\ast$\{Object\}$\ast$$\ast$
\item {\ttfamily node} $\ast$$\ast$\{Object\}$\ast$$\ast$\+: Instance of \href{https://github.com/jonschlinkert/snapdragon-node}{\tt snapdragon-\/node}
\item {\ttfamily returns} $\ast$$\ast$\{Object$\vert$undefined\}$\ast$$\ast$\+: Returns the removed node, if successful, or undefined if it does not exist on {\ttfamily parent.\+nodes}.
\end{DoxyItemize}

{\bfseries Example}


\begin{DoxyCode}
var parent = new Node(\{type: 'abc'\});
var foo = new Node(\{type: 'foo'\});
utils.pushNode(parent, foo);
utils.pushNode(parent, new Node(\{type: 'bar'\}));
utils.pushNode(parent, new Node(\{type: 'baz'\}));
console.log(parent.nodes.length); //=> 3
utils.removeNode(parent, foo);
console.log(parent.nodes.length); //=> 2
\end{DoxyCode}


\subsubsection*{\href{index.js#L443}{\tt .is\+Type}}

Returns true if {\ttfamily node.\+type} matches the given {\ttfamily type}. Throws a {\ttfamily Type\+Error} if {\ttfamily node} is not an instance of {\ttfamily \mbox{\hyperlink{classNode}{Node}}}.

{\bfseries Params}


\begin{DoxyItemize}
\item {\ttfamily node} $\ast$$\ast$\{Object\}$\ast$$\ast$\+: Instance of \href{https://github.com/jonschlinkert/snapdragon-node}{\tt snapdragon-\/node}
\item {\ttfamily type} $\ast$$\ast$\{String\}$\ast$$\ast$
\item {\ttfamily returns} $\ast$$\ast$\{Boolean\}$\ast$$\ast$
\end{DoxyItemize}

{\bfseries Example}


\begin{DoxyCode}
var Node = require('snapdragon-node');
var node = new Node(\{type: 'foo'\});
console.log(utils.isType(node, 'foo')); // false
console.log(utils.isType(node, 'bar')); // true
\end{DoxyCode}


\subsubsection*{\href{index.js#L486}{\tt .has\+Type}}

Returns true if the given {\ttfamily node} has the given {\ttfamily type} in {\ttfamily node.\+nodes}. Throws a {\ttfamily Type\+Error} if {\ttfamily node} is not an instance of {\ttfamily \mbox{\hyperlink{classNode}{Node}}}.

{\bfseries Params}


\begin{DoxyItemize}
\item {\ttfamily node} $\ast$$\ast$\{Object\}$\ast$$\ast$\+: Instance of \href{https://github.com/jonschlinkert/snapdragon-node}{\tt snapdragon-\/node}
\item {\ttfamily type} $\ast$$\ast$\{String\}$\ast$$\ast$
\item {\ttfamily returns} $\ast$$\ast$\{Boolean\}$\ast$$\ast$
\end{DoxyItemize}

{\bfseries Example}


\begin{DoxyCode}
var Node = require('snapdragon-node');
var node = new Node(\{
  type: 'foo',
  nodes: [
    new Node(\{type: 'bar'\}),
    new Node(\{type: 'baz'\})
  ]
\});
console.log(utils.hasType(node, 'xyz')); // false
console.log(utils.hasType(node, 'baz')); // true
\end{DoxyCode}


\subsubsection*{\href{index.js#L519}{\tt .first\+Of\+Type}}

Returns the first node from {\ttfamily node.\+nodes} of the given {\ttfamily type}

{\bfseries Params}


\begin{DoxyItemize}
\item {\ttfamily nodes} $\ast$$\ast$\{Array\}$\ast$$\ast$
\item {\ttfamily type} $\ast$$\ast$\{String\}$\ast$$\ast$
\item {\ttfamily returns} $\ast$$\ast$\{Object$\vert$undefined\}$\ast$$\ast$\+: Returns the first matching node or undefined.
\end{DoxyItemize}

{\bfseries Example}


\begin{DoxyCode}
var node = new Node(\{
  type: 'foo',
  nodes: [
    new Node(\{type: 'text', val: 'abc'\}),
    new Node(\{type: 'text', val: 'xyz'\})
  ]
\});

var textNode = utils.firstOfType(node.nodes, 'text');
console.log(textNode.val);
//=> 'abc'
\end{DoxyCode}


\subsubsection*{\href{index.js#L556}{\tt .find\+Node}}

Returns the node at the specified index, or the first node of the given {\ttfamily type} from {\ttfamily node.\+nodes}.

{\bfseries Params}


\begin{DoxyItemize}
\item {\ttfamily nodes} $\ast$$\ast$\{Array\}$\ast$$\ast$
\item {\ttfamily type} $\ast$$\ast$\{String$\vert$\+Number\}$\ast$$\ast$\+: \mbox{\hyperlink{classNode}{Node}} type or index.
\item {\ttfamily returns} $\ast$$\ast$\{Object\}$\ast$$\ast$\+: Returns a node or undefined.
\end{DoxyItemize}

{\bfseries Example}


\begin{DoxyCode}
var node = new Node(\{
  type: 'foo',
  nodes: [
    new Node(\{type: 'text', val: 'abc'\}),
    new Node(\{type: 'text', val: 'xyz'\})
  ]
\});

var nodeOne = utils.findNode(node.nodes, 'text');
console.log(nodeOne.val);
//=> 'abc'

var nodeTwo = utils.findNode(node.nodes, 1);
console.log(nodeTwo.val);
//=> 'xyz'
\end{DoxyCode}


\subsubsection*{\href{index.js#L584}{\tt .is\+Open}}

Returns true if the given node is an \char`\"{}$\ast$.\+open\char`\"{} node.

{\bfseries Params}


\begin{DoxyItemize}
\item {\ttfamily node} $\ast$$\ast$\{Object\}$\ast$$\ast$\+: Instance of \href{https://github.com/jonschlinkert/snapdragon-node}{\tt snapdragon-\/node}
\item {\ttfamily returns} $\ast$$\ast$\{Boolean\}$\ast$$\ast$
\end{DoxyItemize}

{\bfseries Example}


\begin{DoxyCode}
var Node = require('snapdragon-node');
var brace = new Node(\{type: 'brace'\});
var open = new Node(\{type: 'brace.open'\});
var close = new Node(\{type: 'brace.close'\});

console.log(utils.isOpen(brace)); // false
console.log(utils.isOpen(open)); // true
console.log(utils.isOpen(close)); // false
\end{DoxyCode}


\subsubsection*{\href{index.js#L607}{\tt .is\+Close}}

Returns true if the given node is a \char`\"{}$\ast$.\+close\char`\"{} node.

{\bfseries Params}


\begin{DoxyItemize}
\item {\ttfamily node} $\ast$$\ast$\{Object\}$\ast$$\ast$\+: Instance of \href{https://github.com/jonschlinkert/snapdragon-node}{\tt snapdragon-\/node}
\item {\ttfamily returns} $\ast$$\ast$\{Boolean\}$\ast$$\ast$
\end{DoxyItemize}

{\bfseries Example}


\begin{DoxyCode}
var Node = require('snapdragon-node');
var brace = new Node(\{type: 'brace'\});
var open = new Node(\{type: 'brace.open'\});
var close = new Node(\{type: 'brace.close'\});

console.log(utils.isClose(brace)); // false
console.log(utils.isClose(open)); // false
console.log(utils.isClose(close)); // true
\end{DoxyCode}


\subsubsection*{\href{index.js#L633}{\tt .has\+Open}}

Returns true if {\ttfamily node.\+nodes} {\bfseries has} an {\ttfamily .open} node

{\bfseries Params}


\begin{DoxyItemize}
\item {\ttfamily node} $\ast$$\ast$\{Object\}$\ast$$\ast$\+: Instance of \href{https://github.com/jonschlinkert/snapdragon-node}{\tt snapdragon-\/node}
\item {\ttfamily returns} $\ast$$\ast$\{Boolean\}$\ast$$\ast$
\end{DoxyItemize}

{\bfseries Example}


\begin{DoxyCode}
var Node = require('snapdragon-node');
var brace = new Node(\{
  type: 'brace',
  nodes: []
\});

var open = new Node(\{type: 'brace.open'\});
console.log(utils.hasOpen(brace)); // false

brace.pushNode(open);
console.log(utils.hasOpen(brace)); // true
\end{DoxyCode}


\subsubsection*{\href{index.js#L663}{\tt .has\+Close}}

Returns true if {\ttfamily node.\+nodes} {\bfseries has} a {\ttfamily .close} node

{\bfseries Params}


\begin{DoxyItemize}
\item {\ttfamily node} $\ast$$\ast$\{Object\}$\ast$$\ast$\+: Instance of \href{https://github.com/jonschlinkert/snapdragon-node}{\tt snapdragon-\/node}
\item {\ttfamily returns} $\ast$$\ast$\{Boolean\}$\ast$$\ast$
\end{DoxyItemize}

{\bfseries Example}


\begin{DoxyCode}
var Node = require('snapdragon-node');
var brace = new Node(\{
  type: 'brace',
  nodes: []
\});

var close = new Node(\{type: 'brace.close'\});
console.log(utils.hasClose(brace)); // false

brace.pushNode(close);
console.log(utils.hasClose(brace)); // true
\end{DoxyCode}


\subsubsection*{\href{index.js#L697}{\tt .has\+Open\+And\+Close}}

Returns true if {\ttfamily node.\+nodes} has both {\ttfamily .open} and {\ttfamily .close} nodes

{\bfseries Params}


\begin{DoxyItemize}
\item {\ttfamily node} $\ast$$\ast$\{Object\}$\ast$$\ast$\+: Instance of \href{https://github.com/jonschlinkert/snapdragon-node}{\tt snapdragon-\/node}
\item {\ttfamily returns} $\ast$$\ast$\{Boolean\}$\ast$$\ast$
\end{DoxyItemize}

{\bfseries Example}


\begin{DoxyCode}
var Node = require('snapdragon-node');
var brace = new Node(\{
  type: 'brace',
  nodes: []
\});

var open = new Node(\{type: 'brace.open'\});
var close = new Node(\{type: 'brace.close'\});
console.log(utils.hasOpen(brace)); // false
console.log(utils.hasClose(brace)); // false

brace.pushNode(open);
brace.pushNode(close);
console.log(utils.hasOpen(brace)); // true
console.log(utils.hasClose(brace)); // true
\end{DoxyCode}


\subsubsection*{\href{index.js#L719}{\tt .add\+Type}}

Push the given {\ttfamily node} onto the {\ttfamily state.\+inside} array for the given type. This array is used as a specialized \char`\"{}stack\char`\"{} for only the given {\ttfamily node.\+type}.

{\bfseries Params}


\begin{DoxyItemize}
\item {\ttfamily state} $\ast$$\ast$\{Object\}$\ast$$\ast$\+: The {\ttfamily compiler.\+state} object or custom state object.
\item {\ttfamily node} $\ast$$\ast$\{Object\}$\ast$$\ast$\+: Instance of \href{https://github.com/jonschlinkert/snapdragon-node}{\tt snapdragon-\/node}
\item {\ttfamily returns} $\ast$$\ast$\{Array\}$\ast$$\ast$\+: Returns the {\ttfamily state.\+inside} stack for the given type.
\end{DoxyItemize}

{\bfseries Example}


\begin{DoxyCode}
var state = \{ inside: \{\}\};
var node = new Node(\{type: 'brace'\});
utils.addType(state, node);
console.log(state.inside);
//=> \{ brace: [\{type: 'brace'\}] \}
\end{DoxyCode}


\subsubsection*{\href{index.js#L759}{\tt .remove\+Type}}

Remove the given {\ttfamily node} from the {\ttfamily state.\+inside} array for the given type. This array is used as a specialized \char`\"{}stack\char`\"{} for only the given {\ttfamily node.\+type}.

{\bfseries Params}


\begin{DoxyItemize}
\item {\ttfamily state} $\ast$$\ast$\{Object\}$\ast$$\ast$\+: The {\ttfamily compiler.\+state} object or custom state object.
\item {\ttfamily node} $\ast$$\ast$\{Object\}$\ast$$\ast$\+: Instance of \href{https://github.com/jonschlinkert/snapdragon-node}{\tt snapdragon-\/node}
\item {\ttfamily returns} $\ast$$\ast$\{Array\}$\ast$$\ast$\+: Returns the {\ttfamily state.\+inside} stack for the given type.
\end{DoxyItemize}

{\bfseries Example}


\begin{DoxyCode}
var state = \{ inside: \{\}\};
var node = new Node(\{type: 'brace'\});
utils.addType(state, node);
console.log(state.inside);
//=> \{ brace: [\{type: 'brace'\}] \}
utils.removeType(state, node);
//=> \{ brace: [] \}
\end{DoxyCode}


\subsubsection*{\href{index.js#L788}{\tt .is\+Empty}}

Returns true if {\ttfamily node.\+val} is an empty string, or {\ttfamily node.\+nodes} does not contain any non-\/empty text nodes.

{\bfseries Params}


\begin{DoxyItemize}
\item {\ttfamily node} $\ast$$\ast$\{Object\}$\ast$$\ast$\+: Instance of \href{https://github.com/jonschlinkert/snapdragon-node}{\tt snapdragon-\/node}
\item {\ttfamily fn} $\ast$$\ast$\{Function\}$\ast$$\ast$
\item {\ttfamily returns} $\ast$$\ast$\{Boolean\}$\ast$$\ast$
\end{DoxyItemize}

{\bfseries Example}


\begin{DoxyCode}
var node = new Node(\{type: 'text'\});
utils.isEmpty(node); //=> true
node.val = 'foo';
utils.isEmpty(node); //=> false
\end{DoxyCode}


\subsubsection*{\href{index.js#L833}{\tt .is\+Inside\+Type}}

Returns true if the {\ttfamily state.\+inside} stack for the given type exists and has one or more nodes on it.

{\bfseries Params}


\begin{DoxyItemize}
\item {\ttfamily state} $\ast$$\ast$\{Object\}$\ast$$\ast$
\item {\ttfamily type} $\ast$$\ast$\{String\}$\ast$$\ast$
\item {\ttfamily returns} $\ast$$\ast$\{Boolean\}$\ast$$\ast$
\end{DoxyItemize}

{\bfseries Example}


\begin{DoxyCode}
var state = \{ inside: \{\}\};
var node = new Node(\{type: 'brace'\});
console.log(utils.isInsideType(state, 'brace')); //=> false
utils.addType(state, node);
console.log(utils.isInsideType(state, 'brace')); //=> true
utils.removeType(state, node);
console.log(utils.isInsideType(state, 'brace')); //=> false
\end{DoxyCode}


\subsubsection*{\href{index.js#L867}{\tt .is\+Inside}}

Returns true if {\ttfamily node} is either a child or grand-\/child of the given {\ttfamily type}, or {\ttfamily state.\+inside\mbox{[}type\mbox{]}} is a non-\/empty array.

{\bfseries Params}


\begin{DoxyItemize}
\item {\ttfamily state} $\ast$$\ast$\{Object\}$\ast$$\ast$\+: Either the {\ttfamily compiler.\+state} object, if it exists, or a user-\/supplied state object.
\item {\ttfamily node} $\ast$$\ast$\{Object\}$\ast$$\ast$\+: Instance of \href{https://github.com/jonschlinkert/snapdragon-node}{\tt snapdragon-\/node}
\item {\ttfamily type} $\ast$$\ast$\{String\}$\ast$$\ast$\+: The {\ttfamily node.\+type} to check for.
\item {\ttfamily returns} $\ast$$\ast$\{Boolean\}$\ast$$\ast$
\end{DoxyItemize}

{\bfseries Example}


\begin{DoxyCode}
var state = \{ inside: \{\}\};
var node = new Node(\{type: 'brace'\});
var open = new Node(\{type: 'brace.open'\});
console.log(utils.isInside(state, open, 'brace')); //=> false
utils.pushNode(node, open);
console.log(utils.isInside(state, open, 'brace')); //=> true
\end{DoxyCode}


\subsubsection*{\href{index.js#L915}{\tt .last}}

Get the last {\ttfamily n} element from the given {\ttfamily array}. Used for getting a node from {\ttfamily node.\+nodes.}

{\bfseries Params}


\begin{DoxyItemize}
\item {\ttfamily array} $\ast$$\ast$\{Array\}$\ast$$\ast$
\item {\ttfamily n} $\ast$$\ast$\{Number\}$\ast$$\ast$
\item {\ttfamily returns} $\ast$$\ast$\{undefined\}$\ast$$\ast$
\end{DoxyItemize}

\subsubsection*{\href{index.js#L935}{\tt .arrayify}}

Cast the given {\ttfamily val} to an array.

{\bfseries Params}


\begin{DoxyItemize}
\item {\ttfamily val} $\ast$$\ast$\{any\}$\ast$$\ast$
\item {\ttfamily returns} $\ast$$\ast$\{Array\}$\ast$$\ast$
\end{DoxyItemize}

{\bfseries Example}


\begin{DoxyCode}
console.log(utils.arraify(''));
//=> []
console.log(utils.arraify('foo'));
//=> ['foo']
console.log(utils.arraify(['foo']));
//=> ['foo']
\end{DoxyCode}


\subsubsection*{\href{index.js#L948}{\tt .stringify}}

Convert the given {\ttfamily val} to a string by joining with {\ttfamily ,}. Useful for creating a cheerio/\+C\+S\+S/\+D\+O\+M-\/style selector from a list of strings.

{\bfseries Params}


\begin{DoxyItemize}
\item {\ttfamily val} $\ast$$\ast$\{any\}$\ast$$\ast$
\item {\ttfamily returns} $\ast$$\ast$\{Array\}$\ast$$\ast$
\end{DoxyItemize}

\subsubsection*{\href{index.js#L961}{\tt .trim}}

Ensure that the given value is a string and call {\ttfamily .trim()} on it, or return an empty string.

{\bfseries Params}


\begin{DoxyItemize}
\item {\ttfamily str} $\ast$$\ast$\{String\}$\ast$$\ast$
\item {\ttfamily returns} $\ast$$\ast$\{String\}$\ast$$\ast$
\end{DoxyItemize}

\subsection*{Release history}

Changelog entries are classified using the following labels from \href{https://github.com/olivierlacan/keep-a-changelog}{\tt keep-\/a-\/changelog}\+:


\begin{DoxyItemize}
\item {\ttfamily added}\+: for new features
\item {\ttfamily changed}\+: for changes in existing functionality
\item {\ttfamily deprecated}\+: for once-\/stable features removed in upcoming releases
\item {\ttfamily removed}\+: for deprecated features removed in this release
\item {\ttfamily fixed}\+: for any bug fixes
\end{DoxyItemize}

Custom labels used in this changelog\+:


\begin{DoxyItemize}
\item {\ttfamily dependencies}\+: bumps dependencies
\item {\ttfamily housekeeping}\+: code re-\/organization, minor edits, or other changes that don\textquotesingle{}t fit in one of the other categories.
\end{DoxyItemize}

\subsubsection*{\mbox{[}3.\+0.\+0\mbox{]} -\/ 2017-\/05-\/01}

{\bfseries Changed}


\begin{DoxyItemize}
\item {\ttfamily .emit} was renamed to \href{#append}{\tt .append}
\item {\ttfamily .add\+Node} was renamed to \href{#pushNode}{\tt .push\+Node}
\item {\ttfamily .get\+Node} was renamed to \href{#findNode}{\tt .find\+Node}
\item {\ttfamily .is\+Empty\+Nodes} was renamed to \href{#isEmpty}{\tt .is\+Empty}\+: also now works with {\ttfamily node.\+nodes} and/or {\ttfamily node.\+val}
\end{DoxyItemize}

{\bfseries Added}


\begin{DoxyItemize}
\item \href{#identity}{\tt .identity}
\item \href{#removeNode}{\tt .remove\+Node}
\item \href{#shiftNode}{\tt .shift\+Node}
\item \href{#popNode}{\tt .pop\+Node}
\end{DoxyItemize}

\subsubsection*{\mbox{[}0.\+1.\+0\mbox{]}}

First release.

\subsection*{About}

\subsubsection*{Contributing}

Pull requests and stars are always welcome. For bugs and feature requests, \href{../../issues/new}{\tt please create an issue}.

Please read the .github/contributing.\+md \char`\"{}contributing guide\char`\"{} for advice on opening issues, pull requests, and coding standards.

\subsubsection*{Building docs}

\+\_\+(This project\textquotesingle{}s readme.\+md is generated by \href{https://github.com/verbose/verb-generate-readme}{\tt verb}, please don\textquotesingle{}t edit the readme directly. Any changes to the readme must be made in the .verb.\+md \char`\"{}.\+verb.\+md\char`\"{} readme template.)\+\_\+

To generate the readme, run the following command\+:


\begin{DoxyCode}
$ npm install -g verbose/verb#dev verb-generate-readme && verb
\end{DoxyCode}


\subsubsection*{Running tests}

Running and reviewing unit tests is a great way to get familiarized with a library and its A\+PI. You can install dependencies and run tests with the following command\+:


\begin{DoxyCode}
$ npm install && npm test
\end{DoxyCode}


\subsubsection*{Author}

{\bfseries Jon Schlinkert}


\begin{DoxyItemize}
\item \href{https://github.com/jonschlinkert}{\tt github/jonschlinkert}
\item \href{https://twitter.com/jonschlinkert}{\tt twitter/jonschlinkert}
\end{DoxyItemize}

\subsubsection*{License}

Copyright © 2017, \href{https://github.com/jonschlinkert}{\tt Jon Schlinkert}. Released under the \mbox{[}M\+IT License\mbox{]}(L\+I\+C\+E\+N\+SE).





{\itshape This file was generated by \href{https://github.com/verbose/verb-generate-readme}{\tt verb-\/generate-\/readme}, v0.\+6.\+0, on May 01, 2017.} 