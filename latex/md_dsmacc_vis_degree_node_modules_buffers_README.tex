Treat a collection of Buffers as a single contiguous partially mutable Buffer.

Where possible, operations execute without creating a new Buffer and copying everything over.

This is a cleaner more Buffery rehash of \href{http://github.com/substack/node-bufferlist}{\tt bufferlist}.

\section*{example }

\subsection*{slice }

\begin{DoxyVerb}var Buffers = require('buffers');
var bufs = Buffers();
bufs.push(new Buffer([1,2,3]));
bufs.push(new Buffer([4,5,6,7]));
bufs.push(new Buffer([8,9,10]));

console.dir(bufs.slice(2,8))
\end{DoxyVerb}


output\+: \begin{DoxyVerb}$ node examples/slice.js 
<Buffer 03 04 05 06 07 08>
\end{DoxyVerb}


\subsection*{splice }

\begin{DoxyVerb}var Buffers = require('buffers');
var bufs = Buffers([
    new Buffer([1,2,3]),
    new Buffer([4,5,6,7]),
    new Buffer([8,9,10]),
]);

var removed = bufs.splice(2, 4);
console.dir({
    removed : removed.slice(),
    bufs : bufs.slice(),
});
\end{DoxyVerb}


output\+: \begin{DoxyVerb}$ node examples/splice.js
{ removed: <Buffer 03 04 05 06>,
  bufs: <Buffer 01 02 07 08 09 0a> }
\end{DoxyVerb}


\section*{methods }

\subsection*{Buffers(buffers) }

Create a Buffers with an array of {\ttfamily Buffer}s if specified, else {\ttfamily \mbox{[}\mbox{]}}.

\subsection*{.push(buf1, buf2...) }

Push buffers onto the end. Just like {\ttfamily Array.\+prototype.\+push}.

\subsection*{.unshift(buf1, buf2...) }

Unshift buffers onto the head. Just like {\ttfamily Array.\+prototype.\+unshift}.

\subsection*{.slice(i, j) }

Slice a range out of the buffer collection as if it were contiguous. Works just like the {\ttfamily Array.\+prototype.\+slice} version.

\subsection*{.splice(i, how\+Many, replacements) }

Splice the buffer collection as if it were contiguous. Works just like {\ttfamily Array.\+prototype.\+splice}, even the replacement part!

\subsection*{.copy(dst, dst\+Start, start, end) }

Copy the buffer collection as if it were contiguous to the {\ttfamily dst} Buffer with the specified bounds. Works just like {\ttfamily Buffer.\+prototype.\+copy}.

\subsection*{.get(i) }

Get a single element at index {\ttfamily i}.

\subsection*{.set(i, x) }

Set a single element\textquotesingle{}s value at index {\ttfamily i}.

\subsection*{.index\+Of(needle, offset) }

Find a string or buffer {\ttfamily needle} inside the buffer collection. Returns the position of the search string or -\/1 if the search string was not found.

Provide an {\ttfamily offset} to skip that number of characters at the beginning of the search. This can be used to find additional matches.

This function will return the correct result even if the search string is spread out over multiple internal buffers.

\subsection*{.to\+Buffer() }

Convert the buffer collection to a single buffer, equivalent with {\ttfamily .slice(0, buffers.\+length)};

\subsection*{.to\+String(encoding, start, end) }

Decodes and returns a string from the buffer collection. Works just like {\ttfamily Buffer.\+prototype.\+to\+String} 