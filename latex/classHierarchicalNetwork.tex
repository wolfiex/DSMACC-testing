\hypertarget{classHierarchicalNetwork}{}\section{Hierarchical\+Network Class Reference}
\label{classHierarchicalNetwork}\index{Hierarchical\+Network@{Hierarchical\+Network}}
\subsection*{Public Types}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{classHierarchicalNetwork_a16cfa8dc4fff986c896a8dcf35b063b8}\label{classHierarchicalNetwork_a16cfa8dc4fff986c896a8dcf35b063b8}} 
typedef \mbox{\hyperlink{classSNode}{S\+Node}} {\bfseries node\+\_\+type}
\end{DoxyCompactItemize}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{classHierarchicalNetwork_ad944688007b6ebd216d4bca7494a05fb}\label{classHierarchicalNetwork_ad944688007b6ebd216d4bca7494a05fb}} 
{\bfseries Hierarchical\+Network} (const \mbox{\hyperlink{structConfig}{Config}} \&conf)
\item 
\mbox{\Hypertarget{classHierarchicalNetwork_a18f7a5cf2299c46cc4a9f4323966ee98}\label{classHierarchicalNetwork_a18f7a5cf2299c46cc4a9f4323966ee98}} 
void {\bfseries init} (std\+::string network\+Name, double codelength, double one\+Level\+Codelength)
\item 
\mbox{\Hypertarget{classHierarchicalNetwork_a9207ca47e8361ebd4f4955073f78c6c5}\label{classHierarchicalNetwork_a9207ca47e8361ebd4f4955073f78c6c5}} 
void {\bfseries clear} ()
\item 
\mbox{\Hypertarget{classHierarchicalNetwork_a915fe3f5addf08c3a7363edf4c8ce9f5}\label{classHierarchicalNetwork_a915fe3f5addf08c3a7363edf4c8ce9f5}} 
void {\bfseries clear} (const \mbox{\hyperlink{structConfig}{Config}} \&conf)
\item 
\mbox{\Hypertarget{classHierarchicalNetwork_a50bfc6056358ff96c794b77cf9d724c5}\label{classHierarchicalNetwork_a50bfc6056358ff96c794b77cf9d724c5}} 
\mbox{\hyperlink{classSNode}{S\+Node}} \& {\bfseries get\+Root\+Node} ()
\item 
\mbox{\Hypertarget{classHierarchicalNetwork_a75bfb172ffec8befd3296c710c00b65c}\label{classHierarchicalNetwork_a75bfb172ffec8befd3296c710c00b65c}} 
unsigned int {\bfseries num\+Top\+Modules} ()
\item 
\mbox{\Hypertarget{classHierarchicalNetwork_a024be14e77865ee1052d05133675ed68}\label{classHierarchicalNetwork_a024be14e77865ee1052d05133675ed68}} 
\mbox{\hyperlink{classLeafIterator}{Leaf\+Iterator}} {\bfseries leaf\+Iter} (int module\+Index\+Depth=-\/1)
\item 
\mbox{\Hypertarget{classHierarchicalNetwork_a83c7dcc316ceb7a32d8080cdaa2ccd3b}\label{classHierarchicalNetwork_a83c7dcc316ceb7a32d8080cdaa2ccd3b}} 
\mbox{\hyperlink{classTreeIterator}{Tree\+Iterator}} {\bfseries tree\+Iter} (int module\+Index\+Depth=-\/1)
\item 
\mbox{\Hypertarget{classHierarchicalNetwork_a53b2c2fe076062d335a7c9908810c527}\label{classHierarchicalNetwork_a53b2c2fe076062d335a7c9908810c527}} 
\mbox{\hyperlink{classSNode}{S\+Node}} \& {\bfseries add\+Node} (\mbox{\hyperlink{classSNode}{S\+Node}} \&parent, double flow, double exit\+Flow)
\item 
\mbox{\Hypertarget{classHierarchicalNetwork_a5aad30a822aacde199079cb03190194f}\label{classHierarchicalNetwork_a5aad30a822aacde199079cb03190194f}} 
\mbox{\hyperlink{classSNode}{S\+Node}} \& {\bfseries add\+Leaf\+Node} (\mbox{\hyperlink{classSNode}{S\+Node}} \&parent, double flow, double exit\+Flow, const std\+::string \&name, unsigned int leaf\+Index)
\item 
\mbox{\Hypertarget{classHierarchicalNetwork_a276be851d34e1e2ffb1b12a314f9313a}\label{classHierarchicalNetwork_a276be851d34e1e2ffb1b12a314f9313a}} 
\mbox{\hyperlink{classSNode}{S\+Node}} \& {\bfseries add\+Leaf\+Node} (\mbox{\hyperlink{classSNode}{S\+Node}} \&parent, double flow, double exit\+Flow, const std\+::string \&name, unsigned int leaf\+Index, unsigned int original\+Index)
\item 
\mbox{\Hypertarget{classHierarchicalNetwork_a1d9f53da720bd03750af0b747fd8eb70}\label{classHierarchicalNetwork_a1d9f53da720bd03750af0b747fd8eb70}} 
\mbox{\hyperlink{classSNode}{S\+Node}} \& {\bfseries add\+Leaf\+Node} (\mbox{\hyperlink{classSNode}{S\+Node}} \&parent, double flow, double exit\+Flow, const std\+::string \&name, unsigned int leaf\+Index, unsigned int original\+Index, bool is\+Memory\+Node, unsigned int state\+Index, unsigned int phys\+Index)
\item 
\mbox{\Hypertarget{classHierarchicalNetwork_ad0a7ed5227bda931f77167acbaf89487}\label{classHierarchicalNetwork_ad0a7ed5227bda931f77167acbaf89487}} 
void {\bfseries prepare\+Add\+Leaf\+Nodes} (unsigned int num\+Leaf\+Nodes)
\item 
bool \mbox{\hyperlink{classHierarchicalNetwork_afe1778c66f0b4444d70db38214b43ee1}{add\+Leaf\+Edge}} (unsigned int source\+Leaf\+Node\+Index, unsigned int target\+Leaf\+Node\+Index, double flow)
\item 
\mbox{\Hypertarget{classHierarchicalNetwork_acb6954557f7096139cb377be986bc2a7}\label{classHierarchicalNetwork_acb6954557f7096139cb377be986bc2a7}} 
void {\bfseries propagate\+Node\+Name\+Up\+In\+Hierarchy} (\mbox{\hyperlink{classSNode}{S\+Node}} \&\mbox{\hyperlink{structnode}{node}})
\item 
void \mbox{\hyperlink{classHierarchicalNetwork_af9dcdae2d598bdfd3af540a07e10b42f}{write\+Streamable\+Tree}} (const std\+::string \&file\+Name, bool write\+Edges)
\item 
\mbox{\Hypertarget{classHierarchicalNetwork_adaeada9505974f4aa0c2445926dc4f31}\label{classHierarchicalNetwork_adaeada9505974f4aa0c2445926dc4f31}} 
void {\bfseries read\+Streamable\+Tree} (const std\+::string \&file\+Name)
\item 
\mbox{\Hypertarget{classHierarchicalNetwork_a5509ce6488faffc61cb623c680711264}\label{classHierarchicalNetwork_a5509ce6488faffc61cb623c680711264}} 
void {\bfseries write\+Human\+Readable\+Tree} (const std\+::string \&file\+Name, bool write\+Hierarchical\+Network\+Edges=false)
\item 
void \mbox{\hyperlink{classHierarchicalNetwork_a301ba28d5feabede47f09a2fc31b877c}{write\+Clu}} (const std\+::string \&file\+Name, int module\+Index\+Depth=1)
\item 
\mbox{\Hypertarget{classHierarchicalNetwork_af2e8b7af34535045aed66452c4ee5bc4}\label{classHierarchicalNetwork_af2e8b7af34535045aed66452c4ee5bc4}} 
void {\bfseries read\+Human\+Readable\+Tree} (const std\+::string \&file\+Name)
\item 
\mbox{\Hypertarget{classHierarchicalNetwork_a5d7e90b8b48a526af9b9d61b821a6f4c}\label{classHierarchicalNetwork_a5d7e90b8b48a526af9b9d61b821a6f4c}} 
void {\bfseries write\+Map} (const std\+::string \&file\+Name)
\item 
\mbox{\Hypertarget{classHierarchicalNetwork_a62565042b8b8751558d675598fb27424}\label{classHierarchicalNetwork_a62565042b8b8751558d675598fb27424}} 
unsigned int {\bfseries num\+Leaf\+Nodes} ()
\item 
\mbox{\Hypertarget{classHierarchicalNetwork_a8aebde60085e920969f1a00813878f83}\label{classHierarchicalNetwork_a8aebde60085e920969f1a00813878f83}} 
unsigned int {\bfseries num\+Leaf\+Edges} ()
\item 
\mbox{\Hypertarget{classHierarchicalNetwork_aa198250500a51b7ceb01dbf28eeffe44}\label{classHierarchicalNetwork_aa198250500a51b7ceb01dbf28eeffe44}} 
unsigned int {\bfseries num\+Nodes\+In\+Tree} ()
\item 
\mbox{\Hypertarget{classHierarchicalNetwork_a2de0f643f5857df68c8b8e6340efb7cd}\label{classHierarchicalNetwork_a2de0f643f5857df68c8b8e6340efb7cd}} 
unsigned int {\bfseries max\+Depth} ()
\item 
\mbox{\Hypertarget{classHierarchicalNetwork_ac17f2850618df2f7f07254888384b6e6}\label{classHierarchicalNetwork_ac17f2850618df2f7f07254888384b6e6}} 
double {\bfseries codelength} ()
\item 
\mbox{\Hypertarget{classHierarchicalNetwork_a0d7789ad89fd4375fd4f45fe3ef86321}\label{classHierarchicalNetwork_a0d7789ad89fd4375fd4f45fe3ef86321}} 
double {\bfseries onelevel\+Codelength} ()
\end{DoxyCompactItemize}


\subsection{Member Function Documentation}
\mbox{\Hypertarget{classHierarchicalNetwork_afe1778c66f0b4444d70db38214b43ee1}\label{classHierarchicalNetwork_afe1778c66f0b4444d70db38214b43ee1}} 
\index{Hierarchical\+Network@{Hierarchical\+Network}!add\+Leaf\+Edge@{add\+Leaf\+Edge}}
\index{add\+Leaf\+Edge@{add\+Leaf\+Edge}!Hierarchical\+Network@{Hierarchical\+Network}}
\subsubsection{\texorpdfstring{add\+Leaf\+Edge()}{addLeafEdge()}}
{\footnotesize\ttfamily bool Hierarchical\+Network\+::add\+Leaf\+Edge (\begin{DoxyParamCaption}\item[{unsigned int}]{source\+Leaf\+Node\+Index,  }\item[{unsigned int}]{target\+Leaf\+Node\+Index,  }\item[{double}]{flow }\end{DoxyParamCaption})}

Add flow-\/edges to the tree. This method can aggregate the edges between the leaf-\/nodes up in the tree based on the edge aggregation policy. 
\begin{DoxyParams}{Parameters}
{\em aggregation\+Filter} & A flag to decide the type of aggregation. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if a new edge was inserted, false if it was aggregated to an existing edge 
\end{DoxyReturn}
\begin{DoxyNote}{Note}
The Edge\+Aggregation\+Policy enumeration lists the available aggregation policies. 
\end{DoxyNote}

\begin{DoxyCode}
119 \{
120     \mbox{\hyperlink{classSNode}{SNode}}* source = m\_leafNodes[sourceLeafNodeIndex];
121     \mbox{\hyperlink{classSNode}{SNode}}* target = m\_leafNodes[targetLeafNodeIndex];
122 
123     \textcolor{comment}{// Allow only horizontal flow edges}
124     \textcolor{keywordflow}{if} (source->depth > target->depth)
125         \textcolor{keywordflow}{do} \{ source = source->parentNode; \} \textcolor{keywordflow}{while} (source->depth != target->depth);
126     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (source->depth < target->depth)
127         \textcolor{keywordflow}{do} \{ target = target->parentNode; \} \textcolor{keywordflow}{while} (source->depth != target->depth);
128 
129 \textcolor{comment}{//      source->createEdge(target, flow, m\_directedEdges);}
130 
131     \textcolor{comment}{// Only add links under the same parent}
132     \textcolor{keywordflow}{while} (source->parentNode != target->parentNode)
133     \{
134         source = source->parentNode;
135         target = target->parentNode;
136     \}
137     \textcolor{keywordtype}{bool} createdNewEdge = source->parentNode->\mbox{\hyperlink{classSNode_ae6682b903bf066ca1b3d71403f92d9d7}{createChildEdge}}(source->parentIndex, target->
      parentIndex, flow, m\_directedEdges);
138 
139     ++m\_numLeafEdges;
140     \textcolor{keywordflow}{return} createdNewEdge;
141 \}
\end{DoxyCode}
\mbox{\Hypertarget{classHierarchicalNetwork_a301ba28d5feabede47f09a2fc31b877c}\label{classHierarchicalNetwork_a301ba28d5feabede47f09a2fc31b877c}} 
\index{Hierarchical\+Network@{Hierarchical\+Network}!write\+Clu@{write\+Clu}}
\index{write\+Clu@{write\+Clu}!Hierarchical\+Network@{Hierarchical\+Network}}
\subsubsection{\texorpdfstring{write\+Clu()}{writeClu()}}
{\footnotesize\ttfamily void Hierarchical\+Network\+::write\+Clu (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{file\+Name,  }\item[{int}]{module\+Index\+Depth = {\ttfamily 1} }\end{DoxyParamCaption})}

Write a chosen cluster level to file Default cluster level 1 corresponds to top modules Set to -\/1 for leaf modules. 
\begin{DoxyCode}
263 \{
264     markNodesToSkip();
265 
266     \mbox{\hyperlink{classSafeOutFile}{SafeOutFile}} out(fileName.c\_str());
267 
268     out << \textcolor{stringliteral}{"# '"} << m\_infomapOptions << \textcolor{stringliteral}{"' -> "} << m\_numLeafNodes << \textcolor{stringliteral}{" nodes "};
269     \textcolor{keywordflow}{if} (m\_numLeafEdges > 0)
270         out << \textcolor{stringliteral}{"and "} << m\_numLeafEdges << \textcolor{stringliteral}{" links "};
271     out << \textcolor{stringliteral}{"partitioned in "} << m\_config.elapsedTime() << \textcolor{stringliteral}{" from codelength "} <<
272         io::toPrecision(m\_oneLevelCodelength, 9, \textcolor{keyword}{true}) << \textcolor{stringliteral}{" in one level to codelength "} <<
273         io::toPrecision(m\_codelength, 9, \textcolor{keyword}{true}) << \textcolor{stringliteral}{" in "} << m\_maxDepth << \textcolor{stringliteral}{" levels.\(\backslash\)n"};
274     \textcolor{keywordflow}{if} (m\_config.printExpanded) \{
275         \textcolor{keywordflow}{if} (m\_config.isMultiplexNetwork())
276             out << \textcolor{stringliteral}{"# layer node cluster flow:\(\backslash\)n"};
277         \textcolor{keywordflow}{else}
278             out << \textcolor{stringliteral}{"# state\_node node cluster flow:\(\backslash\)n"};
279     \}
280     \textcolor{keywordflow}{else}
281         out << \textcolor{stringliteral}{"# node cluster flow:\(\backslash\)n"};
282 
283     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} indexOffset = m\_config.zeroBasedNodeNumbers? 0 : 1;
284     \textcolor{keywordflow}{for} (\mbox{\hyperlink{classTreeIterator}{TreeIterator}} it(&m\_rootNode, moduleIndexDepth); !it.isEnd(); ++it) \{
285         \mbox{\hyperlink{classSNode}{SNode}} &\mbox{\hyperlink{structnode}{node}} = *it;
286         \textcolor{keywordflow}{if} (\mbox{\hyperlink{structnode}{node}}.isLeafNode()) \{
287             \textcolor{keywordflow}{if} (m\_config.isBipartite()) \{
288                 \textcolor{keywordflow}{if} (\mbox{\hyperlink{structnode}{node}}.originalLeafIndex < m\_config.minBipartiteNodeIndex)
289                     out << \textcolor{charliteral}{'n'} << \mbox{\hyperlink{structnode}{node}}.originalLeafIndex + indexOffset << \textcolor{stringliteral}{" "} << it.moduleIndex() + 1 <
      < \textcolor{stringliteral}{" "} << \mbox{\hyperlink{structnode}{node}}.data.flow << \textcolor{stringliteral}{"\(\backslash\)n"};
290                 \textcolor{keywordflow}{else}
291                     out << \textcolor{charliteral}{'f'} << \mbox{\hyperlink{structnode}{node}}.originalLeafIndex + indexOffset - m\_config.minBipartiteNodeIndex
       << \textcolor{stringliteral}{" "} << it.moduleIndex() + 1 << \textcolor{stringliteral}{" "} << \mbox{\hyperlink{structnode}{node}}.data.flow << \textcolor{stringliteral}{"\(\backslash\)n"};
292             \}
293             \textcolor{keywordflow}{else} \{
294                 \textcolor{keywordflow}{if} (m\_config.printExpanded && \mbox{\hyperlink{structnode}{node}}.isMemoryNode)
295                     out << \mbox{\hyperlink{structnode}{node}}.printState(indexOffset) << \textcolor{stringliteral}{" "} << it.moduleIndex() + 1 << \textcolor{stringliteral}{" "} << 
      \mbox{\hyperlink{structnode}{node}}.data.flow << \textcolor{stringliteral}{"\(\backslash\)n"};
296                 \textcolor{keywordflow}{else}
297                     out << \mbox{\hyperlink{structnode}{node}}.originalLeafIndex + indexOffset << \textcolor{stringliteral}{" "} << it.moduleIndex() + 1 << \textcolor{stringliteral}{" "} <
      < \mbox{\hyperlink{structnode}{node}}.data.flow << \textcolor{stringliteral}{"\(\backslash\)n"};
298             \}
299         \}
300     \}
301 \}
\end{DoxyCode}
\mbox{\Hypertarget{classHierarchicalNetwork_af9dcdae2d598bdfd3af540a07e10b42f}\label{classHierarchicalNetwork_af9dcdae2d598bdfd3af540a07e10b42f}} 
\index{Hierarchical\+Network@{Hierarchical\+Network}!write\+Streamable\+Tree@{write\+Streamable\+Tree}}
\index{write\+Streamable\+Tree@{write\+Streamable\+Tree}!Hierarchical\+Network@{Hierarchical\+Network}}
\subsubsection{\texorpdfstring{write\+Streamable\+Tree()}{writeStreamableTree()}}
{\footnotesize\ttfamily void Hierarchical\+Network\+::write\+Streamable\+Tree (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{file\+Name,  }\item[{bool}]{write\+Edges }\end{DoxyParamCaption})}

Print the network using a breadth-\/first algorithm. Each node keeps a pointer to where its children is located in the file if it has any.

File format\+:

\mbox{[}Header\mbox{]} unsigned int root\+Node\+Position unsigned int num\+Nodes\+Total (num\+Leaf\+Nodes + num\+Modules including the root\+Node)

\mbox{[}\mbox{\hyperlink{classNetwork}{Network}}\mbox{]} \mbox{[}depth 0\mbox{]} root\+Node

\mbox{[}depth 1\mbox{]} first\+Module second\+Module ... last\+Module edges\+Between\+Children\+Of\+Root\+Node

\mbox{[}depth 2\mbox{]} first\+Child\+Of\+First\+Module second\+Child\+Of\+First\+Module ... last\+Child\+Of\+First\+Module edges\+Between\+Children\+Of\+First\+Module\+On\+Depth1

first\+Child\+Of\+Second\+Module ... last\+Child\+Of\+Second\+Module edges\+Between\+Children\+Of\+Second\+Module\+On\+Depth1

...

\mbox{[}E\+OF\mbox{]}

Each binary node contains a pointer to where its children is located in the file 
\begin{DoxyCode}
153 \{
154     \mbox{\hyperlink{classSafeBinaryOutFile}{SafeBinaryOutFile}} out(fileName.c\_str());
155 
156     std::string magicTag (\textcolor{stringliteral}{"Infomap"});
157 
158     out << magicTag;
159     out << m\_config.version;
160     out << m\_infomapOptions;
161     out << m\_directedEdges;
162     out << m\_networkName;
163     out << m\_numLeafNodes;
164     out << m\_numLeafEdges;
165     out << m\_numNodesInTree;
166     out << m\_maxDepth;
167     out << m\_oneLevelCodelength;
168     out << m\_codelength;
169 
170 \textcolor{comment}{//      Log() << "\(\backslash\)nMeta data:\(\backslash\)n";}
171 \textcolor{comment}{//      Log() << "  directedEdges: " << m\_directedEdges << "\(\backslash\)n";}
172 \textcolor{comment}{//      Log() << "  networkName: " << m\_networkName << "\(\backslash\)n";}
173 \textcolor{comment}{//      Log() << "  numLeafNodes: " << numLeafNodes << "\(\backslash\)n";}
174 \textcolor{comment}{//      Log() << "  numLeafEdges: " << m\_numLeafEdges << "\(\backslash\)n";}
175 \textcolor{comment}{//      Log() << "  numNodeInTree: " << m\_numNodesInTree << "\(\backslash\)n";}
176 \textcolor{comment}{//      Log() << "  maxDepth: " << m\_maxDepth << "\(\backslash\)n";}
177 \textcolor{comment}{//      Log() << "  oneLevelCodelength: " << m\_oneLevelCodelength << "\(\backslash\)n";}
178 \textcolor{comment}{//      Log() << "  codelength: " << m\_codelength << "\(\backslash\)n";}
179 
180     std::deque<SNode*> nodeList;
181     nodeList.push\_back(&m\_rootNode);
182     m\_rootNode.data.name = m\_networkName;
183     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} childPosition = out.size() + m\_rootNode.serializationSize(writeEdges);
184     \textcolor{keyword}{using namespace }\mbox{\hyperlink{namespaceSerialTypes}{SerialTypes}};
185     \textcolor{keywordflow}{while} (nodeList.size() > 0) \textcolor{comment}{// visit tree breadth first}
186     \{
187         \mbox{\hyperlink{classSNode}{SNode}}& \mbox{\hyperlink{structnode}{node}} = *nodeList.front();
188 
189         \textcolor{comment}{// Write current node to the file}
190         \mbox{\hyperlink{structnode}{node}}.serialize(out, childPosition, writeEdges);
191         \textcolor{comment}{// add the children of the current node to the list and aggregate their binary sizes to the
       children pointer}
192         childSize\_t numChildren = numeric\_cast<childSize\_t>(\mbox{\hyperlink{structnode}{node}}.children.size());
193         \textcolor{keywordflow}{for} (childSize\_t i = 0; i < numChildren; ++i)
194         \{
195             \mbox{\hyperlink{classSNode}{SNode}}* child = \mbox{\hyperlink{structnode}{node}}.children[i];
196             nodeList.push\_back(child);
197             childPosition += child->serializationSize(writeEdges);
198         \}
199 
200         \textcolor{comment}{// remove the printed node from the list}
201         nodeList.pop\_front();
202     \}
203 \}
\end{DoxyCode}


The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
dsmacc/graph/infomap/src/io/Hierarchical\+Network.\+h\item 
dsmacc/graph/infomap/src/io/Hierarchical\+Network.\+cpp\end{DoxyCompactItemize}
