\begin{quote}
Regular expression for matching \href{https://en.wikipedia.org/wiki/ANSI_escape_code}{\tt A\+N\+SI escape codes} \end{quote}




 {\bfseries  \href{https://tidelift.com/subscription/pkg/npm-ansi-regex?utm_source=npm-ansi-regex&utm_medium=referral&utm_campaign=readme}{\tt Get professional support for this package with a Tidelift subscription} } ~\newline
 \textsubscript{ Tidelift helps make open source sustainable for maintainers while giving companies~\newline
assurances about security, maintenance, and licensing for their dependencies. }  



\subsection*{Install}


\begin{DoxyCode}
$ npm install ansi-regex
\end{DoxyCode}


\subsection*{Usage}


\begin{DoxyCode}
const ansiRegex = require('ansi-regex');

ansiRegex().test('\(\backslash\)u001B[4mcake\(\backslash\)u001B[0m');
//=> true

ansiRegex().test('cake');
//=> false

'\(\backslash\)u001B[4mcake\(\backslash\)u001B[0m'.match(ansiRegex());
//=> ['\(\backslash\)u001B[4m', '\(\backslash\)u001B[0m']

'\(\backslash\)u001B[4mcake\(\backslash\)u001B[0m'.match(ansiRegex(\{onlyFirst: true\}));
//=> ['\(\backslash\)u001B[4m']

'\(\backslash\)u001B]8;;https://github.com\(\backslash\)u0007click\(\backslash\)u001B]8;;\(\backslash\)u0007'.match(ansiRegex());
//=> ['\(\backslash\)u001B]8;;https://github.com\(\backslash\)u0007', '\(\backslash\)u001B]8;;\(\backslash\)u0007']
\end{DoxyCode}


\subsection*{A\+PI}

\subsubsection*{ansi\+Regex(\mbox{[}options\mbox{]})}

Returns a regex for matching A\+N\+SI escape codes.

\paragraph*{options}

\subparagraph*{only\+First}

Type\+: {\ttfamily boolean}~\newline
 Default\+: {\ttfamily false} $\ast$(Matches any A\+N\+SI escape codes in a string)$\ast$

Match only the first A\+N\+SI escape.

\subsection*{F\+AQ}

\subsubsection*{Why do you test for codes not in the E\+C\+MA 48 standard?}

Some of the codes we run as a test are codes that we acquired finding various lists of non-\/standard or manufacturer specific codes. We test for both standard and non-\/standard codes, as most of them follow the same or similar format and can be safely matched in strings without the risk of removing actual string content. There are a few non-\/standard control codes that do not follow the traditional format (i.\+e. they end in numbers) thus forcing us to exclude them from the test because we cannot reliably match them.

On the historical side, those E\+C\+MA standards were established in the early 90\textquotesingle{}s whereas the V\+T100, for example, was designed in the mid/late 70\textquotesingle{}s. At that point in time, control codes were still pretty ungoverned and engineers used them for a multitude of things, namely to activate hardware ports that may have been proprietary. Somewhere else you see a similar \textquotesingle{}anarchy\textquotesingle{} of codes is in the x86 architecture for processors; there are a ton of \char`\"{}interrupts\char`\"{} that can mean different things on certain brands of processors, most of which have been phased out.

\subsection*{Security}

To report a security vulnerability, please use the \href{https://tidelift.com/security}{\tt Tidelift security contact}. Tidelift will coordinate the fix and disclosure.

\subsection*{Maintainers}


\begin{DoxyItemize}
\item \href{https://github.com/sindresorhus}{\tt Sindre Sorhus}
\item \href{https://github.com/qix-}{\tt Josh Junon}
\end{DoxyItemize}

\subsection*{License}

M\+IT 