This module implements a \href{https://en.wikipedia.org/wiki/Verlet_integration}{\tt velocity Verlet} numerical integrator for simulating physical forces on particles. The simulation is simplified\+: it assumes a constant unit time step Δ$\ast$t$\ast$ = 1 for each step, and a constant unit mass {\itshape m} = 1 for all particles. As a result, a force {\itshape F} acting on a particle is equivalent to a constant acceleration {\itshape a} over the time interval Δ$\ast$t$\ast$, and can be simulated simply by adding to the particle’s velocity, which is then added to the particle’s position.

In the domain of information visualization, physical simulations are useful for studying \href{http://bl.ocks.org/mbostock/ad70335eeef6d167bc36fd3c04378048}{\tt networks} and \href{http://bl.ocks.org/mbostock/95aa92e2f4e8345aaa55a4a94d41ce37}{\tt hierarchies}!

\href{http://bl.ocks.org/mbostock/ad70335eeef6d167bc36fd3c04378048}{\tt }\href{http://bl.ocks.org/mbostock/95aa92e2f4e8345aaa55a4a94d41ce37}{\tt }

You can also simulate circles (disks) with collision, such as for \href{http://www.nytimes.com/interactive/2012/09/06/us/politics/convention-word-counts.html}{\tt bubble charts} or \href{http://bl.ocks.org/mbostock/6526445e2b44303eebf21da3b6627320}{\tt beeswarm plots}\+:

\href{http://bl.ocks.org/mbostock/31ce330646fa8bcb7289ff3b97aab3f5}{\tt }\href{http://bl.ocks.org/mbostock/6526445e2b44303eebf21da3b6627320}{\tt }

You can even use it as a rudimentary physics engine, say to simulate cloth\+:

\href{http://bl.ocks.org/mbostock/1b64ec067fcfc51e7471d944f51f1611}{\tt }

To use this module, create a \href{#simulation}{\tt simulation} for an array of \href{#simulation_nodes}{\tt nodes}, and compose the desired \href{#simulation_force}{\tt forces}. Then \href{#simulation_on}{\tt listen} for tick events to render the nodes as they update in your preferred graphics system, such as Canvas or S\+VG.

\subsection*{Installing}

If you use N\+PM, {\ttfamily npm install d3-\/force}. Otherwise, download the \href{https://github.com/d3/d3-force/releases/latest}{\tt latest release}. You can also load directly from \href{https://d3js.org}{\tt d3js.\+org}, either as a \href{https://d3js.org/d3-force.v1.min.js}{\tt standalone library} or as part of \href{https://github.com/d3/d3}{\tt D3 4.\+0}. A\+MD, Common\+JS, and vanilla environments are supported. In vanilla, a {\ttfamily d3\+\_\+force} global is exported\+:


\begin{DoxyCode}
<script src="https://d3js.org/d3-collection.v1.min.js"></script>
<script src="https://d3js.org/d3-dispatch.v1.min.js"></script>
<script src="https://d3js.org/d3-quadtree.v1.min.js"></script>
<script src="https://d3js.org/d3-timer.v1.min.js"></script>
<script src="https://d3js.org/d3-force.v1.min.js"></script>
<script>

var simulation = d3.forceSimulation(nodes);

</script>
\end{DoxyCode}


\href{https://tonicdev.com/npm/d3-force}{\tt Try d3-\/force in your browser.}

\subsection*{A\+PI Reference}

\subsubsection*{Simulation}

\label{_forceSimulation}%
\# d3.{\bfseries force\+Simulation}(\mbox{[}{\itshape nodes}\mbox{]}) \href{https://github.com/d3/d3-force/blob/master/src/simulation.js}{\tt $<$$>$}

Creates a new simulation with the specified array of \href{#simulation_nodes}{\tt {\itshape nodes}} and no \href{#simulation_force}{\tt forces}. If {\itshape nodes} is not specified, it defaults to the empty array. The simulator \href{#simulation_restart}{\tt starts} automatically; use \href{#simulation_on}{\tt {\itshape simulation}.on} to listen for tick events as the simulation runs. If you wish to run the simulation manually instead, call \href{#simulation_stop}{\tt {\itshape simulation}.stop}, and then call \href{#simulation_tick}{\tt {\itshape simulation}.tick} as desired.

\label{_simulation_restart}%
\# {\itshape simulation}.{\bfseries restart}() \href{https://github.com/d3/d3-force/blob/master/src/simulation.js#L80}{\tt $<$$>$}

Restarts the simulation’s internal timer and returns the simulation. In conjunction with \href{#simulation_alphaTarget}{\tt {\itshape simulation}.alpha\+Target} or \href{#simulation_alpha}{\tt {\itshape simulation}.alpha}, this method can be used to “reheat” the simulation during interaction, such as when dragging a node, or to resume the simulation after temporarily pausing it with \href{#simulation_stop}{\tt {\itshape simulation}.stop}.

\label{_simulation_stop}%
\# {\itshape simulation}.{\bfseries stop}() \href{https://github.com/d3/d3-force/blob/master/src/simulation.js#L84}{\tt $<$$>$}

Stops the simulation’s internal timer, if it is running, and returns the simulation. If the timer is already stopped, this method does nothing. This method is useful for running the simulation manually; see \href{#simulation_tick}{\tt {\itshape simulation}.tick}.

\label{_simulation_tick}%
\# {\itshape simulation}.{\bfseries tick}() \href{https://github.com/d3/d3-force/blob/master/src/simulation.js#L38}{\tt $<$$>$}

Increments the current \href{#simulation_alpha}{\tt {\itshape alpha}} by (\href{#simulation_alphaTarget}{\tt {\itshape alpha\+Target}} -\/ {\itshape alpha}) × \href{#simulation_alphaDecay}{\tt {\itshape alpha\+Decay}}; then invokes each registered \href{#simulation_force}{\tt force}, passing the new {\itshape alpha}; then decrements each \href{#simulation_nodes}{\tt node}’s velocity by {\itshape velocity} × \href{#simulation_velocityDecay}{\tt {\itshape velocity\+Decay}}; lastly increments each node’s position by {\itshape velocity}.

This method does not dispatch \href{#simulation_on}{\tt events}; events are only dispatched by the internal timer when the simulation is started automatically upon \href{#forceSimulation}{\tt creation} or by calling \href{#simulation_restart}{\tt {\itshape simulation}.restart}. The natural number of ticks when the simulation is started is ⌈$\ast$log$\ast$(\href{#simulation_alphaMin}{\tt {\itshape alpha\+Min}}) / {\itshape log}(1 -\/ \href{#simulation_alphaDecay}{\tt {\itshape alpha\+Decay}})⌉; by default, this is 300.

This method can be used in conjunction with \href{#simulation_stop}{\tt {\itshape simulation}.stop} to compute a \href{https://bl.ocks.org/mbostock/1667139}{\tt static force layout}. For large graphs, static layouts should be computed \href{https://bl.ocks.org/mbostock/01ab2e85e8727d6529d20391c0fd9a16}{\tt in a web worker} to avoid freezing the user interface.

\label{_simulation_nodes}%
\# {\itshape simulation}.{\bfseries nodes}(\mbox{[}{\itshape nodes}\mbox{]}) \href{https://github.com/d3/d3-force/blob/master/src/simulation.js#L88}{\tt $<$$>$}

If {\itshape nodes} is specified, sets the simulation’s nodes to the specified array of objects, initializing their positions and velocities if necessary, and then \href{#force_initialize}{\tt re-\/initializes} any bound \href{#simulation_force}{\tt forces}; returns the simulation. If {\itshape nodes} is not specified, returns the simulation’s array of nodes as specified to the \href{#forceSimulation}{\tt constructor}.

Each {\itshape node} must be an object. The following properties are assigned by the simulation\+:


\begin{DoxyItemize}
\item {\ttfamily index} -\/ the node’s zero-\/based index into {\itshape nodes}
\item {\ttfamily x} -\/ the node’s current {\itshape x}-\/position
\item {\ttfamily y} -\/ the node’s current {\itshape y}-\/position
\item {\ttfamily vx} -\/ the node’s current {\itshape x}-\/velocity
\item {\ttfamily vy} -\/ the node’s current {\itshape y}-\/velocity
\end{DoxyItemize}

The position ⟨$\ast$x$\ast$,{\itshape y$\ast$⟩ and velocity ⟨$\ast$vx},{\itshape vy$\ast$⟩ may be subsequently modified by \href{#forces}{\tt forces} and by the simulation. If either $\ast$vx} or {\itshape vy} is NaN, the velocity is initialized to ⟨0,0⟩. If either {\itshape x} or {\itshape y} is NaN, the position is initialized in a \href{http://bl.ocks.org/mbostock/11478058}{\tt phyllotaxis arrangement}, so chosen to ensure a deterministic, uniform distribution around the origin.

To fix a node in a given position, you may specify two additional properties\+:


\begin{DoxyItemize}
\item {\ttfamily fx} -\/ the node’s fixed {\itshape x}-\/position
\item {\ttfamily fy} -\/ the node’s fixed {\itshape y}-\/position
\end{DoxyItemize}

At the end of each \href{#simulation_tick}{\tt tick}, after the application of any forces, a node with a defined {\itshape node}.fx has {\itshape node}.x reset to this value and {\itshape node}.vx set to zero; likewise, a node with a defined {\itshape node}.fy has {\itshape node}.y reset to this value and {\itshape node}.vy set to zero. To unfix a node that was previously fixed, set {\itshape node}.fx and {\itshape node}.fy to null, or delete these properties.

If the specified array of {\itshape nodes} is modified, such as when nodes are added to or removed from the simulation, this method must be called again with the new (or changed) array to notify the simulation and bound forces of the change; the simulation does not make a defensive copy of the specified array.

\label{_simulation_alpha}%
\# {\itshape simulation}.{\bfseries alpha}(\mbox{[}{\itshape alpha}\mbox{]}) \href{https://github.com/d3/d3-force/blob/master/src/simulation.js#L92}{\tt $<$$>$}

If {\itshape alpha} is specified, sets the current alpha to the specified number in the range \mbox{[}0,1\mbox{]} and returns this simulation. If {\itshape alpha} is not specified, returns the current alpha value, which defaults to 1.

\label{_simulation_alphaMin}%
\# {\itshape simulation}.{\bfseries alpha\+Min}(\mbox{[}{\itshape min}\mbox{]}) \href{https://github.com/d3/d3-force/blob/master/src/simulation.js#L96}{\tt $<$$>$}

If {\itshape min} is specified, sets the minimum {\itshape alpha} to the specified number in the range \mbox{[}0,1\mbox{]} and returns this simulation. If {\itshape min} is not specified, returns the current minimum {\itshape alpha} value, which defaults to 0.\+001. The simulation’s internal timer stops when the current \href{#simulation_alpha}{\tt {\itshape alpha}} is less than the minimum {\itshape alpha}. The default \href{#simulation_alphaDecay}{\tt alpha decay rate} of $\sim$0.0228 corresponds to 300 iterations.

\label{_simulation_alphaDecay}%
\# {\itshape simulation}.{\bfseries alpha\+Decay}(\mbox{[}{\itshape decay}\mbox{]}) \href{https://github.com/d3/d3-force/blob/master/src/simulation.js#L100}{\tt $<$$>$}

If {\itshape decay} is specified, sets the \href{#simulation_alpha}{\tt {\itshape alpha}} decay rate to the specified number in the range \mbox{[}0,1\mbox{]} and returns this simulation. If {\itshape decay} is not specified, returns the current {\itshape alpha} decay rate, which defaults to 0.\+0228… = 1 -\/ {\itshape pow}(0.\+001, 1 / 300) where 0.\+001 is the default \href{#simulation_alphaMin}{\tt minimum {\itshape alpha}}.

The alpha decay rate determines how quickly the current alpha interpolates towards the desired \href{#simulation_alphaTarget}{\tt target {\itshape alpha}}; since the default target {\itshape alpha} is zero, by default this controls how quickly the simulation cools. Higher decay rates cause the simulation to stabilize more quickly, but risk getting stuck in a local minimum; lower values cause the simulation to take longer to run, but typically converge on a better layout. To have the simulation run forever at the current {\itshape alpha}, set the {\itshape decay} rate to zero; alternatively, set a \href{#simulation_alphaTarget}{\tt target {\itshape alpha}} greater than the \href{#simulation_alphaMin}{\tt minimum {\itshape alpha}}.

\label{_simulation_alphaTarget}%
\# {\itshape simulation}.{\bfseries alpha\+Target}(\mbox{[}{\itshape target}\mbox{]}) \href{https://github.com/d3/d3-force/blob/master/src/simulation.js#L104}{\tt $<$$>$}

If {\itshape target} is specified, sets the current target \href{#simulation_alpha}{\tt {\itshape alpha}} to the specified number in the range \mbox{[}0,1\mbox{]} and returns this simulation. If {\itshape target} is not specified, returns the current target alpha value, which defaults to 0.

\label{_simulation_velocityDecay}%
\# {\itshape simulation}.{\bfseries velocity\+Decay}(\mbox{[}{\itshape decay}\mbox{]}) \href{https://github.com/d3/d3-force/blob/master/src/simulation.js#L108}{\tt $<$$>$}

If {\itshape decay} is specified, sets the velocity decay factor to the specified number in the range \mbox{[}0,1\mbox{]} and returns this simulation. If {\itshape decay} is not specified, returns the current velocity decay factor, which defaults to 0.\+4. The decay factor is akin to atmospheric friction; after the application of any forces during a \href{#simulation_tick}{\tt tick}, each node’s velocity is multiplied by 1 -\/ {\itshape decay}. As with lowering the \href{#simulation_alphaDecay}{\tt alpha decay rate}, less velocity decay may converge on a better solution, but risks numerical instabilities and oscillation.

\label{_simulation_force}%
\# {\itshape simulation}.{\bfseries force}({\itshape name}\mbox{[}, {\itshape force}\mbox{]}) \href{https://github.com/d3/d3-force/blob/master/src/simulation.js#L112}{\tt $<$$>$}

If {\itshape force} is specified, assigns the \href{#forces}{\tt force} for the specified {\itshape name} and returns this simulation. If {\itshape force} is not specified, returns the force with the specified name, or undefined if there is no such force. (By default, new simulations have no forces.) For example, to create a new simulation to layout a graph, you might say\+:


\begin{DoxyCode}
var simulation = d3.forceSimulation(nodes)
    .force("charge", d3.forceManyBody())
    .force("link", d3.forceLink(links))
    .force("center", d3.forceCenter());
\end{DoxyCode}


To remove the force with the given {\itshape name}, pass null as the {\itshape force}. For example, to remove the charge force\+:


\begin{DoxyCode}
simulation.force("charge", null);
\end{DoxyCode}


\label{_simulation_find}%
\# {\itshape simulation}.{\bfseries find}({\itshape x}, {\itshape y}\mbox{[}, {\itshape radius}\mbox{]}) \href{https://github.com/d3/d3-force/blob/master/src/simulation.js#L116}{\tt $<$$>$}

Returns the node closest to the position ⟨$\ast$x$\ast$,{\itshape y$\ast$⟩ with the given search $\ast$radius}. If {\itshape radius} is not specified, it defaults to infinity. If there is no node within the search area, returns undefined.

\label{_simulation_on}%
\# {\itshape simulation}.{\bfseries on}({\itshape typenames}, \mbox{[}{\itshape listener}\mbox{]}) \href{https://github.com/d3/d3-force/blob/master/src/simulation.js#L139}{\tt $<$$>$}

If {\itshape listener} is specified, sets the event {\itshape listener} for the specified {\itshape typenames} and returns this simulation. If an event listener was already registered for the same type and name, the existing listener is removed before the new listener is added. If {\itshape listener} is null, removes the current event listeners for the specified {\itshape typenames}, if any. If {\itshape listener} is not specified, returns the first currently-\/assigned listener matching the specified {\itshape typenames}, if any. When a specified event is dispatched, each {\itshape listener} will be invoked with the {\ttfamily this} context as the simulation.

The {\itshape typenames} is a string containing one or more {\itshape typename} separated by whitespace. Each {\itshape typename} is a {\itshape type}, optionally followed by a period ({\ttfamily .}) and a {\itshape name}, such as {\ttfamily tick.\+foo} and {\ttfamily tick.\+bar}; the name allows multiple listeners to be registered for the same {\itshape type}. The {\itshape type} must be one of the following\+:


\begin{DoxyItemize}
\item {\ttfamily tick} -\/ after each tick of the simulation’s internal timer.
\item {\ttfamily end} -\/ after the simulation’s timer stops when {\itshape alpha} $<$ \href{#simulation_alphaMin}{\tt {\itshape alpha\+Min}}.
\end{DoxyItemize}

Note that {\itshape tick} events are not dispatched when \href{#simulation_tick}{\tt {\itshape simulation}.tick} is called manually; events are only dispatched by the internal timer and are intended for interactive rendering of the simulation. To affect the simulation, register \href{#simulation_force}{\tt forces} instead of modifying nodes’ positions or velocities inside a tick event listener.

See \href{https://github.com/d3/d3-dispatch#dispatch_on}{\tt {\itshape dispatch}.on} for details.

\subsubsection*{Forces}

A {\itshape force} is simply a function that modifies nodes’ positions or velocities; in this context, a {\itshape force} can apply a classical physical force such as electrical charge or gravity, or it can resolve a geometric constraint, such as keeping nodes within a bounding box or keeping linked nodes a fixed distance apart. For example, a simple positioning force that moves nodes towards the origin ⟨0,0⟩ might be implemented as\+:


\begin{DoxyCode}
function force(alpha) \{
  for (var i = 0, n = nodes.length, node, k = alpha * 0.1; i < n; ++i) \{
    node = nodes[i];
    node.vx -= node.x * k;
    node.vy -= node.y * k;
  \}
\}
\end{DoxyCode}


Forces typically read the node’s current position ⟨$\ast$x$\ast$,{\itshape y$\ast$⟩ and then add to (or subtract from) the node’s velocity ⟨$\ast$vx},{\itshape vy$\ast$⟩. However, forces may also “peek ahead” to the anticipated next position of the node, ⟨$\ast$x} + {\itshape vx},{\itshape y} + $\ast$vy$\ast$⟩; this is necessary for resolving geometric constraints through \href{https://en.wikipedia.org/wiki/Relaxation_\(iterative_method\)}{\tt iterative relaxation}. Forces may also modify the position directly, which is sometimes useful to avoid adding energy to the simulation, such as when recentering the simulation in the viewport.

Simulations typically compose multiple forces as desired. This module provides several for your enjoyment\+:


\begin{DoxyItemize}
\item \href{#centering}{\tt Centering}
\item \href{#collision}{\tt Collision}
\item \href{#links}{\tt Links}
\item \href{#many-body}{\tt Many-\/\+Body}
\item \href{#positioning}{\tt Positioning}
\end{DoxyItemize}

Forces may optionally implement \href{#force_initialize}{\tt {\itshape force}.initialize} to receive the simulation’s array of nodes.

\label{__force}%
\# {\itshape force}({\itshape alpha}) \href{https://github.com/d3/d3-force/blob/master/src/simulation.js#L44}{\tt $<$$>$}

Applies this force, optionally observing the specified {\itshape alpha}. Typically, the force is applied to the array of nodes previously passed to \href{#force_initialize}{\tt {\itshape force}.initialize}, however, some forces may apply to a subset of nodes, or behave differently. For example, \href{#links}{\tt d3.\+force\+Link} applies to the source and target of each link.

\label{_force_initialize}%
\# {\itshape force}.{\bfseries initialize}({\itshape nodes}) \href{https://github.com/d3/d3-force/blob/master/src/simulation.js#L71}{\tt $<$$>$}

Assigns the array of {\itshape nodes} to this force. This method is called when a force is bound to a simulation via \href{#simulation_force}{\tt {\itshape simulation}.force} and when the simulation’s nodes change via \href{#simulation_nodes}{\tt {\itshape simulation}.nodes}. A force may perform necessary work during initialization, such as evaluating per-\/node parameters, to avoid repeatedly performing work during each application of the force.

\paragraph*{Centering}

The centering force translates nodes uniformly so that the mean position of all nodes (the center of mass if all nodes have equal weight) is at the given position ⟨\href{#center_x}{\tt {\itshape x}},\href{#center_y}{\tt {\itshape y}}⟩. This force modifies the positions of nodes on each application; it does not modify velocities, as doing so would typically cause the nodes to overshoot and oscillate around the desired center. This force helps keeps nodes in the center of the viewport, and unlike the \href{#positioning}{\tt positioning force}, it does not distort their relative positions.

\label{_forceCenter}%
\# d3.{\bfseries force\+Center}(\mbox{[}{\itshape x}, {\itshape y}\mbox{]}) \href{https://github.com/d3/d3-force/blob/master/src/center.js#L1}{\tt $<$$>$}

Creates a new centering force with the specified \href{#center_x}{\tt {\itshape x}-\/} and \href{#center_y}{\tt {\itshape y}-\/} coordinates. If {\itshape x} and {\itshape y} are not specified, they default to ⟨0,0⟩.

\label{_center_x}%
\# {\itshape center}.{\bfseries x}(\mbox{[}{\itshape x}\mbox{]}) \href{https://github.com/d3/d3-force/blob/master/src/center.js#L27}{\tt $<$$>$}

If {\itshape x} is specified, sets the {\itshape x}-\/coordinate of the centering position to the specified number and returns this force. If {\itshape x} is not specified, returns the current {\itshape x}-\/coordinate, which defaults to zero.

\label{_center_y}%
\# {\itshape center}.{\bfseries y}(\mbox{[}{\itshape y}\mbox{]}) \href{https://github.com/d3/d3-force/blob/master/src/center.js#L31}{\tt $<$$>$}

If {\itshape y} is specified, sets the {\itshape y}-\/coordinate of the centering position to the specified number and returns this force. If {\itshape y} is not specified, returns the current {\itshape y}-\/coordinate, which defaults to zero.

\paragraph*{Collision}

The collision force treats nodes as circles with a given \href{#collide_radius}{\tt radius}, rather than points, and prevents nodes from overlapping. More formally, two nodes {\itshape a} and {\itshape b} are separated so that the distance between {\itshape a} and {\itshape b} is at least {\itshape radius}({\itshape a}) + {\itshape radius}({\itshape b}). To reduce jitter, this is by default a “soft” constraint with a configurable \href{#collide_strength}{\tt strength} and \href{#collide_iterations}{\tt iteration count}.

\label{_forceCollide}%
\# d3.{\bfseries force\+Collide}(\mbox{[}{\itshape radius}\mbox{]}) \href{https://github.com/d3/d3-force/blob/master/src/collide.js}{\tt $<$$>$}

Creates a new circle collision force with the specified \href{#collide_radius}{\tt {\itshape radius}}. If {\itshape radius} is not specified, it defaults to the constant one for all nodes.

\label{_collide_radius}%
\# {\itshape collide}.{\bfseries radius}(\mbox{[}{\itshape radius}\mbox{]}) \href{https://github.com/d3/d3-force/blob/master/src/collide.js#L86}{\tt $<$$>$}

If {\itshape radius} is specified, sets the radius accessor to the specified number or function, re-\/evaluates the radius accessor for each node, and returns this force. If {\itshape radius} is not specified, returns the current radius accessor, which defaults to\+:


\begin{DoxyCode}
function radius() \{
  return 1;
\}
\end{DoxyCode}


The radius accessor is invoked for each \href{#simulation_nodes}{\tt node} in the simulation, being passed the {\itshape node} and its zero-\/based {\itshape index}. The resulting number is then stored internally, such that the radius of each node is only recomputed when the force is initialized or when this method is called with a new {\itshape radius}, and not on every application of the force.

\label{_collide_strength}%
\# {\itshape collide}.{\bfseries strength}(\mbox{[}{\itshape strength}\mbox{]}) \href{https://github.com/d3/d3-force/blob/master/src/collide.js#L82}{\tt $<$$>$}

If {\itshape strength} is specified, sets the force strength to the specified number in the range \mbox{[}0,1\mbox{]} and returns this force. If {\itshape strength} is not specified, returns the current strength which defaults to 0.\+7.

Overlapping nodes are resolved through iterative relaxation. For each node, the other nodes that are anticipated to overlap at the next tick (using the anticipated positions ⟨$\ast$x$\ast$ + {\itshape vx},{\itshape y} + $\ast$vy$\ast$⟩) are determined; the node’s velocity is then modified to push the node out of each overlapping node. The change in velocity is dampened by the force’s strength such that the resolution of simultaneous overlaps can be blended together to find a stable solution.

\label{_collide_iterations}%
\# {\itshape collide}.{\bfseries iterations}(\mbox{[}{\itshape iterations}\mbox{]}) \href{https://github.com/d3/d3-force/blob/master/src/collide.js#L78}{\tt $<$$>$}

If {\itshape iterations} is specified, sets the number of iterations per application to the specified number and returns this force. If {\itshape iterations} is not specified, returns the current iteration count which defaults to 1. Increasing the number of iterations greatly increases the rigidity of the constraint and avoids partial overlap of nodes, but also increases the runtime cost to evaluate the force.

\paragraph*{Links}

The link force pushes linked nodes together or apart according to the desired \href{#link_distance}{\tt link distance}. The strength of the force is proportional to the difference between the linked nodes’ distance and the target distance, similar to a spring force.

\label{_forceLink}%
\# d3.{\bfseries force\+Link}(\mbox{[}{\itshape links}\mbox{]}) \href{https://github.com/d3/d3-force/blob/master/src/link.js}{\tt $<$$>$}

Creates a new link force with the specified {\itshape links} and default parameters. If {\itshape links} is not specified, it defaults to the empty array.

\label{_link_links}%
\# {\itshape link}.{\bfseries links}(\mbox{[}{\itshape links}\mbox{]}) \href{https://github.com/d3/d3-force/blob/master/src/link.js#L92}{\tt $<$$>$}

If {\itshape links} is specified, sets the array of links associated with this force, recomputes the \href{#link_distance}{\tt distance} and \href{#link_strength}{\tt strength} parameters for each link, and returns this force. If {\itshape links} is not specified, returns the current array of links, which defaults to the empty array.

Each link is an object with the following properties\+:


\begin{DoxyItemize}
\item {\ttfamily source} -\/ the link’s source node; see \href{#simulation_nodes}{\tt {\itshape simulation}.nodes}
\item {\ttfamily target} -\/ the link’s target node; see \href{#simulation_nodes}{\tt {\itshape simulation}.nodes}
\item {\ttfamily index} -\/ the zero-\/based index into {\itshape links}, assigned by this method
\end{DoxyItemize}

For convenience, a link’s source and target properties may be initialized using numeric or string identifiers rather than object references; see \href{#link_id}{\tt {\itshape link}.id}. When the link force is \href{#force_initialize}{\tt initialized} (or re-\/initialized, as when the nodes or links change), any {\itshape link}.source or {\itshape link}.target property which is {\itshape not} an object is replaced by an object reference to the corresponding {\itshape node} with the given identifier.

If the specified array of {\itshape links} is modified, such as when links are added to or removed from the simulation, this method must be called again with the new (or changed) array to notify the force of the change; the force does not make a defensive copy of the specified array.

\label{_link_id}%
\# {\itshape link}.{\bfseries id}(\mbox{[}{\itshape id}\mbox{]}) \href{https://github.com/d3/d3-force/blob/master/src/link.js#L96}{\tt $<$$>$}

If {\itshape id} is specified, sets the node id accessor to the specified function and returns this force. If {\itshape id} is not specified, returns the current node id accessor, which defaults to the numeric {\itshape node}.index\+:


\begin{DoxyCode}
function id(d) \{
  return d.index;
\}
\end{DoxyCode}


The default id accessor allows each link’s source and target to be specified as a zero-\/based index into the \href{#simulation_nodes}{\tt nodes} array. For example\+:


\begin{DoxyCode}
var nodes = [
  \{"id": "Alice"\},
  \{"id": "Bob"\},
  \{"id": "Carol"\}
];

var links = [
  \{"source": 0, "target": 1\}, // Alice → Bob
  \{"source": 1, "target": 2\} // Bob → Carol
];
\end{DoxyCode}


Now consider a different id accessor that returns a string\+:


\begin{DoxyCode}
function id(d) \{
  return d.id;
\}
\end{DoxyCode}


With this accessor, you can use named sources and targets\+:


\begin{DoxyCode}
var nodes = [
  \{"id": "Alice"\},
  \{"id": "Bob"\},
  \{"id": "Carol"\}
];

var links = [
  \{"source": "Alice", "target": "Bob"\},
  \{"source": "Bob", "target": "Carol"\}
];
\end{DoxyCode}


This is particularly useful when representing graphs in J\+S\+ON, as J\+S\+ON does not allow references. See \href{http://bl.ocks.org/mbostock/f584aa36df54c451c94a9d0798caed35}{\tt this example}.

The id accessor is invoked for each node whenever the force is initialized, as when the \href{#simulation_nodes}{\tt nodes} or \href{#link_links}{\tt links} change, being passed the node and its zero-\/based index.

\label{_link_distance}%
\# {\itshape link}.{\bfseries distance}(\mbox{[}{\itshape distance}\mbox{]}) \href{https://github.com/d3/d3-force/blob/master/src/link.js#L108}{\tt $<$$>$}

If {\itshape distance} is specified, sets the distance accessor to the specified number or function, re-\/evaluates the distance accessor for each link, and returns this force. If {\itshape distance} is not specified, returns the current distance accessor, which defaults to\+:


\begin{DoxyCode}
function distance() \{
  return 30;
\}
\end{DoxyCode}


The distance accessor is invoked for each \href{#link_links}{\tt link}, being passed the {\itshape link} and its zero-\/based {\itshape index}. The resulting number is then stored internally, such that the distance of each link is only recomputed when the force is initialized or when this method is called with a new {\itshape distance}, and not on every application of the force.

\label{_link_strength}%
\# {\itshape link}.{\bfseries strength}(\mbox{[}{\itshape strength}\mbox{]}) \href{https://github.com/d3/d3-force/blob/master/src/link.js#L104}{\tt $<$$>$}

If {\itshape strength} is specified, sets the strength accessor to the specified number or function, re-\/evaluates the strength accessor for each link, and returns this force. If {\itshape strength} is not specified, returns the current strength accessor, which defaults to\+:


\begin{DoxyCode}
function strength(link) \{
  return 1 / Math.min(count(link.source), count(link.target));
\}
\end{DoxyCode}


Where {\itshape count}({\itshape node}) is a function that returns the number of links with the given node as a source or target. This default was chosen because it automatically reduces the strength of links connected to heavily-\/connected nodes, improving stability.

The strength accessor is invoked for each \href{#link_links}{\tt link}, being passed the {\itshape link} and its zero-\/based {\itshape index}. The resulting number is then stored internally, such that the strength of each link is only recomputed when the force is initialized or when this method is called with a new {\itshape strength}, and not on every application of the force.

\label{_link_iterations}%
\# {\itshape link}.{\bfseries iterations}(\mbox{[}{\itshape iterations}\mbox{]}) \href{https://github.com/d3/d3-force/blob/master/src/link.js#L100}{\tt $<$$>$}

If {\itshape iterations} is specified, sets the number of iterations per application to the specified number and returns this force. If {\itshape iterations} is not specified, returns the current iteration count which defaults to 1. Increasing the number of iterations greatly increases the rigidity of the constraint and is useful for \href{http://bl.ocks.org/mbostock/1b64ec067fcfc51e7471d944f51f1611}{\tt complex structures such as lattices}, but also increases the runtime cost to evaluate the force.

\paragraph*{Many-\/\+Body}

The many-\/body (or {\itshape n}-\/body) force applies mutually amongst all \href{#simulation_nodes}{\tt nodes}. It can be used to simulate gravity (attraction) if the \href{#manyBody_strength}{\tt strength} is positive, or electrostatic charge (repulsion) if the strength is negative. This implementation uses quadtrees and the \href{https://en.wikipedia.org/wiki/Barnes–Hut_simulation}{\tt Barnes–\+Hut approximation} to greatly improve performance; the accuracy can be customized using the \href{#manyBody_theta}{\tt theta} parameter.

Unlike links, which only affect two linked nodes, the charge force is global\+: every node affects every other node, even if they are on disconnected subgraphs.

\label{_forceManyBody}%
\# d3.{\bfseries force\+Many\+Body}() \href{https://github.com/d3/d3-force/blob/master/src/manyBody.js}{\tt $<$$>$}

Creates a new many-\/body force with the default parameters.

\label{_manyBody_strength}%
\# {\itshape many\+Body}.{\bfseries strength}(\mbox{[}{\itshape strength}\mbox{]}) \href{https://github.com/d3/d3-force/blob/master/src/manyBody.js#L97}{\tt $<$$>$}

If {\itshape strength} is specified, sets the strength accessor to the specified number or function, re-\/evaluates the strength accessor for each node, and returns this force. A positive value causes nodes to attract each other, similar to gravity, while a negative value causes nodes to repel each other, similar to electrostatic charge. If {\itshape strength} is not specified, returns the current strength accessor, which defaults to\+:


\begin{DoxyCode}
function strength() \{
  return -30;
\}
\end{DoxyCode}


The strength accessor is invoked for each \href{#simulation_nodes}{\tt node} in the simulation, being passed the {\itshape node} and its zero-\/based {\itshape index}. The resulting number is then stored internally, such that the strength of each node is only recomputed when the force is initialized or when this method is called with a new {\itshape strength}, and not on every application of the force.

\label{_manyBody_theta}%
\# {\itshape many\+Body}.{\bfseries theta}(\mbox{[}{\itshape theta}\mbox{]}) \href{https://github.com/d3/d3-force/blob/master/src/manyBody.js#L109}{\tt $<$$>$}

If {\itshape theta} is specified, sets the Barnes–\+Hut approximation criterion to the specified number and returns this force. If {\itshape theta} is not specified, returns the current value, which defaults to 0.\+9.

To accelerate computation, this force implements the \href{http://en.wikipedia.org/wiki/Barnes–Hut_simulation}{\tt Barnes–\+Hut approximation} which takes O({\itshape n} log {\itshape n}) per application where {\itshape n} is the number of \href{#simulation_nodes}{\tt nodes}. For each application, a \href{https://github.com/d3/d3-quadtree}{\tt quadtree} stores the current node positions; then for each node, the combined force of all other nodes on the given node is computed. For a cluster of nodes that is far away, the charge force can be approximated by treating the cluster as a single, larger node. The {\itshape theta} parameter determines the accuracy of the approximation\+: if the ratio {\itshape w} / {\itshape l} of the width {\itshape w} of the quadtree cell to the distance {\itshape l} from the node to the cell’s center of mass is less than {\itshape theta}, all nodes in the given cell are treated as a single node rather than individually.

\label{_manyBody_distanceMin}%
\# {\itshape many\+Body}.{\bfseries distance\+Min}(\mbox{[}{\itshape distance}\mbox{]}) \href{https://github.com/d3/d3-force/blob/master/src/manyBody.js#L101}{\tt $<$$>$}

If {\itshape distance} is specified, sets the minimum distance between nodes over which this force is considered. If {\itshape distance} is not specified, returns the current minimum distance, which defaults to 1. A minimum distance establishes an upper bound on the strength of the force between two nearby nodes, avoiding instability. In particular, it avoids an infinitely-\/strong force if two nodes are exactly coincident; in this case, the direction of the force is random.

\label{_manyBody_distanceMax}%
\# {\itshape many\+Body}.{\bfseries distance\+Max}(\mbox{[}{\itshape distance}\mbox{]}) \href{https://github.com/d3/d3-force/blob/master/src/manyBody.js#L105}{\tt $<$$>$}

If {\itshape distance} is specified, sets the maximum distance between nodes over which this force is considered. If {\itshape distance} is not specified, returns the current maximum distance, which defaults to infinity. Specifying a finite maximum distance improves performance and produces a more localized layout.

\paragraph*{Positioning}

The \href{#forceX}{\tt {\itshape x}}-\/ and \href{#forceY}{\tt {\itshape y}}-\/positioning forces push nodes towards a desired position along the given dimension with a configurable strength. The \href{#forceRadial}{\tt {\itshape radial}} force is similar, except it pushes nodes towards the closest point on a given circle. The strength of the force is proportional to the one-\/dimensional distance between the node’s position and the target position. While these forces can be used to position individual nodes, they are intended primarily for global forces that apply to all (or most) nodes.

\label{_forceX}%
\# d3.{\bfseries forceX}(\mbox{[}{\itshape x}\mbox{]}) \href{https://github.com/d3/d3-force/blob/master/src/x.js}{\tt $<$$>$}

Creates a new positioning force along the {\itshape x}-\/axis towards the given position \href{#x_x}{\tt {\itshape x}}. If {\itshape x} is not specified, it defaults to 0.

\label{_x_strength}%
\# {\itshape x}.{\bfseries strength}(\mbox{[}{\itshape strength}\mbox{]}) \href{https://github.com/d3/d3-force/blob/master/src/x.js#L32}{\tt $<$$>$}

If {\itshape strength} is specified, sets the strength accessor to the specified number or function, re-\/evaluates the strength accessor for each node, and returns this force. The {\itshape strength} determines how much to increment the node’s {\itshape x}-\/velocity\+: (\href{#x_x}{\tt {\itshape x}} -\/ {\itshape node}.x) × {\itshape strength}. For example, a value of 0.\+1 indicates that the node should move a tenth of the way from its current {\itshape x}-\/position to the target {\itshape x}-\/position with each application. Higher values moves nodes more quickly to the target position, often at the expense of other forces or constraints. A value outside the range \mbox{[}0,1\mbox{]} is not recommended.

If {\itshape strength} is not specified, returns the current strength accessor, which defaults to\+:


\begin{DoxyCode}
function strength() \{
  return 0.1;
\}
\end{DoxyCode}


The strength accessor is invoked for each \href{#simulation_nodes}{\tt node} in the simulation, being passed the {\itshape node} and its zero-\/based {\itshape index}. The resulting number is then stored internally, such that the strength of each node is only recomputed when the force is initialized or when this method is called with a new {\itshape strength}, and not on every application of the force.

\label{_x_x}%
\# {\itshape x}.{\bfseries x}(\mbox{[}{\itshape x}\mbox{]}) \href{https://github.com/d3/d3-force/blob/master/src/x.js#L36}{\tt $<$$>$}

If {\itshape x} is specified, sets the {\itshape x}-\/coordinate accessor to the specified number or function, re-\/evaluates the {\itshape x}-\/accessor for each node, and returns this force. If {\itshape x} is not specified, returns the current {\itshape x}-\/accessor, which defaults to\+:


\begin{DoxyCode}
function x() \{
  return 0;
\}
\end{DoxyCode}


The {\itshape x}-\/accessor is invoked for each \href{#simulation_nodes}{\tt node} in the simulation, being passed the {\itshape node} and its zero-\/based {\itshape index}. The resulting number is then stored internally, such that the target {\itshape x}-\/coordinate of each node is only recomputed when the force is initialized or when this method is called with a new {\itshape x}, and not on every application of the force.

\label{_forceY}%
\# d3.{\bfseries forceY}(\mbox{[}{\itshape y}\mbox{]}) \href{https://github.com/d3/d3-force/blob/master/src/y.js}{\tt $<$$>$}

Creates a new positioning force along the {\itshape y}-\/axis towards the given position \href{#y_y}{\tt {\itshape y}}. If {\itshape y} is not specified, it defaults to 0.

\label{_y_strength}%
\# {\itshape y}.{\bfseries strength}(\mbox{[}{\itshape strength}\mbox{]}) \href{https://github.com/d3/d3-force/blob/master/src/y.js#L32}{\tt $<$$>$}

If {\itshape strength} is specified, sets the strength accessor to the specified number or function, re-\/evaluates the strength accessor for each node, and returns this force. The {\itshape strength} determines how much to increment the node’s {\itshape y}-\/velocity\+: (\href{#y_y}{\tt {\itshape y}} -\/ {\itshape node}.y) × {\itshape strength}. For example, a value of 0.\+1 indicates that the node should move a tenth of the way from its current {\itshape y}-\/position to the target {\itshape y}-\/position with each application. Higher values moves nodes more quickly to the target position, often at the expense of other forces or constraints. A value outside the range \mbox{[}0,1\mbox{]} is not recommended.

If {\itshape strength} is not specified, returns the current strength accessor, which defaults to\+:


\begin{DoxyCode}
function strength() \{
  return 0.1;
\}
\end{DoxyCode}


The strength accessor is invoked for each \href{#simulation_nodes}{\tt node} in the simulation, being passed the {\itshape node} and its zero-\/based {\itshape index}. The resulting number is then stored internally, such that the strength of each node is only recomputed when the force is initialized or when this method is called with a new {\itshape strength}, and not on every application of the force.

\label{_y_y}%
\# {\itshape y}.{\bfseries y}(\mbox{[}{\itshape y}\mbox{]}) \href{https://github.com/d3/d3-force/blob/master/src/y.js#L36}{\tt $<$$>$}

If {\itshape y} is specified, sets the {\itshape y}-\/coordinate accessor to the specified number or function, re-\/evaluates the {\itshape y}-\/accessor for each node, and returns this force. If {\itshape y} is not specified, returns the current {\itshape y}-\/accessor, which defaults to\+:


\begin{DoxyCode}
function y() \{
  return 0;
\}
\end{DoxyCode}


The {\itshape y}-\/accessor is invoked for each \href{#simulation_nodes}{\tt node} in the simulation, being passed the {\itshape node} and its zero-\/based {\itshape index}. The resulting number is then stored internally, such that the target {\itshape y}-\/coordinate of each node is only recomputed when the force is initialized or when this method is called with a new {\itshape y}, and not on every application of the force.

\label{_forceRadial}%
\# d3.{\bfseries force\+Radial}({\itshape radius}\mbox{[}, {\itshape x}\mbox{]}\mbox{[}, {\itshape y}\mbox{]}) \href{https://github.com/d3/d3-force/blob/master/src/radial.js}{\tt $<$$>$}

Creates a new positioning force towards a circle of the specified \href{#radial_radius}{\tt {\itshape radius}} centered at ⟨\href{#radial_x}{\tt {\itshape x}},\href{#radial_y}{\tt {\itshape y}}⟩. If {\itshape x} and {\itshape y} are not specified, they default to ⟨0,0⟩.

\label{_radial_strength}%
\# {\itshape radial}.{\bfseries strength}(\mbox{[}{\itshape strength}\mbox{]}) \href{https://github.com/d3/d3-force/blob/master/src/radial.js}{\tt $<$$>$}

If {\itshape strength} is specified, sets the strength accessor to the specified number or function, re-\/evaluates the strength accessor for each node, and returns this force. The {\itshape strength} determines how much to increment the node’s {\itshape x}-\/ and {\itshape y}-\/velocity. For example, a value of 0.\+1 indicates that the node should move a tenth of the way from its current position to the closest point on the circle with each application. Higher values moves nodes more quickly to the target position, often at the expense of other forces or constraints. A value outside the range \mbox{[}0,1\mbox{]} is not recommended.

If {\itshape strength} is not specified, returns the current strength accessor, which defaults to\+:


\begin{DoxyCode}
function strength() \{
  return 0.1;
\}
\end{DoxyCode}


The strength accessor is invoked for each \href{#simulation_nodes}{\tt node} in the simulation, being passed the {\itshape node} and its zero-\/based {\itshape index}. The resulting number is then stored internally, such that the strength of each node is only recomputed when the force is initialized or when this method is called with a new {\itshape strength}, and not on every application of the force.

\label{_radial_radius}%
\# {\itshape radial}.{\bfseries radius}(\mbox{[}{\itshape radius}\mbox{]}) \href{https://github.com/d3/d3-force/blob/master/src/radial.js}{\tt $<$$>$}

If {\itshape radius} is specified, sets the circle {\itshape radius} to the specified number or function, re-\/evaluates the {\itshape radius} accessor for each node, and returns this force. If {\itshape radius} is not specified, returns the current {\itshape radius} accessor.

The {\itshape radius} accessor is invoked for each \href{#simulation_nodes}{\tt node} in the simulation, being passed the {\itshape node} and its zero-\/based {\itshape index}. The resulting number is then stored internally, such that the target radius of each node is only recomputed when the force is initialized or when this method is called with a new {\itshape radius}, and not on every application of the force.

\label{_radial_x}%
\# {\itshape radial}.{\bfseries x}(\mbox{[}{\itshape x}\mbox{]}) \href{https://github.com/d3/d3-force/blob/master/src/radial.js}{\tt $<$$>$}

If {\itshape x} is specified, sets the {\itshape x}-\/coordinate of the circle center to the specified number and returns this force. If {\itshape x} is not specified, returns the current {\itshape x}-\/coordinate of the center, which defaults to zero.

\label{_radial_y}%
\# {\itshape radial}.{\bfseries y}(\mbox{[}{\itshape y}\mbox{]}) \href{https://github.com/d3/d3-force/blob/master/src/radial.js}{\tt $<$$>$}

If {\itshape y} is specified, sets the {\itshape y}-\/coordinate of the circle center to the specified number and returns this force. If {\itshape y} is not specified, returns the current {\itshape y}-\/coordinate of the center, which defaults to zero. 