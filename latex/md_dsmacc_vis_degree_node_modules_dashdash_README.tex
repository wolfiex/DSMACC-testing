A light, featureful and explicit option parsing library for node.\+js.

\href{#why}{\tt Why another one? See below}. tl;dr\+: The others I\textquotesingle{}ve tried are one of too loosey goosey (not explicit), too big/too many deps, or ill specified. Y\+M\+MV.

Follow \href{https://twitter.com/intent/user?screen_name=trentmick}{\tt } for updates to node-\/dashdash.

\section*{Install}

\begin{DoxyVerb}npm install dashdash
\end{DoxyVerb}


\section*{Usage}

\`{}\`{}`javascript var dashdash = require(\textquotesingle{}dashdash');

// Specify the options. Minimally {\ttfamily name} (or {\ttfamily names}) and {\ttfamily type} // must be given for each. var options = \mbox{[} \{ // {\ttfamily names} or a single {\ttfamily name}. First element is the {\ttfamily opts.\+K\+EY}. names\+: \mbox{[}\textquotesingle{}help\textquotesingle{}, \textquotesingle{}h\textquotesingle{}\mbox{]}, // See \char`\"{}\+Option specs\char`\"{} below for types. type\+: \textquotesingle{}bool\textquotesingle{}, help\+: \textquotesingle{}Print this help and exit.\textquotesingle{} \} \mbox{]};

// Shortcut form. As called it infers {\ttfamily process.\+argv}. See below for // the longer form to use methods like {\ttfamily .help()} on the Parser object. var opts = dashdash.\+parse(\{options\+: options\});

console.\+log(\char`\"{}opts\+:\char`\"{}, opts); console.\+log(\char`\"{}args\+:\char`\"{}, opts.\+\_\+args); 
\begin{DoxyCode}
# Longer Example

A more realistic [starter script "foo.js"](./examples/foo.js) is as follows.
This also shows using `parser.help()` for formatted option help.

```javascript
var dashdash = require('./lib/dashdash');

var options = [
    \{
        name: 'version',
        type: 'bool',
        help: 'Print tool version and exit.'
    \},
    \{
        names: ['help', 'h'],
        type: 'bool',
        help: 'Print this help and exit.'
    \},
    \{
        names: ['verbose', 'v'],
        type: 'arrayOfBool',
        help: 'Verbose output. Use multiple times for more verbose.'
    \},
    \{
        names: ['file', 'f'],
        type: 'string',
        help: 'File to process',
        helpArg: 'FILE'
    \}
];

var parser = dashdash.createParser(\{options: options\});
try \{
    var opts = parser.parse(process.argv);
\} catch (e) \{
    console.error('foo: error: %s', e.message);
    process.exit(1);
\}

console.log("# opts:", opts);
console.log("# args:", opts.\_args);

// Use `parser.help()` for formatted options help.
if (opts.help) \{
    var help = parser.help(\{includeEnv: true\}).trimRight();
    console.log('usage: node foo.js [OPTIONS]\(\backslash\)n'
                + 'options:\(\backslash\)n'
                + help);
    process.exit(0);
\}

// ...
\end{DoxyCode}


Some example output from this script (foo.\+js)\+:


\begin{DoxyCode}
$ node foo.js -h
# opts: \{ help: true,
  \_order: [ \{ name: 'help', value: true, from: 'argv' \} ],
  \_args: [] \}
# args: []
usage: node foo.js [OPTIONS]
options:
    --version             Print tool version and exit.
    -h, --help            Print this help and exit.
    -v, --verbose         Verbose output. Use multiple times for more verbose.
    -f FILE, --file=FILE  File to process

$ node foo.js -v
# opts: \{ verbose: [ true ],
  \_order: [ \{ name: 'verbose', value: true, from: 'argv' \} ],
  \_args: [] \}
# args: []

$ node foo.js --version arg1
# opts: \{ version: true,
  \_order: [ \{ name: 'version', value: true, from: 'argv' \} ],
  \_args: [ 'arg1' ] \}
# args: [ 'arg1' ]

$ node foo.js -f bar.txt
# opts: \{ file: 'bar.txt',
  \_order: [ \{ name: 'file', value: 'bar.txt', from: 'argv' \} ],
  \_args: [] \}
# args: []

$ node foo.js -vvv --file=blah
# opts: \{ verbose: [ true, true, true ],
  file: 'blah',
  \_order:
   [ \{ name: 'verbose', value: true, from: 'argv' \},
     \{ name: 'verbose', value: true, from: 'argv' \},
     \{ name: 'verbose', value: true, from: 'argv' \},
     \{ name: 'file', value: 'blah', from: 'argv' \} ],
  \_args: [] \}
# args: []
\end{DoxyCode}


See the \href{examples/}{\tt \char`\"{}examples\char`\"{}} dir for a number of starter examples using some of dashdash\textquotesingle{}s features.

\section*{Environment variable integration}

If you want to allow environment variables to specify options to your tool, dashdash makes this easy. We can change the \textquotesingle{}verbose\textquotesingle{} option in the example above to include an \textquotesingle{}env\textquotesingle{} field\+:


\begin{DoxyCode}
\{
    names: ['verbose', 'v'],
    type: 'arrayOfBool',
    env: 'FOO\_VERBOSE',         // <--- add this line
    help: 'Verbose output. Use multiple times for more verbose.'
\},
\end{DoxyCode}


then the $\ast$$\ast$\char`\"{}\+F\+O\+O\+\_\+\+V\+E\+R\+B\+O\+S\+E\char`\"{} environment variable$\ast$$\ast$ can be used to set this option\+:


\begin{DoxyCode}
$ FOO\_VERBOSE=1 node foo.js
# opts: \{ verbose: [ true ],
  \_order: [ \{ name: 'verbose', value: true, from: 'env' \} ],
  \_args: [] \}
# args: []
\end{DoxyCode}


Boolean options will interpret the empty string as unset, \textquotesingle{}0\textquotesingle{} as false and anything else as true.


\begin{DoxyCode}
$ FOO\_VERBOSE= node examples/foo.js                 # not set
# opts: \{ \_order: [], \_args: [] \}
# args: []

$ FOO\_VERBOSE=0 node examples/foo.js                # '0' is false
# opts: \{ verbose: [ false ],
  \_order: [ \{ key: 'verbose', value: false, from: 'env' \} ],
  \_args: [] \}
# args: []

$ FOO\_VERBOSE=1 node examples/foo.js                # true
# opts: \{ verbose: [ true ],
  \_order: [ \{ key: 'verbose', value: true, from: 'env' \} ],
  \_args: [] \}
# args: []

$ FOO\_VERBOSE=boogabooga node examples/foo.js       # true
# opts: \{ verbose: [ true ],
  \_order: [ \{ key: 'verbose', value: true, from: 'env' \} ],
  \_args: [] \}
# args: []
\end{DoxyCode}


Non-\/booleans can be used as well. Strings\+:


\begin{DoxyCode}
$ FOO\_FILE=data.txt node examples/foo.js
# opts: \{ file: 'data.txt',
  \_order: [ \{ key: 'file', value: 'data.txt', from: 'env' \} ],
  \_args: [] \}
# args: []
\end{DoxyCode}


Numbers\+:


\begin{DoxyCode}
$ FOO\_TIMEOUT=5000 node examples/foo.js
# opts: \{ timeout: 5000,
  \_order: [ \{ key: 'timeout', value: 5000, from: 'env' \} ],
  \_args: [] \}
# args: []

$ FOO\_TIMEOUT=blarg node examples/foo.js
foo: error: arg for "FOO\_TIMEOUT" is not a positive integer: "blarg"
\end{DoxyCode}


With the {\ttfamily include\+Env\+: true} config to {\ttfamily parser.\+help()} the environment variable can also be included in {\bfseries help output}\+: \begin{DoxyVerb}usage: node foo.js [OPTIONS]
options:
    --version             Print tool version and exit.
    -h, --help            Print this help and exit.
    -v, --verbose         Verbose output. Use multiple times for more verbose.
                          Environment: FOO_VERBOSE=1
    -f FILE, --file=FILE  File to process
\end{DoxyVerb}


\section*{Bash completion}

Dashdash provides a simple way to create a Bash completion file that you can place in your \char`\"{}bash\+\_\+completion.\+d\char`\"{} directory -- sometimes that is \char`\"{}/usr/local/etc/bash\+\_\+completion.\+d/\char`\"{}). Features\+:


\begin{DoxyItemize}
\item Support for short and long opts
\item Support for knowing which options take arguments
\item Support for subcommands (e.\+g. \textquotesingle{}git log $<$\+T\+A\+B$>$\textquotesingle{} to show just options for the log subcommand). See \href{https://github.com/trentm/node-cmdln#bash-completion}{\tt node-\/cmdln} for how to integrate that.
\item Does the right thing with \char`\"{}-\/-\/\char`\"{} to stop options.
\item Custom optarg and arg types for custom completions.
\end{DoxyItemize}

Dashdash will return bash completion file content given a parser instance\+: \begin{DoxyVerb}var parser = dashdash.createParser({options: options});
console.log( parser.bashCompletion({name: 'mycli'}) );
\end{DoxyVerb}


or directly from a {\ttfamily options} array of options specs\+: \begin{DoxyVerb}var code = dashdash.bashCompletionFromOptions({
    name: 'mycli',
    options: OPTIONS
});
\end{DoxyVerb}


Write that content to \char`\"{}/usr/local/etc/bash\+\_\+completion.\+d/mycli\char`\"{} and you will have Bash completions for {\ttfamily mycli}. Alternatively you can write it to any file (e.\+g. \char`\"{}$\sim$/.\+bashrc\char`\"{}) and source it.

You could add a {\ttfamily -\/-\/completion} hidden option to your tool that emits the completion content and document for your users to call that to install Bash completions.

See \href{examples/ddcompletion.js}{\tt examples/ddcompletion.\+js} for a complete example, including how one can define bash functions for completion of custom option types. Also see \href{https://github.com/trentm/node-cmdln}{\tt node-\/cmdln} for how it uses this for Bash completion for full multi-\/subcommand tools.


\begin{DoxyItemize}
\item T\+O\+DO\+: document spec\+Extra
\item T\+O\+DO\+: document include\+Hidden
\item T\+O\+DO\+: document custom types, {\ttfamily function complete\textbackslash{}\+\_\+\+F\+OO} guide, completion\+Type
\item T\+O\+DO\+: document argtypes
\end{DoxyItemize}

\section*{Parser config}

Parser construction (i.\+e. {\ttfamily dashdash.\+create\+Parser(\+C\+O\+N\+F\+I\+G)}) takes the following fields\+:


\begin{DoxyItemize}
\item {\ttfamily options} (Array of option specs). Required. See the \href{#option-specs}{\tt Option specs} section below.
\item {\ttfamily interspersed} (Boolean). Optional. Default is true. If true this allows interspersed arguments and options. I.\+e.\+: \begin{DoxyVerb}  node ./tool.js -v arg1 arg2 -h   # '-h' is after interspersed args
\end{DoxyVerb}


Set it to false to have \textquotesingle{}-\/h\textquotesingle{} {\bfseries not} get parsed as an option in the above example.
\item {\ttfamily allow\+Unknown} (Boolean). Optional. Default is false. If false, this causes unknown arguments to throw an error. I.\+e.\+: \begin{DoxyVerb}  node ./tool.js -v arg1 --afe8asefksjefhas
\end{DoxyVerb}


Set it to true to treat the unknown option as a positional argument.

{\bfseries Caveat}\+: When a shortopt group, such as {\ttfamily -\/xaz} contains a mix of known and unknown options, the {\itshape entire} group is passed through unmolested as a positional argument.

Consider if you have a known short option {\ttfamily -\/a}, and parse the following command line\+: \begin{DoxyVerb}  node ./tool.js -xaz
\end{DoxyVerb}


where {\ttfamily -\/x} and {\ttfamily -\/z} are unknown. There are multiple ways to interpret this\+:
\begin{DoxyEnumerate}
\item {\ttfamily -\/x} takes a value\+: `\{x\+: \textquotesingle{}az'\}{\ttfamily  2.}-\/x{\ttfamily and}-\/z{\ttfamily are both booleans\+:}\{x\+:true,a\+:true,z\+:true\}\`{}
\end{DoxyEnumerate}

Since dashdash does not know what {\ttfamily -\/x} and {\ttfamily -\/z} are, it can\textquotesingle{}t know if you\textquotesingle{}d prefer to receive `\{a\+:true,\+\_\+args\+:\mbox{[}'-\/x\textquotesingle{},\textquotesingle{}-\/z\textquotesingle{}\mbox{]}\}{\ttfamily or }\{x\+:\textquotesingle{}az\textquotesingle{}\}{\ttfamily , or}\{\+\_\+args\+:\mbox{[}\textquotesingle{}-\/xaz\textquotesingle{}\mbox{]}\}\`{}. Leaving the positional arg unprocessed is the easiest mistake for the user to recover from.
\end{DoxyItemize}

\section*{\mbox{\hyperlink{structOption}{Option}} specs}

Example using all fields (required fields are noted)\+:


\begin{DoxyCode}
\{
    names: ['file', 'f'],       // Required (one of `names` or `name`).
    type: 'string',             // Required.
    completionType: 'filename',
    env: 'MYTOOL\_FILE',
    help: 'Config file to load before running "mytool"',
    helpArg: 'PATH',
    helpWrap: false,
    default: path.resolve(process.env.HOME, '.mytoolrc')
\}
\end{DoxyCode}


Each option spec in the {\ttfamily options} array must/can have the following fields\+:


\begin{DoxyItemize}
\item {\ttfamily name} (String) or {\ttfamily names} (Array). Required. These give the option name and aliases. The first name (if more than one given) is the key for the parsed {\ttfamily opts} object.
\item {\ttfamily type} (String). Required. One of\+:
\begin{DoxyItemize}
\item bool
\item string
\item number
\item integer
\item positive\+Integer
\item date (epoch seconds, e.\+g. 1396031701, or I\+SO 8601 format {\ttfamily Y\+Y\+Y\+Y-\/\+M\+M-\/\+DD\mbox{[}T\+H\+H\+:\+MM\+:SS\mbox{[}.sss\mbox{]}\mbox{[}Z\mbox{]}\mbox{]}}, e.\+g. \char`\"{}2014-\/03-\/28\+T18\+:35\+:01.\+489\+Z\char`\"{})
\item array\+Of\+Bool
\item array\+Of\+String
\item array\+Of\+Number
\item array\+Of\+Integer
\item array\+Of\+Positive\+Integer
\item array\+Of\+Date
\end{DoxyItemize}

F\+W\+IW, these names attempt to match with asserts on \href{https://github.com/mcavage/node-assert-plus}{\tt assert-\/plus}. You can add your own custom option types with {\ttfamily dashdash.\+add\+Option\+Type}. See below.
\item {\ttfamily completion\+Type} (String). Optional. This is used for \href{#bash-completion}{\tt Bash completion} for an option argument. If not specified, then the value of {\ttfamily type} is used. Any string may be specified, but only the following values have meaning\+:
\begin{DoxyItemize}
\item {\ttfamily none}\+: Provide no completions.
\item {\ttfamily file}\+: Bash\textquotesingle{}s default completion (i.\+e. {\ttfamily complete -\/o default}), which includes filenames.
\item {\itshape Any string F\+OO for which a {\ttfamily function complete\+\_\+\+F\+OO} Bash function is defined.} This is for custom completions for a given tool. Typically these custom functions are provided in the {\ttfamily spec\+Extra} argument to {\ttfamily dashdash.\+bash\+Completion\+From\+Options()}. See \href{examples/ddcompletion.js}{\tt \char`\"{}examples/ddcompletion.\+js\char`\"{}} for an example.
\end{DoxyItemize}
\item {\ttfamily env} (String or Array of String). Optional. An environment variable name (or names) that can be used as a fallback for this option. For example, given a \char`\"{}foo.\+js\char`\"{} like this\+: \begin{DoxyVerb}  var options = [{names: ['dry-run', 'n'], env: 'FOO_DRY_RUN'}];
  var opts = dashdash.parse({options: options});
\end{DoxyVerb}


Both {\ttfamily node foo.\+js -\/-\/dry-\/run} and {\ttfamily F\+O\+O\+\_\+\+D\+R\+Y\+\_\+\+R\+UN=1 node foo.\+js} would result in {\ttfamily opts.\+dry\+\_\+run = true}.

An environment variable is only used as a fallback, i.\+e. it is ignored if the associated option is given in {\ttfamily argv}.
\item {\ttfamily help} (String). Optional. Used for {\ttfamily parser.\+help()} output.
\item {\ttfamily help\+Arg} (String). Optional. Used in help output as the placeholder for the option argument, e.\+g. the \char`\"{}\+P\+A\+T\+H\char`\"{} in\+: \begin{DoxyVerb}  ...
  -f PATH, --file=PATH    File to process
  ...
\end{DoxyVerb}

\item {\ttfamily help\+Wrap} (Boolean). Optional, default true. Set this to {\ttfamily false} to have that option\textquotesingle{}s {\ttfamily help} {\itshape not} be text wrapped in {\ttfamily $<$parser$>$.help()} output.
\item {\ttfamily default}. Optional. A default value used for this option, if the option isn\textquotesingle{}t specified in argv.
\item {\ttfamily hidden} (Boolean). Optional, default false. If true, help output will not include this option. See also the {\ttfamily include\+Hidden} option to {\ttfamily bash\+Completion\+From\+Options()} for \href{#bash-completion}{\tt Bash completion}.
\end{DoxyItemize}

\section*{\mbox{\hyperlink{structOption}{Option}} group headings}

You can add headings between option specs in the {\ttfamily options} array. To do so, simply add an object with only a {\ttfamily group} property -- the string to print as the heading for the subsequent options in the array. For example\+:


\begin{DoxyCode}
var options = [
    \{
        group: 'Armament Options'
    \},
    \{
        names: [ 'weapon', 'w' ],
        type: 'string'
    \},
    \{
        group: 'General Options'
    \},
    \{
        names: [ 'help', 'h' ],
        type: 'bool'
    \}
];
...
\end{DoxyCode}


Note\+: You can use an empty string, `\{group\+: '\textquotesingle{}\}\`{}, to get a blank line in help output between groups of options.

\section*{Help config}

The {\ttfamily parser.\+help(...)} function is configurable as follows\+: \begin{DoxyVerb}    Options:
      Armament Options:
    ^^  -w WEAPON, --weapon=WEAPON  Weapon with which to crush. One of: |
   /                                sword, spear, maul                  |
  /   General Options:                                                  |
 /      -h, --help                  Print this help and exit.           |
/   ^^^^                            ^                                   |
\       `-- indent                   `-- helpCol              maxCol ---'
 `-- headingIndent
\end{DoxyVerb}



\begin{DoxyItemize}
\item {\ttfamily indent} (Number or String). Default 4. Set to a number (for that many spaces) or a string for the literal indent.
\item {\ttfamily heading\+Indent} (Number or String). Default half length of {\ttfamily indent}. Set to a number (for that many spaces) or a string for the literal indent. This indent applies to group heading lines, between normal option lines.
\item {\ttfamily name\+Sort} (String). Default is \textquotesingle{}length\textquotesingle{}. By default the names are sorted to put the short opts first (i.\+e. \textquotesingle{}-\/h, --help\textquotesingle{} preferred to \textquotesingle{}--help, -\/h\textquotesingle{}). Set to \textquotesingle{}none\textquotesingle{} to not do this sorting.
\item {\ttfamily max\+Col} (Number). Default 80. Note that reflow is just done on whitespace so a long token in the option help can overflow max\+Col.
\item {\ttfamily help\+Col} (Number). If not set a reasonable value will be determined between {\ttfamily min\+Help\+Col} and {\ttfamily max\+Help\+Col}.
\item {\ttfamily min\+Help\+Col} (Number). Default 20.
\item {\ttfamily max\+Help\+Col} (Number). Default 40.
\item {\ttfamily help\+Wrap} (Boolean). Default true. Set to {\ttfamily false} to have option {\ttfamily help} strings {\itshape not} be textwrapped to the help\+Col..max\+Col range.
\item {\ttfamily include\+Env} (Boolean). Default false. If the option has associated environment variables (via the {\ttfamily env} option spec attribute), then append mentioned of those envvars to the help string.
\item {\ttfamily include\+Default} (Boolean). Default false. If the option has a default value (via the {\ttfamily default} option spec attribute, or a default on the option\textquotesingle{}s type), then a \char`\"{}\+Default\+: V\+A\+L\+U\+E\char`\"{} string will be appended to the help string.
\end{DoxyItemize}

\section*{Custom option types}

Dashdash includes a good starter set of option types that it will parse for you. However, you can add your own via\+: \begin{DoxyVerb}var dashdash = require('dashdash');
dashdash.addOptionType({
    name: '...',
    takesArg: true,
    helpArg: '...',
    parseArg: function (option, optstr, arg) {
        ...
    },
    array: false,  // optional
    arrayFlatten: false,  // optional
    default: ...,   // optional
    completionType: ...  // optional
});
\end{DoxyVerb}


For example, a simple option type that accepts \textquotesingle{}yes\textquotesingle{}, \textquotesingle{}y\textquotesingle{}, \textquotesingle{}no\textquotesingle{} or \textquotesingle{}n\textquotesingle{} as a boolean argument would look like\+: \begin{DoxyVerb}var dashdash = require('dashdash');

function parseYesNo(option, optstr, arg) {
    var argLower = arg.toLowerCase()
    if (~['yes', 'y'].indexOf(argLower)) {
        return true;
    } else if (~['no', 'n'].indexOf(argLower)) {
        return false;
    } else {
        throw new Error(format(
            'arg for "%s" is not "yes" or "no": "%s"',
            optstr, arg));
    }
}

dashdash.addOptionType({
    name: 'yesno'
    takesArg: true,
    helpArg: '<yes|no>',
    parseArg: parseYesNo
});

var options = {
    {names: ['answer', 'a'], type: 'yesno'}
};
var opts = dashdash.parse({options: options});
\end{DoxyVerb}


See \char`\"{}examples/custom-\/option-\/\textbackslash{}$\ast$.\+js\char`\"{} for other examples. See the {\ttfamily add\+Option\+Type} block comment in \char`\"{}lib/dashdash.\+js\char`\"{} for more details. Please let me know \href{https://github.com/trentm/node-dashdash/issues/new}{\tt with an issue} if you write a generally useful one.

\section*{Why}

Why another node.\+js option parsing lib?


\begin{DoxyItemize}
\item {\ttfamily nopt} really is just for \char`\"{}tools like npm\char`\"{}. Implicit opts (e.\+g. \textquotesingle{}--no-\/foo\textquotesingle{} works for every \textquotesingle{}--foo\textquotesingle{}). Can\textquotesingle{}t disable abbreviated opts. Can\textquotesingle{}t do multiple usages of same opt, e.\+g. \textquotesingle{}-\/vvv\textquotesingle{} (I think). Can\textquotesingle{}t do grouped short opts.
\item {\ttfamily optimist} has surprise interpretation of options (at least to me). Implicit opts mean ambiguities and poor error handling for fat-\/fingering. {\ttfamily process.\+exit} calls makes it hard to use as a libary.
\item {\ttfamily optparse} Incomplete docs. Is this an attempted clone of Python\textquotesingle{}s {\ttfamily optparse}. Not clear. Some divergence. {\ttfamily parser.\+on(\char`\"{}name\char`\"{}, ...)} A\+PI is weird.
\item {\ttfamily argparse} Dep on underscore. No thanks just for option processing. {\ttfamily find lib $\vert$ wc -\/l} -\/$>$ {\ttfamily 26}. Overkill. Argparse is a bit different anyway. Not sure I want that.
\item {\ttfamily posix-\/getopt} No type validation. Though that isn\textquotesingle{}t a killer. A\+F\+A\+IK can\textquotesingle{}t have a long opt without a short alias. I.\+e. no {\ttfamily getopt\+\_\+long} semantics. Also, no whizbang features like generated help output.
\item \href{https://github.com/visionmedia/commander.js}{\tt \char`\"{}commander.\+js\char`\"{}}\+: I wrote \href{http://trentm.com/2014/01/a-critique-of-commander-for-nodejs.html}{\tt a critique} a while back. It seems fine, but last I checked had \href{https://github.com/visionmedia/commander.js/pull/121}{\tt an outstanding bug} that would prevent me from using it.
\end{DoxyItemize}

\section*{License}

M\+IT. See L\+I\+C\+E\+N\+S\+E.\+txt. 