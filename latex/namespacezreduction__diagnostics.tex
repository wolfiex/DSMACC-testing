\hypertarget{namespacezreduction__diagnostics}{}\section{zreduction\+\_\+diagnostics Namespace Reference}
\label{namespacezreduction__diagnostics}\index{zreduction\+\_\+diagnostics@{zreduction\+\_\+diagnostics}}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
def \mbox{\hyperlink{namespacezreduction__diagnostics_a42c5959d3e8fa7583245637112b84961}{undirect}} (self)
\end{DoxyCompactItemize}
\subsection*{Variables}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{namespacezreduction__diagnostics_a37db539398db5c40c1970b992b1d7c8c}\label{namespacezreduction__diagnostics_a37db539398db5c40c1970b992b1d7c8c}} 
int {\bfseries ncores} = 50
\end{DoxyCompactItemize}


\subsection{Detailed Description}
\begin{DoxyVerb}Insparation from using the google csc_matrix
https://github.com/networkx/networkx/blob/2db5f8663deacc501c7472c3a60884a2ca8be45a/networkx/algorithms/link_analysis/pagerank_alg.py
\end{DoxyVerb}
 

\subsection{Function Documentation}
\mbox{\Hypertarget{namespacezreduction__diagnostics_a42c5959d3e8fa7583245637112b84961}\label{namespacezreduction__diagnostics_a42c5959d3e8fa7583245637112b84961}} 
\index{zreduction\+\_\+diagnostics@{zreduction\+\_\+diagnostics}!undirect@{undirect}}
\index{undirect@{undirect}!zreduction\+\_\+diagnostics@{zreduction\+\_\+diagnostics}}
\subsubsection{\texorpdfstring{undirect()}{undirect()}}
{\footnotesize\ttfamily def zreduction\+\_\+diagnostics.\+undirect (\begin{DoxyParamCaption}\item[{}]{self }\end{DoxyParamCaption})}

\begin{DoxyVerb}Remove directional links between species by finding the net weight of the jacobian
\end{DoxyVerb}
 
\begin{DoxyCode}
20 \textcolor{keyword}{def }undirect(self):
21     \textcolor{stringliteral}{'''}
22 \textcolor{stringliteral}{    Remove directional links between species by finding the net weight of the jacobian}
23 \textcolor{stringliteral}{    '''}
24 
25     dct=\{\}
26     specs = self.spec.columns
27     iterate = []
28     \textcolor{keywordflow}{for} i \textcolor{keywordflow}{in} specs:
29         \textcolor{keywordflow}{for} j \textcolor{keywordflow}{in} specs:
30             \textcolor{keywordflow}{if} i==j: \textcolor{keywordflow}{break}
31             iterate.append(list(set([i,j])))
32 
33     \textcolor{keywordflow}{print} iterate
34 
35 
36     self = self.jacsp.compute()
37 
38 
39     \textcolor{keyword}{def }net(d):
40         ret = []
41         \textcolor{keywordflow}{for} n \textcolor{keywordflow}{in} d:
42             total =[]
43             \textcolor{keywordflow}{try}: total.append(self[\textcolor{stringliteral}{'%s->%s'}%(n[0],n[1])])
44             \textcolor{keywordflow}{except}:\textcolor{keywordtype}{None}
45             \textcolor{keywordflow}{try}: total.append(-self[\textcolor{stringliteral}{'%s->%s'}%(n[1],n[0])])
46             \textcolor{keywordflow}{except}:\textcolor{keywordtype}{None}
47 
48             \textcolor{keywordflow}{if} len(total) > 0 :
49                 ret.append([\textcolor{stringliteral}{'->'}.join(n), sum(total)])
50         \textcolor{keywordflow}{return} ret
51 
52     dct = ProcessPool(nodes=ncores).amap(net,np.array\_split(iterate,ncores))
53 
54     \textcolor{keywordflow}{while} \textcolor{keywordflow}{not} dct.ready():
55          time.sleep(5); print(\textcolor{stringliteral}{"."})
56 
57     dct = dct.get()
58 
59     \textcolor{keywordflow}{return} dict([i \textcolor{keywordflow}{for} j \textcolor{keywordflow}{in} dct \textcolor{keywordflow}{for} i \textcolor{keywordflow}{in} j])
60 
61 
62 \textcolor{stringliteral}{'''}
63 \textcolor{stringliteral}{import zhdf}
64 \textcolor{stringliteral}{a = zhdf.new("../lhs\_spinup\_training.h5")}
65 \textcolor{stringliteral}{a.rm\_spinup()}
66 \textcolor{stringliteral}{b = zhdf.new("../lhs\_spinup.h5")}
67 \textcolor{stringliteral}{b.rm\_spinup()}
68 \textcolor{stringliteral}{}
69 \textcolor{stringliteral}{a = undirect(a)}
70 \textcolor{stringliteral}{b = undirect(b)}
71 \textcolor{stringliteral}{}
72 \textcolor{stringliteral}{}
73 \textcolor{stringliteral}{lumped = '../mechanisms/lumped\_formatted\_CRI\_FULL\_2.2\_inorganics\_True.kpp'}
74 \textcolor{stringliteral}{import re}
75 \textcolor{stringliteral}{header = a.keys()}
76 \textcolor{stringliteral}{lumped = open(lumped).readlines()}
77 \textcolor{stringliteral}{lumped = re.findall(r'(LMP\(\backslash\)d+): ([\(\backslash\)w,]+)',''.join(lumped))}
78 \textcolor{stringliteral}{}
79 \textcolor{stringliteral}{print len(header)}
80 \textcolor{stringliteral}{newheader = []}
81 \textcolor{stringliteral}{}
82 \textcolor{stringliteral}{for n,l in lumped:}
83 \textcolor{stringliteral}{    sub = re.compile(r'\(\backslash\)b(%s)\(\backslash\)b'%(l.replace(',','|')))}
84 \textcolor{stringliteral}{    header = ['->'.join(list(set( sub.sub(n, i).split('->')))) if sub.match(n) else i for i in header]}
85 \textcolor{stringliteral}{}
86 \textcolor{stringliteral}{}
87 \textcolor{stringliteral}{a = dict(zip(header,a.values()))}
88 \textcolor{stringliteral}{a = pd.concat(a.values(),axis=1)}
89 \textcolor{stringliteral}{a.columns=header}
90 \textcolor{stringliteral}{a = a.groupby(by=a.columns,axis=1).agg(np.sum)}
91 \textcolor{stringliteral}{}
92 \textcolor{stringliteral}{b = pd.concat(b.values(),axis=1)}
93 \textcolor{stringliteral}{}
94 \textcolor{stringliteral}{}
95 \textcolor{stringliteral}{keep = list(set(a.keys()) & set(b.keys()))}
96 \textcolor{stringliteral}{dismiss = set(a.keys()) ^ set(b.keys())}
97 \textcolor{stringliteral}{}
98 \textcolor{stringliteral}{}
99 \textcolor{stringliteral}{print('ignoring',dismiss)}
100 \textcolor{stringliteral}{}
101 \textcolor{stringliteral}{}
102 \textcolor{stringliteral}{net\_edges = b[keep].divide(a[keep],axis=1)}
103 \textcolor{stringliteral}{'''}
104 
105 
106 nsp.log10normalise(zeronans = \textcolor{keyword}{True})
\end{DoxyCode}
