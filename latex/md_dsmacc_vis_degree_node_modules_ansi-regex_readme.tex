\begin{quote}
Regular expression for matching \href{http://en.wikipedia.org/wiki/ANSI_escape_code}{\tt A\+N\+SI escape codes} \end{quote}


\subsection*{Install}


\begin{DoxyCode}
$ npm install --save ansi-regex
\end{DoxyCode}


\subsection*{Usage}


\begin{DoxyCode}
const ansiRegex = require('ansi-regex');

ansiRegex().test('\(\backslash\)u001b[4mcake\(\backslash\)u001b[0m');
//=> true

ansiRegex().test('cake');
//=> false

'\(\backslash\)u001b[4mcake\(\backslash\)u001b[0m'.match(ansiRegex());
//=> ['\(\backslash\)u001b[4m', '\(\backslash\)u001b[0m']
\end{DoxyCode}


\subsection*{F\+AQ}

\subsubsection*{Why do you test for codes not in the E\+C\+MA 48 standard?}

Some of the codes we run as a test are codes that we acquired finding various lists of non-\/standard or manufacturer specific codes. If I recall correctly, we test for both standard and non-\/standard codes, as most of them follow the same or similar format and can be safely matched in strings without the risk of removing actual string content. There are a few non-\/standard control codes that do not follow the traditional format (i.\+e. they end in numbers) thus forcing us to exclude them from the test because we cannot reliably match them.

On the historical side, those E\+C\+MA standards were established in the early 90\textquotesingle{}s whereas the V\+T100, for example, was designed in the mid/late 70\textquotesingle{}s. At that point in time, control codes were still pretty ungoverned and engineers used them for a multitude of things, namely to activate hardware ports that may have been proprietary. Somewhere else you see a similar \textquotesingle{}anarchy\textquotesingle{} of codes is in the x86 architecture for processors; there are a ton of \char`\"{}interrupts\char`\"{} that can mean different things on certain brands of processors, most of which have been phased out.

\subsection*{License}

M\+IT Â© \href{http://sindresorhus.com}{\tt Sindre Sorhus} 