\subsection*{Synopsis}

Javascript does not natively support handling of unsigned 32 or 64 bits integers. This library provides that functionality, following C behaviour, enabling the writing of algorithms that depend on it. It was designed with performance in mind and tries its best to be as fast as possible. Any improvement is welcome!

\subsection*{How it works}

An unsigned 32 bits integer is represented by an object with its first 16 bits (low bits) and its 16 last ones (high bits). All the supported standard operations on the unsigned integer are then performed transparently. \begin{DoxyVerb}e.g.
10000010000100000100010000100010 (2182104098 or 0x82104422) is represented by:
high=1000001000010000
low= 0100010000100010
\end{DoxyVerb}


NB. In case of overflow, the unsigned integer is {\itshape truncated} to its lowest 32 bits (in case of U\+I\+N\+T32) or 64 bits (in case of U\+I\+N\+T64).

The same applies to 64 bits integers, which are split into 4 16 bits ones.

\subsection*{Installation}

In nodejs\+: \begin{DoxyVerb}npm install cuint
\end{DoxyVerb}


In the browser, include the following (file is located in the {\itshape build} directory), and access the constructor with {\itshape U\+I\+N\+T32}\+:

\`{}$<$script src=\char`\"{}/your/path/to/uint32.\+js\char`\"{}$>$$<$/script$>$ ... $<$script type=\char`\"{}text/javascript\char`\"{}$>$ var v1 = U\+I\+N\+T32(\textquotesingle{}326648991\textquotesingle{}); var v2 = U\+I\+N\+T32(\textquotesingle{}265443576\textquotesingle{}); var v1plus2 = v1.\+add(v2) // 592092567 $<$/script$>$\`{}

\subsection*{Usage}

To instantiate an unsigned 32 bits integer, do any of the following\+: \begin{DoxyVerb}var UINT32 = require('cuint').UINT32 // NodeJS
UINT32( <low bits>, <high bits> )
UINT32( <number> )
UINT32( '<number>', <radix> ) // radix = 10 by default
\end{DoxyVerb}


To instantiate an unsigned 64 bits integer, do any of the following\+: \begin{DoxyVerb}var UINT64 = require('cuint').UINT64 // NodeJS
UINT64( <low bits>, <high bits> )
UINT64( <first low bits>, <second low bits>, <first high bits>, <second high bits> )
UINT64( <number> )
UINT64( '<number>', <radix> ) // radix = 10 by default
\end{DoxyVerb}


\subsection*{Important}

Most methods {\bfseries do modify} the object they are applied to. For instance, the following is equivalent to {\ttfamily x += y} \begin{DoxyVerb}UINT(x).add( UINT(y) )
\end{DoxyVerb}


This allows for chaining and reduces the cost of the emulation. To have {\ttfamily z = x + y}, do the following\+: \begin{DoxyVerb}z = UINT(x).clone().add( UINT(y) )
\end{DoxyVerb}


\subsection*{Examples for U\+I\+N\+T32}


\begin{DoxyItemize}
\item Using low and high bits \begin{quote}
{\ttfamily U\+I\+N\+T32( 2, 1 ) // 65538} \{ remainder\+: null, \+\_\+low\+: 2, \+\_\+high\+: 1 \} \end{quote}

\item Using a number (signed 32 bits integer) \begin{quote}
{\ttfamily U\+I\+N\+T32( 65538 ) // 65538} \{ remainder\+: null, \+\_\+low\+: 2, \+\_\+high\+: 1 \} \end{quote}

\item Using a string \begin{quote}
`U\+I\+N\+T32( \textquotesingle{}65538' ) // 65538\`{} \{ remainder\+: null, \+\_\+low\+: 2, \+\_\+high\+: 1 \} \end{quote}

\item Using another string \begin{quote}
`U\+I\+N\+T32( \textquotesingle{}3266489917' )\`{} \{ remainder\+: null, \+\_\+low\+: 44605, \+\_\+high\+: 49842 \} \end{quote}

\item Divide 2 unsigned 32 bits integers -\/ note that the remainder is also provided \begin{quote}
`U\+I\+N\+T32( \textquotesingle{}3266489917' ).div( U\+I\+N\+T32( \textquotesingle{}668265263\textquotesingle{} ) )\`{} \{ remainder\+: \{ remainder\+: null , \+\_\+low\+: 385 , \+\_\+high\+: 9055 \} , \+\_\+low\+: 4 , \+\_\+high\+: 0 \} \end{quote}

\end{DoxyItemize}

\subsection*{Examples for U\+I\+N\+T64}


\begin{DoxyItemize}
\item Using low and high bits \begin{quote}
{\ttfamily U\+I\+N\+T64( 2, 1 ) // 4294967298} \{ remainder\+: null, \+\_\+a00\+: 2, \+\_\+a16\+: 0, \+\_\+a32\+: 1, \+\_\+a48\+: 0 \} \end{quote}

\item Using first/second low and high bits \begin{quote}
{\ttfamily U\+I\+N\+T64( 2, 1, 0, 0 ) // 65538} \{ remainder\+: null, \+\_\+a00\+: 2, \+\_\+a16\+: 1, \+\_\+a32\+: 0, \+\_\+a48\+: 0 \} \end{quote}

\item Using a number (signed 32 bits integer) \begin{quote}
{\ttfamily U\+I\+N\+T64( 65538 ) // 65538} \{ remainder\+: null, \+\_\+a00\+: 2, \+\_\+a16\+: 1, \+\_\+a32\+: 0, \+\_\+a48\+: 0 \} \end{quote}

\item Using a string \begin{quote}
`U\+I\+N\+T64( \textquotesingle{}65538' ) // 65538\`{} \{ remainder\+: null, \+\_\+a00\+: 2, \+\_\+a16\+: 1, \+\_\+a32\+: 0, \+\_\+a48\+: 0 \} \end{quote}

\item Using another string \begin{quote}
`U\+I\+N\+T64( \textquotesingle{}3266489917' )\`{} \{ remainder\+: null, \+\_\+a00\+: 44605, \+\_\+a16\+: 49842, \+\_\+a32\+: 0, \+\_\+a48\+: 0 \} \end{quote}

\item Divide 2 unsigned 64 bits integers -\/ note that the remainder is also provided \begin{quote}
`U\+I\+N\+T64( \textquotesingle{}F00000000000', 16 ).div( U\+I\+N\+T64( \textquotesingle{}800000000000\textquotesingle{}, 16 ) )\`{} \{ remainder\+: \{ remainder\+: null, \+\_\+a00\+: 0, \+\_\+a16\+: 0, \+\_\+a32\+: 28672, \+\_\+a48\+: 0 \}, \+\_\+a00\+: 1, \+\_\+a16\+: 0, \+\_\+a32\+: 0, \+\_\+a48\+: 0 \} \end{quote}

\end{DoxyItemize}

\subsection*{Methods}

Methods specific to {\itshape U\+I\+N\+T32} and {\itshape U\+I\+N\+T64}\+:


\begin{DoxyItemize}
\item {\ttfamily U\+I\+N\+T32.\+from\+Bits($<$low bits$>$, $<$high bits$>$)$\ast$} Set the current {\itshape U\+I\+N\+T32} object with its low and high bits
\item {\ttfamily U\+I\+N\+T64.\+from\+Bits($<$low bits$>$, $<$high bits$>$)$\ast$} Set the current {\itshape U\+I\+N\+T64} object with its low and high bits
\item {\ttfamily U\+I\+N\+T64.\+from\+Bits($<$first low bits$>$, $<$second low bits$>$, $<$first high bits$>$, $<$second high bits$>$)$\ast$} Set the current {\itshape U\+I\+N\+T64} object with all its low and high bits
\end{DoxyItemize}

Methods common to {\itshape U\+I\+N\+T32} and {\itshape U\+I\+N\+T64}\+:


\begin{DoxyItemize}
\item {\ttfamily U\+I\+N\+T.\+from\+Number($<$number$>$)$\ast$} Set the current {\itshape U\+I\+NT} object from a number (first 32 bits only)
\item {\ttfamily U\+I\+N\+T.\+from\+String($<$string$>$, $<$radix$>$)} Set the current {\itshape U\+I\+NT} object from a string
\item {\ttfamily U\+I\+N\+T.\+to\+Number()} Convert this {\itshape U\+I\+NT} to a number
\item {\ttfamily U\+I\+N\+T.\+to\+String($<$radix$>$)} Convert this {\itshape U\+I\+NT} to a string
\item {\ttfamily U\+I\+N\+T.\+add($<$uint$>$)$\ast$} Add two {\itshape U\+I\+NT}. The current {\itshape U\+I\+NT} stores the result
\item {\ttfamily U\+I\+N\+T.\+subtract($<$uint$>$)$\ast$} Subtract two {\itshape U\+I\+NT}. The current {\itshape U\+I\+NT} stores the result
\item {\ttfamily U\+I\+N\+T.\+multiply($<$uint$>$)$\ast$} Multiply two {\itshape U\+I\+NT}. The current {\itshape U\+I\+NT} stores the result
\item {\ttfamily U\+I\+N\+T.\+div($<$uint$>$)$\ast$} Divide two {\itshape U\+I\+NT}. The current {\itshape U\+I\+NT} stores the result. The remainder is made available as the {\itshape remainder} property on the {\itshape U\+I\+NT} object. It can be null, meaning there are no remainder.
\item {\ttfamily U\+I\+N\+T.\+negate()} Negate the current {\itshape U\+I\+NT}
\item {\ttfamily U\+I\+N\+T.\+equals($<$uint$>$)} alias {\ttfamily U\+I\+N\+T.\+eq($<$uint$>$)} Equals
\item {\ttfamily U\+I\+N\+T.\+less\+Than($<$uint$>$)} alias {\ttfamily U\+I\+N\+T.\+lt($<$uint$>$)} Less than (strict)
\item {\ttfamily U\+I\+N\+T.\+greater\+Than($<$uint$>$)} alias {\ttfamily U\+I\+N\+T.\+gt($<$uint$>$)} Greater than (strict)
\item {\ttfamily U\+I\+N\+T.\+not()} Bitwise N\+OT
\item {\ttfamily U\+I\+N\+T.\+or($<$uint$>$)$\ast$} Bitwise OR
\item {\ttfamily U\+I\+N\+T.\+and($<$uint$>$)$\ast$} Bitwise A\+ND
\item {\ttfamily U\+I\+N\+T.\+xor($<$uint$>$)$\ast$} Bitwise X\+OR
\item {\ttfamily U\+I\+N\+T.\+shift\+Right($<$number$>$)$\ast$} alias {\ttfamily U\+I\+N\+T.\+shiftr($<$number$>$)$\ast$} Bitwise shift right
\item {\ttfamily U\+I\+N\+T.\+shift\+Left($<$number$>$\mbox{[}, $<$allow\+Overflow$>$\mbox{]})$\ast$} alias {\ttfamily U\+I\+N\+T.\+shiftl($<$number$>$\mbox{[}, $<$allow\+Overflow$>$\mbox{]})$\ast$} Bitwise shift left
\item {\ttfamily U\+I\+N\+T.\+rotate\+Left($<$number$>$)$\ast$} alias {\ttfamily U\+I\+N\+T.\+rotl($<$number$>$)$\ast$} Bitwise rotate left
\item {\ttfamily U\+I\+N\+T.\+rotate\+Right($<$number$>$)$\ast$} alias {\ttfamily U\+I\+N\+T.\+rotr($<$number$>$)$\ast$} Bitwise rotate right
\item {\ttfamily U\+I\+N\+T.\+clone()} Clone the current {\itshape U\+I\+NT}
\end{DoxyItemize}

NB. methods with an $\ast$ do {\bfseries modify} the object it is applied to. Input objects are not modified.

\subsection*{T\+O\+DO}


\begin{DoxyItemize}
\item more methods\+:
\begin{DoxyItemize}
\item pow
\item log
\item sqrt
\item ...
\end{DoxyItemize}
\item signed version
\end{DoxyItemize}

\subsection*{License}

M\+IT

\begin{quote}
Written with \href{https://stackedit.io/}{\tt Stack\+Edit}.\end{quote}
