\hypertarget{classInfomapGreedyTypeSpecialized_3_01FlowType_00_01WithMemory_01_4}{}\section{Infomap\+Greedy\+Type\+Specialized$<$ Flow\+Type, With\+Memory $>$ Class Template Reference}
\label{classInfomapGreedyTypeSpecialized_3_01FlowType_00_01WithMemory_01_4}\index{Infomap\+Greedy\+Type\+Specialized$<$ Flow\+Type, With\+Memory $>$@{Infomap\+Greedy\+Type\+Specialized$<$ Flow\+Type, With\+Memory $>$}}
Inheritance diagram for Infomap\+Greedy\+Type\+Specialized$<$ Flow\+Type, With\+Memory $>$\+:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=3.486924cm]{classInfomapGreedyTypeSpecialized_3_01FlowType_00_01WithMemory_01_4}
\end{center}
\end{figure}
\subsection*{Public Types}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{classInfomapGreedyTypeSpecialized_3_01FlowType_00_01WithMemory_01_4_a391c023fa6a6f20343e03c1da75ded0f}\label{classInfomapGreedyTypeSpecialized_3_01FlowType_00_01WithMemory_01_4_a391c023fa6a6f20343e03c1da75ded0f}} 
typedef Flow\+Type {\bfseries flow\+\_\+type}
\end{DoxyCompactItemize}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{classInfomapGreedyTypeSpecialized_3_01FlowType_00_01WithMemory_01_4_acaff703219347cdecc57bd3269c3c140}\label{classInfomapGreedyTypeSpecialized_3_01FlowType_00_01WithMemory_01_4_acaff703219347cdecc57bd3269c3c140}} 
{\bfseries Infomap\+Greedy\+Type\+Specialized} (const \mbox{\hyperlink{structConfig}{Config}} \&conf)
\item 
\mbox{\Hypertarget{classInfomapGreedyTypeSpecialized_3_01FlowType_00_01WithMemory_01_4_aed0a200f517849998ea7d81b33df8ebd}\label{classInfomapGreedyTypeSpecialized_3_01FlowType_00_01WithMemory_01_4_aed0a200f517849998ea7d81b33df8ebd}} 
{\bfseries Infomap\+Greedy\+Type\+Specialized} (const \mbox{\hyperlink{classInfomapBase}{Infomap\+Base}} \&infomap)
\end{DoxyCompactItemize}
\subsection*{Protected Member Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{classInfomapGreedyTypeSpecialized_3_01FlowType_00_01WithMemory_01_4_af784da3d085139461da37195a499a0d6}\label{classInfomapGreedyTypeSpecialized_3_01FlowType_00_01WithMemory_01_4_af784da3d085139461da37195a499a0d6}} 
virtual std\+::auto\+\_\+ptr$<$ \mbox{\hyperlink{classInfomapBase}{Infomap\+Base}} $>$ {\bfseries get\+New\+Infomap\+Instance\+Without\+Memory} ()
\item 
\mbox{\Hypertarget{classInfomapGreedyTypeSpecialized_3_01FlowType_00_01WithMemory_01_4_af256d7fbcede47c289ac5523283fc836}\label{classInfomapGreedyTypeSpecialized_3_01FlowType_00_01WithMemory_01_4_af256d7fbcede47c289ac5523283fc836}} 
virtual bool {\bfseries pre\+Cluster\+Multiplex\+Network} (bool print\+Results=false)
\item 
\mbox{\Hypertarget{classInfomapGreedyTypeSpecialized_3_01FlowType_00_01WithMemory_01_4_a9dec24f211a79e1672d581bf1ddca828}\label{classInfomapGreedyTypeSpecialized_3_01FlowType_00_01WithMemory_01_4_a9dec24f211a79e1672d581bf1ddca828}} 
virtual unsigned int {\bfseries aggregate\+Flow\+Values\+From\+Leaf\+To\+Root} ()
\item 
\mbox{\Hypertarget{classInfomapGreedyTypeSpecialized_3_01FlowType_00_01WithMemory_01_4_a9cc197eb97a00d1dd39ce72bb7432749}\label{classInfomapGreedyTypeSpecialized_3_01FlowType_00_01WithMemory_01_4_a9cc197eb97a00d1dd39ce72bb7432749}} 
virtual double {\bfseries calc\+Codelength\+On\+Root\+Of\+Leaf\+Nodes} (const \mbox{\hyperlink{classNodeBase}{Node\+Base}} \&parent)
\item 
\mbox{\Hypertarget{classInfomapGreedyTypeSpecialized_3_01FlowType_00_01WithMemory_01_4_aa4bebdd9c7932541bfa0b49466786c55}\label{classInfomapGreedyTypeSpecialized_3_01FlowType_00_01WithMemory_01_4_aa4bebdd9c7932541bfa0b49466786c55}} 
virtual double {\bfseries calc\+Codelength\+On\+Module\+Of\+Modules} (const \mbox{\hyperlink{classNodeBase}{Node\+Base}} \&parent)
\item 
\mbox{\Hypertarget{classInfomapGreedyTypeSpecialized_3_01FlowType_00_01WithMemory_01_4_aaf98cc0c3514fb23645747627ca8da83}\label{classInfomapGreedyTypeSpecialized_3_01FlowType_00_01WithMemory_01_4_aaf98cc0c3514fb23645747627ca8da83}} 
virtual double {\bfseries calc\+Codelength\+On\+Module\+Of\+Leaf\+Nodes} (const \mbox{\hyperlink{classNodeBase}{Node\+Base}} \&parent)
\item 
virtual void \mbox{\hyperlink{classInfomapGreedyTypeSpecialized_3_01FlowType_00_01WithMemory_01_4_a3b8cb78e45b8879069d662c3791a702e}{init\+Module\+Optimization}} ()
\item 
\mbox{\Hypertarget{classInfomapGreedyTypeSpecialized_3_01FlowType_00_01WithMemory_01_4_a347b6825186d798587fdd77a35277a83}\label{classInfomapGreedyTypeSpecialized_3_01FlowType_00_01WithMemory_01_4_a347b6825186d798587fdd77a35277a83}} 
void {\bfseries calculate\+Node\+Flow\+\_\+log\+\_\+node\+Flow\+For\+Memory\+Network} ()
\item 
void \mbox{\hyperlink{classInfomapGreedyTypeSpecialized_3_01FlowType_00_01WithMemory_01_4_acde6bc33c277e883e2803d8859dce5f9}{add\+Contribution\+Of\+Moving\+Memory\+Nodes}} (\mbox{\hyperlink{classMemNode}{Node\+Type}} \&current, \mbox{\hyperlink{structMemDeltaFlow}{Delta\+Flow\+Type}} \&old\+Module\+Delta, std\+::vector$<$ \mbox{\hyperlink{structMemDeltaFlow}{Delta\+Flow\+Type}} $>$ \&module\+Delta\+Enter\+Exit, std\+::vector$<$ unsigned int $>$ \&redirect, unsigned int \&offset, unsigned int \&num\+Module\+Links)
\item 
void \mbox{\hyperlink{classInfomapGreedyTypeSpecialized_3_01FlowType_00_01WithMemory_01_4_afce65e489f9881a44582fd56bd76b675}{add\+Contribution\+Of\+Moving\+Memory\+Nodes}} (\mbox{\hyperlink{classMemNode}{Node\+Type}} \&current, \mbox{\hyperlink{structMemDeltaFlow}{Delta\+Flow\+Type}} \&old\+Module\+Delta, std\+::map$<$ unsigned int, \mbox{\hyperlink{structMemDeltaFlow}{Delta\+Flow\+Type}} $>$ \&module\+Delta\+Flow)
\item 
\mbox{\Hypertarget{classInfomapGreedyTypeSpecialized_3_01FlowType_00_01WithMemory_01_4_a766c0e73cd02f1612ebcd13d8ae1a598}\label{classInfomapGreedyTypeSpecialized_3_01FlowType_00_01WithMemory_01_4_a766c0e73cd02f1612ebcd13d8ae1a598}} 
void {\bfseries perform\+Move\+Of\+Memory\+Node} (\mbox{\hyperlink{classMemNode}{Node\+Type}} \&current, unsigned int old\+Module\+Index, unsigned int best\+Module\+Index)
\item 
\mbox{\Hypertarget{classInfomapGreedyTypeSpecialized_3_01FlowType_00_01WithMemory_01_4_ab09f3531525acae56835f1b49dbc7827}\label{classInfomapGreedyTypeSpecialized_3_01FlowType_00_01WithMemory_01_4_ab09f3531525acae56835f1b49dbc7827}} 
void {\bfseries perform\+Predefined\+Move\+Of\+Memory\+Node} (\mbox{\hyperlink{classMemNode}{Node\+Type}} \&current, unsigned int old\+Module\+Index, unsigned int best\+Module\+Index, \mbox{\hyperlink{structMemDeltaFlow}{Delta\+Flow\+Type}} \&old\+Module\+Delta, \mbox{\hyperlink{structMemDeltaFlow}{Delta\+Flow\+Type}} \&new\+Module\+Delta)
\item 
\mbox{\Hypertarget{classInfomapGreedyTypeSpecialized_3_01FlowType_00_01WithMemory_01_4_afee5e78a78127cdfd32d77c0ce8b5f16}\label{classInfomapGreedyTypeSpecialized_3_01FlowType_00_01WithMemory_01_4_afee5e78a78127cdfd32d77c0ce8b5f16}} 
double {\bfseries get\+Delta\+Codelength\+On\+Moving\+Memory\+Node} (\mbox{\hyperlink{structMemDeltaFlow}{Delta\+Flow\+Type}} \&old\+Module\+Delta, \mbox{\hyperlink{structMemDeltaFlow}{Delta\+Flow\+Type}} \&new\+Module\+Delta)
\item 
\mbox{\Hypertarget{classInfomapGreedyTypeSpecialized_3_01FlowType_00_01WithMemory_01_4_a15f1cd1b1ea3729648dd8ed3a6c95a5c}\label{classInfomapGreedyTypeSpecialized_3_01FlowType_00_01WithMemory_01_4_a15f1cd1b1ea3729648dd8ed3a6c95a5c}} 
void {\bfseries update\+Codelength\+On\+Moving\+Memory\+Node} (\mbox{\hyperlink{structMemDeltaFlow}{Delta\+Flow\+Type}} \&old\+Module\+Delta, \mbox{\hyperlink{structMemDeltaFlow}{Delta\+Flow\+Type}} \&new\+Module\+Delta)
\item 
\mbox{\Hypertarget{classInfomapGreedyTypeSpecialized_3_01FlowType_00_01WithMemory_01_4_a4bd2cf9ebfa39ce1fef6b214460025f0}\label{classInfomapGreedyTypeSpecialized_3_01FlowType_00_01WithMemory_01_4_a4bd2cf9ebfa39ce1fef6b214460025f0}} 
void {\bfseries consolidate\+Physical\+Nodes} (std\+::vector$<$ \mbox{\hyperlink{classNodeBase}{Node\+Base}} $\ast$$>$ \&modules)
\item 
\mbox{\Hypertarget{classInfomapGreedyTypeSpecialized_3_01FlowType_00_01WithMemory_01_4_a1e2705ccb3ae8c5cf6be88b8e979375e}\label{classInfomapGreedyTypeSpecialized_3_01FlowType_00_01WithMemory_01_4_a1e2705ccb3ae8c5cf6be88b8e979375e}} 
void {\bfseries generate\+Network\+From\+Children} (\mbox{\hyperlink{classNodeBase}{Node\+Base}} \&parent)
\item 
\mbox{\Hypertarget{classInfomapGreedyTypeSpecialized_3_01FlowType_00_01WithMemory_01_4_a3cb50733f59c3763c1fa7faa72967c14}\label{classInfomapGreedyTypeSpecialized_3_01FlowType_00_01WithMemory_01_4_a3cb50733f59c3763c1fa7faa72967c14}} 
virtual void {\bfseries save\+Hierarchical\+Network} (\mbox{\hyperlink{classHierarchicalNetwork}{Hierarchical\+Network}} \&output, std\+::string root\+Name, bool include\+Links)
\item 
\mbox{\Hypertarget{classInfomapGreedyTypeSpecialized_3_01FlowType_00_01WithMemory_01_4_a6f74df9a3966389285347b5c4b08efe9}\label{classInfomapGreedyTypeSpecialized_3_01FlowType_00_01WithMemory_01_4_a6f74df9a3966389285347b5c4b08efe9}} 
virtual void {\bfseries print\+Cluster\+Numbers} (std\+::ostream \&out)
\item 
\mbox{\Hypertarget{classInfomapGreedyTypeSpecialized_3_01FlowType_00_01WithMemory_01_4_aa04d7c5d5d851b81c3006a20a3db14e0}\label{classInfomapGreedyTypeSpecialized_3_01FlowType_00_01WithMemory_01_4_aa04d7c5d5d851b81c3006a20a3db14e0}} 
virtual void {\bfseries print\+Flow\+Network} (std\+::ostream \&out)
\item 
\mbox{\Hypertarget{classInfomapGreedyTypeSpecialized_3_01FlowType_00_01WithMemory_01_4_a3e3fbee8f0df0a6866f7af8f8959c83a}\label{classInfomapGreedyTypeSpecialized_3_01FlowType_00_01WithMemory_01_4_a3e3fbee8f0df0a6866f7af8f8959c83a}} 
virtual std\+::vector$<$ \mbox{\hyperlink{structPhysData}{Phys\+Data}} $>$ \& {\bfseries get\+Physical\+Members} (\mbox{\hyperlink{classNodeBase}{Node\+Base}} \&\mbox{\hyperlink{structnode}{node}})
\item 
\mbox{\Hypertarget{classInfomapGreedyTypeSpecialized_3_01FlowType_00_01WithMemory_01_4_a2c2381a2c5284a39252751ca388fadcb}\label{classInfomapGreedyTypeSpecialized_3_01FlowType_00_01WithMemory_01_4_a2c2381a2c5284a39252751ca388fadcb}} 
virtual \mbox{\hyperlink{structStateNode}{State\+Node}} \& {\bfseries get\+Memory\+Node} (\mbox{\hyperlink{classNodeBase}{Node\+Base}} \&\mbox{\hyperlink{structnode}{node}})
\end{DoxyCompactItemize}
\subsection*{Friends}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{classInfomapGreedyTypeSpecialized_3_01FlowType_00_01WithMemory_01_4_aa70a5b9ff2b70d2893f555e1a9313a3e}\label{classInfomapGreedyTypeSpecialized_3_01FlowType_00_01WithMemory_01_4_aa70a5b9ff2b70d2893f555e1a9313a3e}} 
class {\bfseries Infomap\+Greedy\+Common$<$ Infomap\+Greedy\+Type\+Specialized$<$ Flow\+Type, With\+Memory $>$ $>$}
\end{DoxyCompactItemize}
\subsection*{Additional Inherited Members}


\subsection{Member Function Documentation}
\mbox{\Hypertarget{classInfomapGreedyTypeSpecialized_3_01FlowType_00_01WithMemory_01_4_acde6bc33c277e883e2803d8859dce5f9}\label{classInfomapGreedyTypeSpecialized_3_01FlowType_00_01WithMemory_01_4_acde6bc33c277e883e2803d8859dce5f9}} 
\index{Infomap\+Greedy\+Type\+Specialized$<$ Flow\+Type, With\+Memory $>$@{Infomap\+Greedy\+Type\+Specialized$<$ Flow\+Type, With\+Memory $>$}!add\+Contribution\+Of\+Moving\+Memory\+Nodes@{add\+Contribution\+Of\+Moving\+Memory\+Nodes}}
\index{add\+Contribution\+Of\+Moving\+Memory\+Nodes@{add\+Contribution\+Of\+Moving\+Memory\+Nodes}!Infomap\+Greedy\+Type\+Specialized$<$ Flow\+Type, With\+Memory $>$@{Infomap\+Greedy\+Type\+Specialized$<$ Flow\+Type, With\+Memory $>$}}
\subsubsection{\texorpdfstring{add\+Contribution\+Of\+Moving\+Memory\+Nodes()}{addContributionOfMovingMemoryNodes()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename Flow\+Type $>$ \\
void \mbox{\hyperlink{classInfomapGreedyTypeSpecialized}{Infomap\+Greedy\+Type\+Specialized}}$<$ Flow\+Type, \mbox{\hyperlink{structWithMemory}{With\+Memory}} $>$\+::add\+Contribution\+Of\+Moving\+Memory\+Nodes (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classMemNode}{Node\+Type}} \&}]{current,  }\item[{\mbox{\hyperlink{structMemDeltaFlow}{Delta\+Flow\+Type}} \&}]{old\+Module\+Delta,  }\item[{std\+::vector$<$ \mbox{\hyperlink{structMemDeltaFlow}{Delta\+Flow\+Type}} $>$ \&}]{module\+Delta\+Enter\+Exit,  }\item[{std\+::vector$<$ unsigned int $>$ \&}]{redirect,  }\item[{unsigned int \&}]{offset,  }\item[{unsigned int \&}]{num\+Module\+Links }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [protected]}}

delta = old.\+first + new.\+first + old.\+second -\/ new.\+second. Two cases\+: (p(x) = plogp(x)) Moving to a module that already have that physical node\+: (old\+: p1, p2, new p3, moving p2 -\/$>$ old\+:p1, new p2,p3) Then old.\+second = new.\+second = plogp(physical\+Node\+Size) -\/$>$ cancelation -\/$>$ delta = p(p1) -\/ p(p1+p2) + p(p2+p3) -\/ p(p3) Moving to a module that not have that physical node\+: (old\+: p1, p2, new -\/, moving p2 -\/$>$ old\+: p1, new\+: p2) Then new.\+first = new.\+second = 0 -\/$>$ delta = p(p1) -\/ p(p1+p2) + p(p2).
\begin{DoxyCode}
535 \{
536     \textcolor{comment}{// Overlapping modules}
545 \textcolor{comment}{}    \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} numPhysicalNodes = current.physicalNodes.size();
546     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} i = 0; i < numPhysicalNodes; ++i)
547     \{
548         \mbox{\hyperlink{structPhysData}{PhysData}}& physData = current.physicalNodes[i];
549         ModuleToMemNodes& moduleToMemNodes = m\_physToModuleToMemNodes[physData.physNodeIndex];
550         \textcolor{keywordflow}{for} (ModuleToMemNodes::iterator overlapIt(moduleToMemNodes.begin()); overlapIt != moduleToMemNodes.
      end(); ++overlapIt)
551         \{
552             \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} moduleIndex = overlapIt->first;
553             \mbox{\hyperlink{structMemNodeSet}{MemNodeSet}}& memNodeSet = overlapIt->second;
554             \textcolor{keywordflow}{if} (moduleIndex == current.index) \textcolor{comment}{// From where the multiple assigned node is moved}
555             \{
556                 \textcolor{keywordtype}{double} oldPhysFlow = memNodeSet.sumFlow;
557                 \textcolor{keywordtype}{double} newPhysFlow = memNodeSet.sumFlow - physData.sumFlowFromStateNode;
558                 oldModuleDelta.sumDeltaPlogpPhysFlow += infomath::plogp(newPhysFlow) - infomath::plogp(
      oldPhysFlow);
559                 oldModuleDelta.sumPlogpPhysFlow += infomath::plogp(physData.sumFlowFromStateNode);
560             \}
561             \textcolor{keywordflow}{else} \textcolor{comment}{// To where the multiple assigned node is moved}
562             \{
563                 \textcolor{keywordtype}{double} oldPhysFlow = memNodeSet.sumFlow;
564                 \textcolor{keywordtype}{double} newPhysFlow = memNodeSet.sumFlow + physData.sumFlowFromStateNode;
565 
566                 \textcolor{keywordflow}{if} (redirect[moduleIndex] >= offset)
567                 \{
568                     moduleDeltaEnterExit[redirect[moduleIndex] - offset].sumDeltaPlogpPhysFlow += 
      infomath::plogp(newPhysFlow) - infomath::plogp(oldPhysFlow);
569                     moduleDeltaEnterExit[redirect[moduleIndex] - offset].sumPlogpPhysFlow += 
      infomath::plogp(physData.sumFlowFromStateNode);
570                 \}
571                 \textcolor{keywordflow}{else}
572                 \{
573                     redirect[moduleIndex] = offset + numModuleLinks;
574                     moduleDeltaEnterExit[numModuleLinks].module = moduleIndex;
575                     moduleDeltaEnterExit[numModuleLinks].deltaExit = 0.0;
576                     moduleDeltaEnterExit[numModuleLinks].deltaEnter = 0.0;
577                     moduleDeltaEnterExit[numModuleLinks].sumDeltaPlogpPhysFlow = infomath::plogp(
      newPhysFlow) - infomath::plogp(oldPhysFlow);
578                     moduleDeltaEnterExit[numModuleLinks].sumPlogpPhysFlow = infomath::plogp(physData.
      sumFlowFromStateNode);
579                     ++numModuleLinks;
580                 \}
581             \}
582         \}
583     \}
584 \}
\end{DoxyCode}
\mbox{\Hypertarget{classInfomapGreedyTypeSpecialized_3_01FlowType_00_01WithMemory_01_4_afce65e489f9881a44582fd56bd76b675}\label{classInfomapGreedyTypeSpecialized_3_01FlowType_00_01WithMemory_01_4_afce65e489f9881a44582fd56bd76b675}} 
\index{Infomap\+Greedy\+Type\+Specialized$<$ Flow\+Type, With\+Memory $>$@{Infomap\+Greedy\+Type\+Specialized$<$ Flow\+Type, With\+Memory $>$}!add\+Contribution\+Of\+Moving\+Memory\+Nodes@{add\+Contribution\+Of\+Moving\+Memory\+Nodes}}
\index{add\+Contribution\+Of\+Moving\+Memory\+Nodes@{add\+Contribution\+Of\+Moving\+Memory\+Nodes}!Infomap\+Greedy\+Type\+Specialized$<$ Flow\+Type, With\+Memory $>$@{Infomap\+Greedy\+Type\+Specialized$<$ Flow\+Type, With\+Memory $>$}}
\subsubsection{\texorpdfstring{add\+Contribution\+Of\+Moving\+Memory\+Nodes()}{addContributionOfMovingMemoryNodes()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename Flow\+Type $>$ \\
void \mbox{\hyperlink{classInfomapGreedyTypeSpecialized}{Infomap\+Greedy\+Type\+Specialized}}$<$ Flow\+Type, \mbox{\hyperlink{structWithMemory}{With\+Memory}} $>$\+::add\+Contribution\+Of\+Moving\+Memory\+Nodes (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classMemNode}{Node\+Type}} \&}]{current,  }\item[{\mbox{\hyperlink{structMemDeltaFlow}{Delta\+Flow\+Type}} \&}]{old\+Module\+Delta,  }\item[{std\+::map$<$ unsigned int, \mbox{\hyperlink{structMemDeltaFlow}{Delta\+Flow\+Type}} $>$ \&}]{module\+Delta\+Flow }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [protected]}}

delta = old.\+first + new.\+first + old.\+second -\/ new.\+second. Two cases\+: (p(x) = plogp(x)) Moving to a module that already have that physical node\+: (old\+: p1, p2, new p3, moving p2 -\/$>$ old\+:p1, new p2,p3) Then old.\+second = new.\+second = plogp(physical\+Node\+Size) -\/$>$ cancelation -\/$>$ delta = p(p1) -\/ p(p1+p2) + p(p2+p3) -\/ p(p3) Moving to a module that not have that physical node\+: (old\+: p1, p2, new -\/, moving p2 -\/$>$ old\+: p1, new\+: p2) Then new.\+first = new.\+second = 0 -\/$>$ delta = p(p1) -\/ p(p1+p2) + p(p2).
\begin{DoxyCode}
590 \{
591     \textcolor{comment}{// Overlapping modules}
600 \textcolor{comment}{}    \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} numPhysicalNodes = current.physicalNodes.size();
601     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} i = 0; i < numPhysicalNodes; ++i)
602     \{
603         \mbox{\hyperlink{structPhysData}{PhysData}}& physData = current.physicalNodes[i];
604         ModuleToMemNodes& moduleToMemNodes = m\_physToModuleToMemNodes[physData.physNodeIndex];
605         \textcolor{keywordflow}{for} (ModuleToMemNodes::iterator overlapIt(moduleToMemNodes.begin()); overlapIt != moduleToMemNodes.
      end(); ++overlapIt)
606         \{
607             \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} moduleIndex = overlapIt->first;
608             \mbox{\hyperlink{structMemNodeSet}{MemNodeSet}}& memNodeSet = overlapIt->second;
609             \textcolor{keywordflow}{if} (moduleIndex == current.index) \textcolor{comment}{// From where the multiple assigned node is moved}
610             \{
611                 \textcolor{keywordtype}{double} oldPhysFlow = memNodeSet.sumFlow;
612                 \textcolor{keywordtype}{double} newPhysFlow = memNodeSet.sumFlow - physData.sumFlowFromStateNode;
613                 oldModuleDelta.sumDeltaPlogpPhysFlow += infomath::plogp(newPhysFlow) - infomath::plogp(
      oldPhysFlow);
614                 oldModuleDelta.sumPlogpPhysFlow += infomath::plogp(physData.sumFlowFromStateNode);
615             \}
616             \textcolor{keywordflow}{else} \textcolor{comment}{// To where the multiple assigned node is moved}
617             \{
618                 \textcolor{keywordtype}{double} oldPhysFlow = memNodeSet.sumFlow;
619                 \textcolor{keywordtype}{double} newPhysFlow = memNodeSet.sumFlow + physData.sumFlowFromStateNode;
620 
621                 \textcolor{comment}{// moduleDeltaFlow[moduleIndex].addMemFlowTerms(infomath::plogp(newPhysFlow) -
       infomath::plogp(oldPhysFlow), infomath::plogp(physData.sumFlowFromStateNode));}
622                 DeltaFlowType& physNeighbourDeltaFlow = moduleDeltaFlow[moduleIndex];
623                 physNeighbourDeltaFlow.module = moduleIndex; \textcolor{comment}{// Make sure module is correct if created new}
624                 physNeighbourDeltaFlow.sumDeltaPlogpPhysFlow = infomath::plogp(newPhysFlow) - 
      infomath::plogp(oldPhysFlow);
625                 physNeighbourDeltaFlow.sumPlogpPhysFlow = infomath::plogp(physData.sumFlowFromStateNode);
626             \}
627         \}
628     \}
629 \}
\end{DoxyCode}
\mbox{\Hypertarget{classInfomapGreedyTypeSpecialized_3_01FlowType_00_01WithMemory_01_4_a3b8cb78e45b8879069d662c3791a702e}\label{classInfomapGreedyTypeSpecialized_3_01FlowType_00_01WithMemory_01_4_a3b8cb78e45b8879069d662c3791a702e}} 
\index{Infomap\+Greedy\+Type\+Specialized$<$ Flow\+Type, With\+Memory $>$@{Infomap\+Greedy\+Type\+Specialized$<$ Flow\+Type, With\+Memory $>$}!init\+Module\+Optimization@{init\+Module\+Optimization}}
\index{init\+Module\+Optimization@{init\+Module\+Optimization}!Infomap\+Greedy\+Type\+Specialized$<$ Flow\+Type, With\+Memory $>$@{Infomap\+Greedy\+Type\+Specialized$<$ Flow\+Type, With\+Memory $>$}}
\subsubsection{\texorpdfstring{init\+Module\+Optimization()}{initModuleOptimization()}}
{\footnotesize\ttfamily template$<$typename Flow\+Type $>$ \\
void \mbox{\hyperlink{classInfomapGreedyTypeSpecialized}{Infomap\+Greedy\+Type\+Specialized}}$<$ Flow\+Type, \mbox{\hyperlink{structWithMemory}{With\+Memory}} $>$\+::init\+Module\+Optimization (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}, {\ttfamily [virtual]}}

Allocate a module for each node, with flow data from the node. 

Implements \mbox{\hyperlink{classInfomapBase_a8347fea5ed1cd22a27c7d972496e7d90}{Infomap\+Base}}.


\begin{DoxyCode}
464 \{
465     DEBUG\_OUT(\textcolor{stringliteral}{"\(\backslash\)n::initModuleOptimization()"} << std::flush);
466     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} numNodes = Super::m\_activeNetwork.size();
467     Super::m\_moduleFlowData.resize(numNodes);
468     Super::m\_moduleMembers.assign(numNodes, 1);
469     Super::m\_emptyModules.clear();
470     Super::m\_emptyModules.reserve(numNodes);
471 
472     \textcolor{keywordflow}{if} (m\_numPhysicalNodes == 0) \{
473         \textcolor{comment}{// Get max physical index (may be more than numNodes if non-contiguous indexing)}
474         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} maxPhysIndex = 0;
475         \textcolor{keywordflow}{for} (\textcolor{keyword}{typename} Super::activeNetwork\_iterator it(Super::m\_activeNetwork.
      \mbox{\hyperlink{namespacebegin}{begin}}()), itEnd(Super::m\_activeNetwork.end());
476                 it != itEnd; ++it)
477         \{
478             NodeType& \mbox{\hyperlink{structnode}{node}} = getNode(**it);
479             \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} numPhysicalMembers = \mbox{\hyperlink{structnode}{node}}.physicalNodes.size();
480             \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} j = 0; j < numPhysicalMembers; ++j)
481             \{
482                 \mbox{\hyperlink{structPhysData}{PhysData}}& physData = \mbox{\hyperlink{structnode}{node}}.physicalNodes[j];
483                 maxPhysIndex = std::max(maxPhysIndex, physData.physNodeIndex);
484             \}
485         \}
486         m\_numPhysicalNodes = maxPhysIndex + 1;
487     \}
488     m\_physToModuleToMemNodes.clear();
489     m\_physToModuleToMemNodes.resize(m\_numPhysicalNodes);
490 
491     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} i = 0;
492     \textcolor{keywordflow}{for} (\textcolor{keyword}{typename} Super::activeNetwork\_iterator it(Super::m\_activeNetwork.\mbox{\hyperlink{namespacebegin}{begin}}()), itEnd(
      Super::m\_activeNetwork.end());
493             it != itEnd; ++it, ++i)
494     \{
495         NodeType& \mbox{\hyperlink{structnode}{node}} = getNode(**it);
496         \mbox{\hyperlink{structnode}{node}}.index = i; \textcolor{comment}{// Unique module index for each node}
497         Super::m\_moduleFlowData[i] = \mbox{\hyperlink{structnode}{node}}.data;
498         \mbox{\hyperlink{structnode}{node}}.dirty = \textcolor{keyword}{true};
499 
500         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} numPhysicalMembers = \mbox{\hyperlink{structnode}{node}}.physicalNodes.size();
501         \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} j = 0; j < numPhysicalMembers; ++j)
502         \{
503             \mbox{\hyperlink{structPhysData}{PhysData}}& physData = \mbox{\hyperlink{structnode}{node}}.physicalNodes[j];
504             m\_physToModuleToMemNodes[physData.physNodeIndex].insert(m\_physToModuleToMemNodes[physData.
      physNodeIndex].end(),
505                     std::make\_pair(i, \mbox{\hyperlink{structMemNodeSet}{MemNodeSet}}(1, physData.sumFlowFromStateNode)));
506         \}
507     \}
508 
509 
510     \textcolor{comment}{// Initiate codelength terms for the initial state of one module per node}
511     \mbox{\hyperlink{classInfomapGreedyCommon_ae168ab41c18759e09b1a3dff97ee017d}{Super::calculateCodelengthFromActiveNetwork}}();
512 \}
\end{DoxyCode}


The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
dsmacc/graph/infomap/src/infomap/Infomap\+Greedy\+Type\+Specialized.\+h\end{DoxyCompactItemize}
