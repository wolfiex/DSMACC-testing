`require(\textquotesingle{}modules')\`{} in the browser

Use a \href{http://nodejs.org}{\tt node}-\/style {\ttfamily require()} to organize your browser code and load modules installed by \href{https://www.npmjs.com}{\tt npm}.

browserify will recursively analyze all the {\ttfamily require()} calls in your app in order to build a bundle you can serve up to the browser in a single {\ttfamily $<$script$>$} tag.

\href{https://travis-ci.org/browserify/browserify}{\tt }



\section*{getting started}

If you\textquotesingle{}re new to browserify, check out the \href{https://github.com/browserify/browserify-handbook}{\tt browserify handbook} and the resources on \href{http://browserify.org/}{\tt browserify.\+org}.

\section*{example}

Whip up a file, {\ttfamily main.\+js} with some {\ttfamily require()}s in it. You can use relative paths like `'./foo.js\textquotesingle{}{\ttfamily and}\textquotesingle{}../lib/bar.js\textquotesingle{}{\ttfamily or module paths like}\textquotesingle{}gamma\textquotesingle{}{\ttfamily  that will search}node\+\_\+modules/\`{} using \href{https://github.com/browserify/resolve}{\tt node\textquotesingle{}s module lookup algorithm}.


\begin{DoxyCode}
var foo = require('./foo.js');
var bar = require('../lib/bar.js');
var gamma = require('gamma');

var elem = document.getElementById('result');
var x = foo(100) + bar('baz');
elem.textContent = gamma(x);
\end{DoxyCode}


Export functionality by assigning onto {\ttfamily module.\+exports} or {\ttfamily exports}\+:


\begin{DoxyCode}
module.exports = function (n) \{ return n * 111 \}
\end{DoxyCode}


Now just use the {\ttfamily browserify} command to build a bundle starting at {\ttfamily main.\+js}\+:


\begin{DoxyCode}
$ browserify main.js > bundle.js
\end{DoxyCode}


All of the modules that {\ttfamily main.\+js} needs are included in the {\ttfamily bundle.\+js} from a recursive walk of the {\ttfamily require()} graph using \href{https://github.com/defunctzombie/node-required}{\tt required}.

To use this bundle, just toss a {\ttfamily $<$script src=\char`\"{}bundle.\+js\char`\"{}$>$$<$/script$>$} into your html!

\section*{install}

With \href{https://www.npmjs.com/}{\tt npm} do\+:


\begin{DoxyCode}
npm install -g browserify
\end{DoxyCode}


\section*{usage}


\begin{DoxyCode}
Usage: browserify [entry files] \{OPTIONS\}

Standard Options:

    --outfile, -o  Write the browserify bundle to this file.
                   If unspecified, browserify prints to stdout.

    --require, -r  A module name or file to bundle.require()
                   Optionally use a colon separator to set the target.

      --entry, -e  An entry point of your app

     --ignore, -i  Replace a file with an empty stub. Files can be globs.

    --exclude, -u  Omit a file from the output bundle. Files can be globs.

   --external, -x  Reference a file from another bundle. Files can be globs.

  --transform, -t  Use a transform module on top-level files.

    --command, -c  Use a transform command on top-level files.

  --standalone -s  Generate a UMD bundle for the supplied export name.
                   This bundle works with other module systems and sets the name
                   given as a window global if no module system is found.

       --debug -d  Enable source maps that allow you to debug your files
                   separately.

       --help, -h  Show this message

For advanced options, type `browserify --help advanced`.

Specify a parameter.
\end{DoxyCode}


\`{}\`{}\`{} Advanced Options\+:

--insert-\/globals, --ig, --fast \mbox{[}default\+: false\mbox{]}

Skip detection and always insert definitions for process, global, \+\_\+\+\_\+filename, and \+\_\+\+\_\+dirname.

benefit\+: faster builds cost\+: extra bytes

--insert-\/global-\/vars, --igv

Comma-\/separated list of global variables to detect and define. Default\+: \+\_\+\+\_\+filename,\+\_\+\+\_\+dirname,process,Buffer,global

--detect-\/globals, --dg \mbox{[}default\+: true\mbox{]}

Detect the presence of process, global, \+\_\+\+\_\+filename, and \+\_\+\+\_\+dirname and define these values when present.

benefit\+: npm modules more likely to work cost\+: slower builds

--ignore-\/missing, --im \mbox{[}default\+: false\mbox{]}

Ignore {\ttfamily require()} statements that don\textquotesingle{}t resolve to anything.

--noparse=F\+I\+LE

Don\textquotesingle{}t parse F\+I\+LE at all. This will make bundling much, much faster for giant libs like jquery or threejs.

--no-\/builtins

Turn off builtins. This is handy when you want to run a bundle in node which provides the core builtins.

--no-\/commondir

Turn off setting a commondir. This is useful if you want to preserve the original paths that a bundle was generated with.

--no-\/bundle-\/external

Turn off bundling of all external modules. This is useful if you only want to bundle your local files.

--bare

Alias for both --no-\/builtins, --no-\/commondir, and sets --insert-\/global-\/vars to just \char`\"{}\+\_\+\+\_\+filename,\+\_\+\+\_\+dirname\char`\"{}. This is handy if you want to run bundles in node.

--no-\/browser-\/field, --no-\/bf

Turn off package.\+json browser field resolution. This is also handy if you need to run a bundle in node.

--transform-\/key

Instead of the default package.\+json\+::browserify\+::transform field to list all transforms to apply when running browserify, a custom field, like, e.\+g. package.\+json\+::browserify\+::production or package.\+json\+::browserify\+::staging can be used, by for example running\+:
\begin{DoxyItemize}
\item {\ttfamily browserify index.\+js -\/-\/transform-\/key=production $>$ bundle.\+js}
\item {\ttfamily browserify index.\+js -\/-\/transform-\/key=staging $>$ bundle.\+js}
\end{DoxyItemize}

--node

Alias for --bare and --no-\/browser-\/field.

--full-\/paths

Turn off converting module ids into numerical indexes. This is useful for preserving the original paths that a bundle was generated with.

--deps

Instead of standard bundle output, print the dependency array generated by module-\/deps.

--no-\/dedupe

Turn off deduping.

--list

Print each file in the dependency graph. Useful for makefiles.

--extension=E\+X\+T\+E\+N\+S\+I\+ON

Consider files with specified E\+X\+T\+E\+N\+S\+I\+ON as modules, this option can used multiple times.

--global-\/transform=M\+O\+D\+U\+LE, -\/g M\+O\+D\+U\+LE

Use a transform module on all files after any ordinary transforms have run.

--ignore-\/transform=M\+O\+D\+U\+LE, -\/it M\+O\+D\+U\+LE

Do not run certain transformations, even if specified elsewhere.

--plugin=M\+O\+D\+U\+LE, -\/p M\+O\+D\+U\+LE

Register M\+O\+D\+U\+LE as a plugin.

Passing arguments to transforms and plugins\+:

For -\/t, -\/g, and -\/p, you may use subarg syntax to pass options to the transforms or plugin function as the second parameter. For example\+:

-\/t \mbox{[} foo -\/x 3 --beep \mbox{]}

will call the {\ttfamily foo} transform for each applicable file by calling\+:

foo(file, \{ x\+: 3, beep\+: true \})


\begin{DoxyCode}
# compatibility

Many [npm](https://www.npmjs.com/) modules that don't do IO will just work after being
browserified. Others take more work.

Many node built-in modules have been wrapped to work in the browser, but only
when you explicitly `require()` or use their functionality.

When you `require()` any of these modules, you will get a browser-specific shim:

* [assert](https://www.npmjs.com/package/assert)
* [buffer](https://www.npmjs.com/package/buffer)
* [console](https://www.npmjs.com/package/console-browserify)
* [constants](https://www.npmjs.com/package/constants-browserify)
* [crypto](https://www.npmjs.com/package/crypto-browserify)
* [domain](https://www.npmjs.com/package/domain-browser)
* [events](https://www.npmjs.com/package/events)
* [http](https://www.npmjs.com/package/stream-http)
* [https](https://www.npmjs.com/package/https-browserify)
* [os](https://www.npmjs.com/package/os-browserify)
* [path](https://www.npmjs.com/package/path-browserify)
* [punycode](https://www.npmjs.com/package/punycode)
* [querystring](https://www.npmjs.com/package/querystring-es3)
* [stream](https://www.npmjs.com/package/stream-browserify)
* [string\_decoder](https://www.npmjs.com/package/string\_decoder)
* [timers](https://www.npmjs.com/package/timers-browserify)
* [tty](https://www.npmjs.com/package/tty-browserify)
* [url](https://www.npmjs.com/package/url)
* [util](https://www.npmjs.com/package/util)
* [vm](https://www.npmjs.com/package/vm-browserify)
* [zlib](https://www.npmjs.com/package/browserify-zlib)

Additionally, if you use any of these variables, they
[will be defined](https://github.com/browserify/insert-module-globals)
in the bundled output in a browser-appropriate way:

* [process](https://www.npmjs.com/package/process)
* [Buffer](https://www.npmjs.com/package/buffer)
* global - top-level scope object (window)
* \_\_filename - file path of the currently executing file
* \_\_dirname - directory path of the currently executing file

# more examples

## external requires

You can just as easily create a bundle that will export a `require()` function so
you can `require()` modules from another script tag. Here we'll create a
`bundle.js` with the [through](https://www.npmjs.com/package/through)
and [duplexer](https://www.npmjs.com/package/duplexer) modules.
\end{DoxyCode}
 \$ browserify -\/r through -\/r duplexer -\/r ./my-\/file.js\+:my-\/module $>$ bundle.\+js 
\begin{DoxyCode}
Then in your page you can do:

``` html
<script src="bundle.js"></script>
<script>
  var through = require('through');
  var duplexer = require('duplexer');
  var myModule = require('my-module');
  /* ... */
</script>
\end{DoxyCode}


\subsection*{external source maps}

If you prefer the source maps be saved to a separate {\ttfamily .js.\+map} source map file, you may use \href{https://github.com/thlorenz/exorcist}{\tt exorcist} in order to achieve that. It\textquotesingle{}s as simple as\+:


\begin{DoxyCode}
$ browserify main.js --debug | exorcist bundle.js.map > bundle.js
\end{DoxyCode}


Learn about additional options \href{https://github.com/thlorenz/exorcist#usage}{\tt here}.

\subsection*{multiple bundles}

If browserify finds a {\ttfamily require}d function already defined in the page scope, it will fall back to that function if it didn\textquotesingle{}t find any matches in its own set of bundled modules.

In this way, you can use browserify to split up bundles among multiple pages to get the benefit of caching for shared, infrequently-\/changing modules, while still being able to use {\ttfamily require()}. Just use a combination of {\ttfamily -\/-\/external} and {\ttfamily -\/-\/require} to factor out common dependencies.

For example, if a website with 2 pages, {\ttfamily beep.\+js}\+:


\begin{DoxyCode}
var robot = require('./robot.js');
console.log(robot('beep'));
\end{DoxyCode}


and {\ttfamily boop.\+js}\+:


\begin{DoxyCode}
var robot = require('./robot.js');
console.log(robot('boop'));
\end{DoxyCode}


both depend on {\ttfamily robot.\+js}\+:


\begin{DoxyCode}
module.exports = function (s) \{ return s.toUpperCase() + '!' \};
\end{DoxyCode}



\begin{DoxyCode}
$ browserify -r ./robot.js > static/common.js
$ browserify -x ./robot.js beep.js > static/beep.js
$ browserify -x ./robot.js boop.js > static/boop.js
\end{DoxyCode}


Then on the beep page you can have\+:


\begin{DoxyCode}
<script src="common.js"></script>
<script src="beep.js"></script>
\end{DoxyCode}


while the boop page can have\+:


\begin{DoxyCode}
<script src="common.js"></script>
<script src="boop.js"></script>
\end{DoxyCode}


This approach using {\ttfamily -\/r} and {\ttfamily -\/x} works fine for a small number of split assets, but there are plugins for automatically factoring out components which are described in the \href{https://github.com/browserify/browserify-handbook#partitioning}{\tt partitioning section of the browserify handbook}.

\subsection*{api example}

You can use the A\+PI directly too\+:


\begin{DoxyCode}
var browserify = require('browserify');
var b = browserify();
b.add('./browser/main.js');
b.bundle().pipe(process.stdout);
\end{DoxyCode}


\section*{methods}


\begin{DoxyCode}
var browserify = require('browserify')
\end{DoxyCode}


\subsection*{{\ttfamily browserify(\mbox{[}files\mbox{]} \mbox{[}, opts\mbox{]})}}

Returns a new browserify instance.


\begin{DoxyDescription}
\item[files  ]String, file object, or array of those types (they may be mixed) specifying entry file(s). 


\item[opts  ]Object.  
\end{DoxyDescription}

{\ttfamily files} and {\ttfamily opts} are both optional, but must be in the order shown if both are passed.

Entry files may be passed in {\ttfamily files} and / or {\ttfamily opts.\+entries}.

External requires may be specified in {\ttfamily opts.\+require}, accepting the same formats that the {\ttfamily files} argument does.

If an entry file is a stream, its contents will be used. You should pass {\ttfamily opts.\+basedir} when using streaming files so that relative requires can be resolved.

{\ttfamily opts.\+entries} has the same definition as {\ttfamily files}.

{\ttfamily opts.\+no\+Parse} is an array which will skip all require() and global parsing for each file in the array. Use this for giant libs like jquery or threejs that don\textquotesingle{}t have any requires or node-\/style globals but take forever to parse.

{\ttfamily opts.\+transform} is an array of transform functions or modules names which will transform the source code before the parsing.

{\ttfamily opts.\+ignore\+Transform} is an array of transformations that will not be run, even if specified elsewhere.

{\ttfamily opts.\+plugin} is an array of plugin functions or module names to use. See the plugins section below for details.

{\ttfamily opts.\+extensions} is an array of optional extra extensions for the module lookup machinery to use when the extension has not been specified. By default browserify considers only {\ttfamily .js} and {\ttfamily .json} files in such cases.

{\ttfamily opts.\+basedir} is the directory that browserify starts bundling from for filenames that start with {\ttfamily .}.

{\ttfamily opts.\+paths} is an array of directories that browserify searches when looking for modules which are not referenced using relative path. Can be absolute or relative to {\ttfamily basedir}. Equivalent of setting {\ttfamily N\+O\+D\+E\+\_\+\+P\+A\+TH} environmental variable when calling {\ttfamily browserify} command.

{\ttfamily opts.\+commondir} sets the algorithm used to parse out the common paths. Use {\ttfamily false} to turn this off, otherwise it uses the \href{https://www.npmjs.com/package/commondir}{\tt commondir} module.

{\ttfamily opts.\+full\+Paths} disables converting module ids into numerical indexes. This is useful for preserving the original paths that a bundle was generated with.

{\ttfamily opts.\+builtins} sets the list of built-\/ins to use, which by default is set in {\ttfamily lib/builtins.\+js} in this distribution.

{\ttfamily opts.\+bundle\+External} boolean option to set if external modules should be bundled. Defaults to true.

When {\ttfamily opts.\+browser\+Field} is false, the package.\+json browser field will be ignored. When {\ttfamily opts.\+browser\+Field} is set to a {\ttfamily string}, then a custom field name can be used instead of the default {\ttfamily \char`\"{}browser\char`\"{}} field.

When {\ttfamily opts.\+insert\+Globals} is true, always insert {\ttfamily process}, {\ttfamily global}, {\ttfamily \+\_\+\+\_\+filename}, and {\ttfamily \+\_\+\+\_\+dirname} without analyzing the A\+ST for faster builds but larger output bundles. Default false.

When {\ttfamily opts.\+detect\+Globals} is true, scan all files for {\ttfamily process}, {\ttfamily global}, {\ttfamily \+\_\+\+\_\+filename}, and {\ttfamily \+\_\+\+\_\+dirname}, defining as necessary. With this option npm modules are more likely to work but bundling takes longer. Default true.

When {\ttfamily opts.\+ignore\+Missing} is true, ignore {\ttfamily require()} statements that don\textquotesingle{}t resolve to anything.

When {\ttfamily opts.\+debug} is true, add a source map inline to the end of the bundle. This makes debugging easier because you can see all the original files if you are in a modern enough browser.

When {\ttfamily opts.\+standalone} is a non-\/empty string, a standalone module is created with that name and a \href{https://github.com/forbeslindesay/umd}{\tt umd} wrapper. You can use namespaces in the standalone global export using a {\ttfamily .} in the string name as a separator, for example `\textquotesingle{}A.\+B.\+C'\`{}. The global export will be \href{https://github.com/ForbesLindesay/umd#name-casing-and-characters}{\tt sanitized and camel cased}.

Note that in standalone mode the {\ttfamily require()} calls from the original source will still be around, which may trip up A\+MD loaders scanning for {\ttfamily require()} calls. You can remove these calls with \href{https://www.npmjs.com/package/derequire}{\tt derequire}\+:


\begin{DoxyCode}
$ npm install -g derequire
$ browserify main.js --standalone Foo | derequire > bundle.js
\end{DoxyCode}


{\ttfamily opts.\+insert\+Global\+Vars} will be passed to \href{https://www.npmjs.com/package/insert-module-globals}{\tt insert-\/module-\/globals} as the {\ttfamily opts.\+vars} parameter.

{\ttfamily opts.\+external\+Require\+Name} defaults to `\textquotesingle{}require'{\ttfamily in}expose\`{} mode but you can use another name.

{\ttfamily opts.\+bare} creates a bundle that does not include \mbox{\hyperlink{classNode}{Node}} builtins, and does not replace global \mbox{\hyperlink{classNode}{Node}} variables except for {\ttfamily \+\_\+\+\_\+dirname} and {\ttfamily \+\_\+\+\_\+filename}.

{\ttfamily opts.\+node} creates a bundle that runs in \mbox{\hyperlink{classNode}{Node}} and does not use the browser versions of dependencies. Same as passing {\ttfamily \{ bare\+: true, browser\+Field\+: false \}}.

Note that if files do not contain javascript source code then you also need to specify a corresponding transform for them.

All other options are forwarded along to \href{https://www.npmjs.com/package/module-deps}{\tt module-\/deps} and \href{https://www.npmjs.com/package/browser-pack}{\tt browser-\/pack} directly.

\subsection*{b.\+add(file, opts)}

Add an entry file from {\ttfamily file} that will be executed when the bundle loads.

If {\ttfamily file} is an array, each item in {\ttfamily file} will be added as an entry file.

\subsection*{b.\+require(file, opts)}

Make {\ttfamily file} available from outside the bundle with {\ttfamily require(file)}.

The {\ttfamily file} param is anything that can be resolved by {\ttfamily require.\+resolve()}, including files from {\ttfamily node\+\_\+modules}. Like with {\ttfamily require.\+resolve()}, you must prefix {\ttfamily file} with {\ttfamily ./} to require a local file (not in {\ttfamily node\+\_\+modules}).

{\ttfamily file} can also be a stream, but you should also use {\ttfamily opts.\+basedir} so that relative requires will be resolvable.

If {\ttfamily file} is an array, each item in {\ttfamily file} will be required. In {\ttfamily file} array form, you can use a string or object for each item. Object items should have a {\ttfamily file} property and the rest of the parameters will be used for the {\ttfamily opts}.

Use the {\ttfamily expose} property of opts to specify a custom dependency name. `require('./vendor/angular/angular.js\textquotesingle{}, \{expose\+: \textquotesingle{}angular\textquotesingle{}\}){\ttfamily enables}require(\textquotesingle{}angular\textquotesingle{})\`{}

\subsection*{b.\+bundle(cb)}

Bundle the files and their dependencies into a single javascript file.

Return a readable stream with the javascript file contents or optionally specify a {\ttfamily cb(err, buf)} to get the buffered results.

\subsection*{b.\+external(file)}

Prevent {\ttfamily file} from being loaded into the current bundle, instead referencing from another bundle.

If {\ttfamily file} is an array, each item in {\ttfamily file} will be externalized.

If {\ttfamily file} is another bundle, that bundle\textquotesingle{}s contents will be read and excluded from the current bundle as the bundle in {\ttfamily file} gets bundled.

\subsection*{b.\+ignore(file)}

Prevent the module name or file at {\ttfamily file} from showing up in the output bundle.

If {\ttfamily file} is an array, each item in {\ttfamily file} will be ignored.

Instead you will get a file with {\ttfamily module.\+exports = \{\}}.

\subsection*{b.\+exclude(file)}

Prevent the module name or file at {\ttfamily file} from showing up in the output bundle.

If {\ttfamily file} is an array, each item in {\ttfamily file} will be excluded.

If your code tries to {\ttfamily require()} that file it will throw unless you\textquotesingle{}ve provided another mechanism for loading it.

\subsection*{b.\+transform(tr, opts=\{\})}

Transform source code before parsing it for {\ttfamily require()} calls with the transform function or module name {\ttfamily tr}.

If {\ttfamily tr} is a function, it will be called with {\ttfamily tr(file)} and it should return a \href{https://github.com/substack/stream-handbook#through}{\tt through-\/stream} that takes the raw file contents and produces the transformed source.

If {\ttfamily tr} is a string, it should be a module name or file path of a \href{https://github.com/browserify/module-deps#transforms}{\tt transform module} with a signature of\+:


\begin{DoxyCode}
var through = require('through');
module.exports = function (file) \{ return through() \};
\end{DoxyCode}


You don\textquotesingle{}t need to necessarily use the \href{https://www.npmjs.com/package/through}{\tt through} module. Browserify is compatible with the newer, more verbose \href{http://nodejs.org/api/stream.html#stream_class_stream_transform_1}{\tt Transform streams} built into \mbox{\hyperlink{classNode}{Node}} v0.\+10.

Here\textquotesingle{}s how you might compile coffee script on the fly using {\ttfamily .transform()}\+:


\begin{DoxyCode}
var coffee = require('coffee-script');
var through = require('through');

b.transform(function (file) \{
    var data = '';
    return through(write, end);

    function write (buf) \{ data += buf \}
    function end () \{
        this.queue(coffee.compile(data));
        this.queue(null);
    \}
\});
\end{DoxyCode}


Note that on the command-\/line with the {\ttfamily -\/c} flag you can just do\+:


\begin{DoxyCode}
$ browserify -c 'coffee -sc' main.coffee > bundle.js
\end{DoxyCode}


Or better still, use the \href{https://github.com/jnordberg/coffeeify}{\tt coffeeify} module\+:


\begin{DoxyCode}
$ npm install coffeeify
$ browserify -t coffeeify main.coffee > bundle.js
\end{DoxyCode}


If {\ttfamily opts.\+global} is {\ttfamily true}, the transform will operate on A\+LL files, despite whether they exist up a level in a {\ttfamily node\+\_\+modules/} directory. Use global transforms cautiously and sparingly, since most of the time an ordinary transform will suffice. You can also not configure global transforms in a {\ttfamily package.\+json} like you can with ordinary transforms.

Global transforms always run after any ordinary transforms have run.

Transforms may obtain options from the command-\/line with \href{https://www.npmjs.com/package/subarg}{\tt subarg} syntax\+:


\begin{DoxyCode}
$ browserify -t [ foo --bar=555 ] main.js
\end{DoxyCode}


or from the api\+:


\begin{DoxyCode}
b.transform('foo', \{ bar: 555 \})
\end{DoxyCode}


In both cases, these options are provided as the second argument to the transform function\+:


\begin{DoxyCode}
module.exports = function (file, opts) \{ /* opts.bar === 555 */ \}
\end{DoxyCode}


Options sent to the browserify constructor are also provided under {\ttfamily opts.\+\_\+flags}. These browserify options are sometimes required if your transform needs to do something different when browserify is run in debug mode, for example.

\subsection*{b.\+plugin(plugin, opts)}

Register a {\ttfamily plugin} with {\ttfamily opts}. Plugins can be a string module name or a function the same as transforms.

{\ttfamily plugin(b, opts)} is called with the browserify instance {\ttfamily b}.

For more information, consult the plugins section below.

\subsection*{b.\+pipeline}

There is an internal \href{https://www.npmjs.com/package/labeled-stream-splicer}{\tt labeled-\/stream-\/splicer} pipeline with these labels\+:


\begin{DoxyItemize}
\item `\textquotesingle{}record'{\ttfamily -\/ save inputs to play back later on subsequent}bundle(){\ttfamily calls $\ast$}\textquotesingle{}deps\textquotesingle{}{\ttfamily -\/ \mbox{[}module-\/deps\mbox{]}(\href{https://www.npmjs.com/package/module-deps}{\tt https\+://www.\+npmjs.\+com/package/module-\/deps}) $\ast$}\textquotesingle{}json\textquotesingle{}{\ttfamily -\/ adds}module.\+exports={\ttfamily to the beginning of json files $\ast$}\textquotesingle{}unbom\textquotesingle{}{\ttfamily -\/ remove byte-\/order markers $\ast$}\textquotesingle{}unshebang\textquotesingle{}{\ttfamily -\/ remove \#! labels on the first line $\ast$}\textquotesingle{}syntax\textquotesingle{}{\ttfamily -\/ check for syntax errors $\ast$}\textquotesingle{}sort\textquotesingle{}{\ttfamily -\/ sort the dependencies for deterministic bundles $\ast$}\textquotesingle{}dedupe\textquotesingle{}{\ttfamily -\/ remove duplicate source contents $\ast$}\textquotesingle{}label\textquotesingle{}{\ttfamily -\/ apply integer labels to files $\ast$}\textquotesingle{}emit-\/deps\textquotesingle{}{\ttfamily -\/ emit}\textquotesingle{}dep\textquotesingle{}{\ttfamily event $\ast$}\textquotesingle{}debug\textquotesingle{}{\ttfamily -\/ apply source maps $\ast$}\textquotesingle{}pack\textquotesingle{}{\ttfamily -\/ \mbox{[}browser-\/pack\mbox{]}(\href{https://www.npmjs.com/package/browser-pack}{\tt https\+://www.\+npmjs.\+com/package/browser-\/pack}) $\ast$}\textquotesingle{}wrap\textquotesingle{}{\ttfamily -\/ apply final wrapping,}require=\`{} and a newline and semicolon
\end{DoxyItemize}

You can call {\ttfamily b.\+pipeline.\+get()} with a label name to get a handle on a stream pipeline that you can {\ttfamily push()}, {\ttfamily unshift()}, or {\ttfamily splice()} to insert your own transform streams.

\subsection*{b.\+reset(opts)}

Reset the pipeline back to a normal state. This function is called automatically when {\ttfamily bundle()} is called multiple times.

This function triggers a \textquotesingle{}reset\textquotesingle{} event.

\section*{package.\+json}

browserify uses the {\ttfamily package.\+json} in its module resolution algorithm, just like node. If there is a {\ttfamily \char`\"{}main\char`\"{}} field, browserify will start resolving the package at that point. If there is no {\ttfamily \char`\"{}main\char`\"{}} field, browserify will look for an {\ttfamily \char`\"{}index.\+js\char`\"{}} file in the module root directory. Here are some more sophisticated things you can do in the package.\+json\+:

\subsection*{browser field}

There is a special \char`\"{}\mbox{[}browser\mbox{]}(https\+://github.\+com/defunctzombie/package-\/browser-\/field-\/spec)\char`\"{} field you can set in your package.\+json on a per-\/module basis to override file resolution for browser-\/specific versions of files.

For example, if you want to have a browser-\/specific module entry point for your {\ttfamily \char`\"{}main\char`\"{}} field you can just set the {\ttfamily \char`\"{}browser\char`\"{}} field to a string\+:


\begin{DoxyCode}
"browser": "./browser.js"
\end{DoxyCode}


or you can have overrides on a per-\/file basis\+:


\begin{DoxyCode}
"browser": \{
  "fs": "level-fs",
  "./lib/ops.js": "./browser/opts.js"
\}
\end{DoxyCode}


Note that the browser field only applies to files in the local module, and like transforms, it doesn\textquotesingle{}t apply into {\ttfamily node\+\_\+modules} directories.

\subsection*{browserify.\+transform}

You can specify source transforms in the package.\+json in the {\ttfamily browserify.\+transform} field. There is more information about how source transforms work in package.\+json on the \href{https://github.com/browserify/module-deps#transforms}{\tt module-\/deps readme}.

For example, if your module requires \href{https://www.npmjs.com/package/brfs}{\tt brfs}, you can add


\begin{DoxyCode}
"browserify": \{ "transform": [ "brfs" ] \}
\end{DoxyCode}


to your package.\+json. Now when somebody {\ttfamily require()}s your module, brfs will automatically be applied to the files in your module without explicit intervention by the person using your module. Make sure to add transforms to your package.\+json dependencies field.

\section*{events}

\subsection*{b.\+on(\textquotesingle{}file\textquotesingle{}, function (file, id, parent) \{\})}

\subsection*{b.\+pipeline.\+on(\textquotesingle{}file\textquotesingle{}, function (file, id, parent) \{\})}

When a file is resolved for the bundle, the bundle emits a `\textquotesingle{}file'{\ttfamily event with the full}file{\ttfamily path, the}id{\ttfamily string passed to}require(){\ttfamily , and the}parent\`{} object used by \href{https://github.com/defunctzombie/node-browser-resolve}{\tt browser-\/resolve}.

You could use the {\ttfamily file} event to implement a file watcher to regenerate bundles when files change.

\subsection*{b.\+on(\textquotesingle{}package\textquotesingle{}, function (pkg) \{\})}

\subsection*{b.\+pipeline.\+on(\textquotesingle{}package\textquotesingle{}, function (pkg) \{\})}

When a package file is read, this event fires with the contents. The package directory is available at {\ttfamily pkg.\+\_\+\+\_\+dirname}.

\subsection*{b.\+on(\textquotesingle{}bundle\textquotesingle{}, function (bundle) \{\})}

When {\ttfamily .bundle()} is called, this event fires with the {\ttfamily bundle} output stream.

\subsection*{b.\+on(\textquotesingle{}reset\textquotesingle{}, function () \{\})}

When the {\ttfamily .reset()} method is called or implicitly called by another call to {\ttfamily .bundle()}, this event fires.

\subsection*{b.\+on(\textquotesingle{}transform\textquotesingle{}, function (tr, file) \{\})}

\subsection*{b.\+pipeline.\+on(\textquotesingle{}transform\textquotesingle{}, function (tr, file) \{\})}

When a transform is applied to a file, the `\textquotesingle{}transform'{\ttfamily event fires on the bundle stream with the transform stream}tr{\ttfamily and the}file\`{} that the transform is being applied to.

\section*{plugins}

For some more advanced use-\/cases, a transform is not sufficiently extensible. Plugins are modules that take the bundle instance as their first parameter and an option hash as their second.

Plugins can be used to do perform some fancy features that transforms can\textquotesingle{}t do. For example, \href{https://www.npmjs.com/package/factor-bundle}{\tt factor-\/bundle} is a plugin that can factor out common dependencies from multiple entry-\/points into a common bundle. Use plugins with {\ttfamily -\/p} and pass options to plugins with \href{https://www.npmjs.com/package/subarg}{\tt subarg} syntax\+:


\begin{DoxyCode}
browserify x.js y.js -p [ factor-bundle -o bundle/x.js -o bundle/y.js ] \(\backslash\)
  > bundle/common.js
\end{DoxyCode}


For a list of plugins, consult the \href{https://www.npmjs.com/browse/keyword/browserify-plugin}{\tt browserify-\/plugin tag} on npm.

\section*{list of source transforms}

There is a \href{https://github.com/browserify/browserify/wiki/list-of-transforms}{\tt wiki page that lists the known browserify transforms}.

If you write a transform, make sure to add your transform to that wiki page and add a package.\+json keyword of {\ttfamily browserify-\/transform} so that \href{https://www.npmjs.com/browse/keyword/browserify-transform}{\tt people can browse for all the browserify transforms} on npmjs.\+org.

\section*{third-\/party tools}

There is a \href{https://github.com/browserify/browserify/wiki/browserify-tools}{\tt wiki page that lists the known browserify tools}.

If you write a tool, make sure to add it to that wiki page and add a package.\+json keyword of {\ttfamily browserify-\/tool} so that \href{https://www.npmjs.com/browse/keyword/browserify-tool}{\tt people can browse for all the browserify tools} on npmjs.\+org.

\section*{changelog}

Releases are documented in changelog.markdown and on the \href{https://twitter.com/browserify}{\tt browserify twitter feed}.

\section*{license}

\href{./LICENSE}{\tt M\+IT}

 