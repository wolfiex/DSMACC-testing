\href{http://travis-ci.org/rvagg/through2}{\tt }

\href{https://nodei.co/npm/through2/}{\tt }

\href{https://david-dm.org/rvagg/through2/}{\tt } \href{https://david-dm.org/rvagg/through2#info=devDependencies/}{\tt }

{\bfseries A tiny wrapper around \mbox{\hyperlink{classNode}{Node}} streams.\+Transform (Streams2) to avoid explicit subclassing noise}

Inspired by \href{https://github.com/dominictarr}{\tt Dominic Tarr}\textquotesingle{}s \href{https://github.com/dominictarr/through}{\tt through} in that it\textquotesingle{}s so much easier to make a stream out of a function than it is to set up the prototype chain properly\+: {\ttfamily through(function (chunk) \{ ... \})}.


\begin{DoxyCode}
fs.createReadStream('ex.txt')
    .pipe(through2(function (chunk, enc, callback) \{
    for (var i = 0; i < chunk.length; i++)
      if (chunk[i] == 97)
        chunk[i] = 122 // swap 'a' for 'z'
    this.push(chunk)
    callback()
  \}))
  .pipe(fs.createWriteStream('out.txt'))
\end{DoxyCode}


Or object streams\+:


\begin{DoxyCode}
var all = []
fs.createReadStream('data.csv')
  .pipe(csv2())
  .pipe(through2(\{ objectMode: true \}, function (chunk, enc, callback) \{
    var data = \{
        name    : chunk[0]
      , address : chunk[3]
      , phone   : chunk[10]
    \}
    this.push(data)
    callback()
  \}))
  .on('data', function (data) \{
    all.push(data)
  \})
  .on('end', function () \{
    doSomethingSpecial(all)
  \})
\end{DoxyCode}


\subsection*{A\+PI}

{\bfseries {\ttfamily through2(\mbox{[} options, \mbox{]} \mbox{[} transform\+Function \mbox{]} \mbox{[}, flush\+Function \mbox{]})}}

Consult the {\bfseries \href{http://nodejs.org/docs/latest/api/stream.html#stream_class_stream_transform}{\tt stream.\+Transform}} documentation for the exact rules of the {\ttfamily transform\+Function} (i.\+e. {\ttfamily this.\+\_\+transform}) and the optional {\ttfamily flush\+Function} (i.\+e. {\ttfamily this.\+\_\+flush}).

\subsubsection*{options}

The options argument is optional and is passed straight through to {\ttfamily stream.\+Transform}. So you can use {\ttfamily object\+Mode\+:true} if you are processing non-\/binary streams.

The {\ttfamily options} argument is first, unlike standard convention, because if I\textquotesingle{}m passing in an anonymous function then I\textquotesingle{}d prefer for the options argument to not get lost at the end of the call\+:


\begin{DoxyCode}
fs.createReadStream('/tmp/important.dat')
    .pipe(through2(\{ objectMode: true, allowHalfOpen: false \}, function (chunk, enc, cb) \{
        this.push(new Buffer('wut?'))
    cb()
    \})
  .pipe(fs.createWriteStream('/tmp/wut.txt'))
\end{DoxyCode}


\subsubsection*{transform\+Function}

The {\ttfamily transform\+Function} must have the following signature\+: {\ttfamily function (chunk, encoding, callback) \{\}}. A minimal implementation should call the {\ttfamily callback} function to indicate that the transformation is done, even if that transformation means discarding the chunk.

To queue a new chunk, call {\ttfamily this.\+push(chunk)}---this can be called as many times as required before the {\ttfamily callback()} if you have multiple pieces to send on.

If you {\bfseries do not provide a {\ttfamily transform\+Function}} then you will get a simple simple pass-\/through stream.

\subsubsection*{flush\+Function}

The optional {\ttfamily flush\+Function} is provided as the last argument (2nd or 3rd, depending on whether you\textquotesingle{}ve supplied options) is called just prior to the stream ending. Can be used to finish up any processing that may be in progress.

{\bfseries {\ttfamily through2.\+ctor(\mbox{[} options, \mbox{]} transform\+Function\mbox{[}, flush\+Function \mbox{]})}}

Instead of returning a {\ttfamily stream.\+Transform} instance, {\ttfamily through2.\+ctor()} returns a {\bfseries constructor} for a custom Transform. This is useful when you want to use the same transform logic in multiple instances.


\begin{DoxyCode}
var FToC = through2.ctor(\{objectMode: true\}, function (record, encoding, callback) \{
  if (record.temp != null && record.unit = "F") \{
    record.temp = ( ( record.temp - 32 ) * 5 ) / 9
    record.unit = "C"
  \}
  this.push(record)
  callback()
\})

// Create instances of FToC like so:
var converter = new FToC()
// Or:
var converter = FToC()
// Or specify/override options when you instantiate, if you prefer:
var converter = FToC(\{objectMode: true\})
\end{DoxyCode}


\subsection*{License}

{\bfseries through2} is Copyright (c) 2013 Rod Vagg \href{https://twitter.com/rvagg}{\tt } and licenced under the M\+IT licence. All rights not explicitly granted in the M\+IT license are reserved. See the included L\+I\+C\+E\+N\+SE file for more details. 