walk the dependency graph to generate json output that can be fed into \href{https://github.com/browserify/browser-pack}{\tt browser-\/pack}

\href{http://travis-ci.org/browserify/module-deps}{\tt }

\section*{example}


\begin{DoxyCode}
var mdeps = require('module-deps');
var JSONStream = require('JSONStream');

var md = mdeps();
md.pipe(JSONStream.stringify()).pipe(process.stdout);
md.end(\{ file: \_\_dirname + '/files/main.js' \});
\end{DoxyCode}


output\+:


\begin{DoxyCode}
$ node example/deps.js
[
\{"id":"/home/substack/projects/module-deps/example/files/main.js","source":"var foo =
       require('./foo');\(\backslash\)nconsole.log('main: ' +
       foo(5));\(\backslash\)n","entry":true,"deps":\{"./foo":"/home/substack/projects/module-deps/example/files/foo.js"\}\}
,
\{"id":"/home/substack/projects/module-deps/example/files/foo.js","source":"var bar =
       require('./bar');\(\backslash\)n\(\backslash\)nmodule.exports = function (n) \{\(\backslash\)n    return n * 111 +
       bar(n);\(\backslash\)n\};\(\backslash\)n","deps":\{"./bar":"/home/substack/projects/module-deps/example/files/bar.js"\}\}
,
\{"id":"/home/substack/projects/module-deps/example/files/bar.js","source":"module.exports = function (n)
       \{\(\backslash\)n    return n * 100;\(\backslash\)n\};\(\backslash\)n","deps":\{\}\}
]
\end{DoxyCode}


and you can feed this json data into \href{https://github.com/browserify/browser-pack}{\tt browser-\/pack}\+:


\begin{DoxyCode}
$ node example/deps.js | browser-pack | node
main: 1055
\end{DoxyCode}


\section*{usage}


\begin{DoxyCode}
usage: module-deps [files]

  generate json output from each entry file
\end{DoxyCode}


\section*{methods}


\begin{DoxyCode}
var mdeps = require('module-deps')
\end{DoxyCode}


\subsection*{var d = mdeps(opts=\{\})}

Return an object transform stream {\ttfamily d} that expects entry filenames or {\ttfamily \{ id\+: ..., file\+: ... \}} objects as input and produces objects for every dependency from a recursive module traversal as output.

Each file in {\ttfamily files} can be a string filename or a stream.

Optionally pass in some {\ttfamily opts}\+:


\begin{DoxyItemize}
\item {\ttfamily opts.\+transform} -\/ a string or array of string transforms (see below)
\item {\ttfamily opts.\+transform\+Key} -\/ an array path of strings showing where to look in the package.\+json for source transformations. If falsy, don\textquotesingle{}t look at the package.\+json at all.
\item {\ttfamily opts.\+resolve} -\/ custom resolve function using the {\ttfamily opts.\+resolve(id, parent, cb)} signature that \href{https://github.com/shtylman/node-browser-resolve}{\tt browser-\/resolve} has
\item {\ttfamily opts.\+detect} -\/ a custom dependency detection function. {\ttfamily opts.\+detect(source)} should return an array of dependency module names. By default \href{https://github.com/browserify/detective}{\tt detective} is used.
\item {\ttfamily opts.\+filter} -\/ a function (id) to skip resolution of some module {\ttfamily id} strings. If defined, {\ttfamily opts.\+filter(id)} should return truthy for all the ids to include and falsey for all the ids to skip.
\item {\ttfamily opts.\+post\+Filter} -\/ a function (id, file, pkg) that gets called after {\ttfamily id} has been resolved. Return false to skip this file.
\item {\ttfamily opts.\+package\+Filter} -\/ transform the parsed package.\+json contents before using the values. {\ttfamily opts.\+package\+Filter(pkg, dir)} should return the new {\ttfamily pkg} object to use.
\item {\ttfamily opts.\+no\+Parse} -\/ an array of absolute paths to not parse for dependencies. Use this for large dependencies like jquery or threejs which take forever to parse.
\item {\ttfamily opts.\+cache} -\/ an object mapping filenames to file objects to skip costly io
\item {\ttfamily opts.\+package\+Cache} -\/ an object mapping filenames to their parent package.\+json contents for browser fields, main entries, and transforms
\item {\ttfamily opts.\+file\+Cache} -\/ an object mapping filenames to raw source to avoid reading from disk.
\item {\ttfamily opts.\+persistent\+Cache} -\/ a complex cache handler that allows async and persistent caching of data. A {\ttfamily persistent\+Cache} needs to follow this interface\+: \`{}\`{}\`{}js function persistent\+Cache ( file, // the path to the file that is loaded id, // the id that is used to reference this file pkg, // the package that this file belongs to fallback fallback, // async fallback handler to be called if the cache doesn\textquotesingle{}t hold the given file cb // callback handler that receives the cache data ) \{ if (has\+Error()) \{ return cb(error) // Pass any error to the callback \}

var file\+Data = fs.\+read\+File\+Sync(file) var key = key\+From\+File(file, file\+Data)

if (db.\+has(key)) \{ return cb(null, \{ source\+: db.\+get(key).to\+String(), package\+: pkg, // The package for housekeeping deps\+: \{ \textquotesingle{}id\textquotesingle{}\+: // id that is used to reference a required file \textquotesingle{}file\textquotesingle{} // file path to the required file \} \}) \} // // The fallback will process the file in case the file is not // in cache. // // Note that if your implementation doesn\textquotesingle{}t need the file data // then you can pass {\ttfamily null} instead of the source and the fallback will // fetch the data by itself. // fallback(file\+Data, function (error, cacheable\+Entry) \{ if (error) \{ return cb(error) \} db.\+add\+To\+Cache(key, cacheable\+Entry) cb(null, cacheable\+Entry) \}) \} \`{}\`{}\`{}
\item {\ttfamily opts.\+paths} -\/ array of global paths to search. Defaults to splitting on `'\+:\textquotesingle{}{\ttfamily  in}process.\+env.\+N\+O\+D\+E\+\_\+\+P\+A\+TH\`{}
\item {\ttfamily opts.\+ignore\+Missing} -\/ ignore files that failed to resolve
\end{DoxyItemize}

\section*{input objects}

Input objects should be string filenames or objects with these parameters\+:


\begin{DoxyItemize}
\item {\ttfamily row.\+file} -\/ filename
\item {\ttfamily row.\+entry} -\/ whether to treat this file as an entry point, defaults to {\ttfamily true}. Set to {\ttfamily false} to include this file, but not run it automatically.
\item {\ttfamily row.\+expose} -\/ name to be exposed as
\item {\ttfamily row.\+noparse} -\/ when true, don\textquotesingle{}t parse the file contents for dependencies
\end{DoxyItemize}

or objects can specify transforms\+:


\begin{DoxyItemize}
\item {\ttfamily row.\+transform} -\/ string name, path, or function
\item {\ttfamily row.\+options} -\/ transform options as an object
\item {\ttfamily row.\+global} -\/ boolean, whether the transform is global
\end{DoxyItemize}

\section*{output objects}

Output objects describe files with dependencies. They have these properties\+:


\begin{DoxyItemize}
\item {\ttfamily row.\+id} -\/ an identifier for the file, used in the {\ttfamily row.\+deps} prperty
\item {\ttfamily row.\+file} -\/ path to the source file
\item {\ttfamily row.\+entry} -\/ true if the file is an entry point
\item {\ttfamily row.\+expose} -\/ name to be exposed as
\item {\ttfamily row.\+source} -\/ source file content as a string
\item {\ttfamily row.\+deps} -\/ object describing dependencies. The keys are strings as used in {\ttfamily require()} calls in the file, and values are the row I\+Ds (file paths) of dependencies.
\end{DoxyItemize}

\section*{events}

\subsection*{d.\+on(\textquotesingle{}transform\textquotesingle{}, function (tr, file) \{\})}

Every time a transform is applied to a {\ttfamily file}, a `\textquotesingle{}transform'{\ttfamily event fires with the instantiated transform stream}tr\`{}.

\subsection*{d.\+on(\textquotesingle{}file\textquotesingle{}, function (file) \{\})}

Every time a file is read, this event fires with the file path.

\subsection*{d.\+on(\textquotesingle{}missing\textquotesingle{}, function (id, parent) \{\})}

When {\ttfamily opts.\+ignore\+Missing} is enabled, this event fires for each missing package.

\subsection*{d.\+on(\textquotesingle{}package\textquotesingle{}, function (pkg) \{\})}

Every time a package is read, this event fires. The directory name of the package is available in {\ttfamily pkg.\+\_\+\+\_\+dirname}.

\section*{transforms}

module-\/deps can be configured to run source transformations on files before parsing them for {\ttfamily require()} calls. These transforms are useful if you want to compile a language like \href{http://coffeescript.org/}{\tt coffeescript} on the fly or if you want to load static assets into your bundle by parsing the A\+ST for {\ttfamily fs.\+read\+File\+Sync()} calls.

If the transform is a function, it should take the {\ttfamily file} name as an argument and return a through stream that will be written file contents and should output the new transformed file contents.

If the transform is a string, it is treated as a module name that will resolve to a module that is expected to follow this format\+:


\begin{DoxyCode}
var through = require('through2');
module.exports = function (file, opts) \{ return through() \};
\end{DoxyCode}


You don\textquotesingle{}t necessarily need to use the \href{https://github.com/rvagg/through2}{\tt through2} module to create a readable/writable filter stream for transforming file contents, but this is an easy way to do it.

module-\/deps looks for {\ttfamily require()} calls and adds their arguments as dependencies of a file. Transform streams can emit `\textquotesingle{}dep'{\ttfamily events to include additional dependencies that are not consumed with}require()\`{}.

When you call {\ttfamily mdeps()} with an {\ttfamily opts.\+transform}, the transformations you specify will not be run for any files in node\+\_\+modules/. This is because modules you include should be self-\/contained and not need to worry about guarding themselves against transformations that may happen upstream.

Modules can apply their own transformations by setting a transformation pipeline in their package.\+json at the {\ttfamily opts.\+transform\+Key} path. These transformations only apply to the files directly in the module itself, not to the module\textquotesingle{}s dependants nor to its dependencies.

\subsection*{package.\+json transform\+Key}

Transform keys live at a configurable location in the package.\+json denoted by the {\ttfamily opts.\+transform\+Key} array.

For a transform\+Key of `\mbox{[}\textquotesingle{}foo',\textquotesingle{}bar\textquotesingle{}\mbox{]}{\ttfamily , the transform\+Key can be a single string (}\char`\"{}fff\char`\"{}\`{})\+:


\begin{DoxyCode}
\{
  "foo": \{
    "bar": "fff"
  \}
\}
\end{DoxyCode}


or an array of strings ({\ttfamily \mbox{[}\char`\"{}fff\char`\"{},\char`\"{}ggg\char`\"{}\mbox{]}})\+:


\begin{DoxyCode}
\{
  "foo": \{
    "bar": ["fff","ggg"]
  \}
\}
\end{DoxyCode}


If you want to pass options to the transforms, you can use a 2-\/element array inside of the primary array. Here {\ttfamily fff} gets an options object with {\ttfamily \{\char`\"{}x\char`\"{}\+:3\}} and {\ttfamily ggg} gets {\ttfamily \{\char`\"{}y\char`\"{}\+:4\}}\+:


\begin{DoxyCode}
\{
  "foo": \{
    "bar": [["fff",\{"x":3\}],["ggg",\{"y":4\}]]
  \}
\}
\end{DoxyCode}


Options sent to the module-\/deps constructor are also provided under {\ttfamily opts.\+\_\+flags}. These options are sometimes required if your transform needs to do something different when browserify is run in debug mode, for example.

\section*{usage}


\begin{DoxyCode}
module-deps [FILES] OPTIONS

  Generate json output for the entry point FILES.

OPTIONS are:

  -t TRANSFORM  Apply a TRANSFORM.
  -g TRANSFORM  Apply a global TRANSFORM.
\end{DoxyCode}


\section*{install}

With \href{http://npmjs.org}{\tt npm}, to get the module do\+:


\begin{DoxyCode}
npm install module-deps
\end{DoxyCode}


and to get the {\ttfamily module-\/deps} command do\+:


\begin{DoxyCode}
npm install -g module-deps
\end{DoxyCode}


\section*{license}

M\+IT 