\href{http://travis-ci.org/tj/commander.js}{\tt } \href{https://www.npmjs.org/package/commander}{\tt } \href{https://npmcharts.com/compare/commander?minimal=true}{\tt } \href{https://packagephobia.now.sh/result?p=commander}{\tt } \href{https://gitter.im/tj/commander.js?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge}{\tt }

The complete solution for \href{http://nodejs.org}{\tt node.\+js} command-\/line interfaces, inspired by Ruby\textquotesingle{}s \href{https://github.com/commander-rb/commander}{\tt commander}. ~\newline
 \href{http://tj.github.com/commander.js/}{\tt A\+PI documentation}

\subsection*{Installation}

\begin{DoxyVerb}$ npm install commander
\end{DoxyVerb}


\subsection*{\mbox{\hyperlink{structOption}{Option}} parsing}

Options with commander are defined with the {\ttfamily .option()} method, also serving as documentation for the options. The example below parses args and options from {\ttfamily process.\+argv}, leaving remaining args as the {\ttfamily program.\+args} array which were not consumed by options.


\begin{DoxyCode}
#!/usr/bin/env node

/**
 * Module dependencies.
 */

var program = require('commander');

program
  .version('0.1.0')
  .option('-p, --peppers', 'Add peppers')
  .option('-P, --pineapple', 'Add pineapple')
  .option('-b, --bbq-sauce', 'Add bbq sauce')
  .option('-c, --cheese [type]', 'Add the specified type of cheese [marble]', 'marble')
  .parse(process.argv);

console.log('you ordered a pizza with:');
if (program.peppers) console.log('  - peppers');
if (program.pineapple) console.log('  - pineapple');
if (program.bbqSauce) console.log('  - bbq');
console.log('  - %s cheese', program.cheese);
\end{DoxyCode}


Short flags may be passed as a single arg, for example {\ttfamily -\/abc} is equivalent to {\ttfamily -\/a -\/b -\/c}. Multi-\/word options such as \char`\"{}-\/-\/template-\/engine\char`\"{} are camel-\/cased, becoming {\ttfamily program.\+template\+Engine} etc.

Note that multi-\/word options starting with {\ttfamily -\/-\/no} prefix negate the boolean value of the following word. For example, {\ttfamily -\/-\/no-\/sauce} sets the value of {\ttfamily program.\+sauce} to false.


\begin{DoxyCode}
#!/usr/bin/env node

/**
 * Module dependencies.
 */

var program = require('commander');

program
  .option('--no-sauce', 'Remove sauce')
  .parse(process.argv);

console.log('you ordered a pizza');
if (program.sauce) console.log('  with sauce');
else console.log(' without sauce');
\end{DoxyCode}


To get string arguments from options you will need to use angle brackets $<$$>$ for required inputs or square brackets \mbox{[}\mbox{]} for optional inputs.

e.\+g. {\ttfamily .option(\textquotesingle{}-\/m -\/-\/myarg \mbox{[}my\+Var\mbox{]}\textquotesingle{}, \textquotesingle{}my super cool description\textquotesingle{})}

Then to access the input if it was passed in.

e.\+g. {\ttfamily var my\+Input = program.\+myarg}

{\bfseries N\+O\+TE}\+: If you pass a argument without using brackets the example above will return true and not the value passed in.

\subsection*{Version option}

Calling the {\ttfamily version} implicitly adds the {\ttfamily -\/V} and {\ttfamily -\/-\/version} options to the command. When either of these options is present, the command prints the version number and exits. \begin{DoxyVerb}$ ./examples/pizza -V
0.0.1
\end{DoxyVerb}


If you want your program to respond to the {\ttfamily -\/v} option instead of the {\ttfamily -\/V} option, simply pass custom flags to the {\ttfamily version} method using the same syntax as the {\ttfamily option} method.


\begin{DoxyCode}
program
  .version('0.0.1', '-v, --version')
\end{DoxyCode}


The version flags can be named anything, but the long option is required.

\subsection*{Command-\/specific options}

You can attach options to a command.


\begin{DoxyCode}
#!/usr/bin/env node

var program = require('commander');

program
  .command('rm <dir>')
  .option('-r, --recursive', 'Remove recursively')
  .action(function (dir, cmd) \{
    console.log('remove ' + dir + (cmd.recursive ? ' recursively' : ''))
  \})

program.parse(process.argv)
\end{DoxyCode}


A command\textquotesingle{}s options are validated when the command is used. Any unknown options will be reported as an error. However, if an action-\/based command does not define an action, then the options are not validated.

\subsection*{Coercion}


\begin{DoxyCode}
function range(val) \{
  return val.split('..').map(Number);
\}

function list(val) \{
  return val.split(',');
\}

function collect(val, memo) \{
  memo.push(val);
  return memo;
\}

function increaseVerbosity(v, total) \{
  return total + 1;
\}

program
  .version('0.1.0')
  .usage('[options] <file ...>')
  .option('-i, --integer <n>', 'An integer argument', parseInt)
  .option('-f, --float <n>', 'A float argument', parseFloat)
  .option('-r, --range <a>..<b>', 'A range', range)
  .option('-l, --list <items>', 'A list', list)
  .option('-o, --optional [value]', 'An optional value')
  .option('-c, --collect [value]', 'A repeatable value', collect, [])
  .option('-v, --verbose', 'A value that can be increased', increaseVerbosity, 0)
  .parse(process.argv);

console.log(' int: %j', program.integer);
console.log(' float: %j', program.float);
console.log(' optional: %j', program.optional);
program.range = program.range || [];
console.log(' range: %j..%j', program.range[0], program.range[1]);
console.log(' list: %j', program.list);
console.log(' collect: %j', program.collect);
console.log(' verbosity: %j', program.verbose);
console.log(' args: %j', program.args);
\end{DoxyCode}


\#\# Regular Expression 
\begin{DoxyCode}
program
  .version('0.1.0')
  .option('-s --size <size>', 'Pizza size', /^(large|medium|small)$/i, 'medium')
  .option('-d --drink [drink]', 'Drink', /^(coke|pepsi|izze)$/i)
  .parse(process.argv);

console.log(' size: %j', program.size);
console.log(' drink: %j', program.drink);
\end{DoxyCode}


\subsection*{Variadic arguments}

The last argument of a command can be variadic, and only the last argument. To make an argument variadic you have to append {\ttfamily ...} to the argument name. Here is an example\+:


\begin{DoxyCode}
#!/usr/bin/env node

/**
 * Module dependencies.
 */

var program = require('commander');

program
  .version('0.1.0')
  .command('rmdir <dir> [otherDirs...]')
  .action(function (dir, otherDirs) \{
    console.log('rmdir %s', dir);
    if (otherDirs) \{
      otherDirs.forEach(function (oDir) \{
        console.log('rmdir %s', oDir);
      \});
    \}
  \});

program.parse(process.argv);
\end{DoxyCode}


An {\ttfamily Array} is used for the value of a variadic argument. This applies to {\ttfamily program.\+args} as well as the argument passed to your action as demonstrated above.

\subsection*{Specify the argument syntax}


\begin{DoxyCode}
#!/usr/bin/env node

var program = require('commander');

program
  .version('0.1.0')
  .arguments('<cmd> [env]')
  .action(function (cmd, env) \{
     cmdValue = cmd;
     envValue = env;
  \});

program.parse(process.argv);

if (typeof cmdValue === 'undefined') \{
   console.error('no command given!');
   process.exit(1);
\}
console.log('command:', cmdValue);
console.log('environment:', envValue || "no environment given");
\end{DoxyCode}
 Angled brackets (e.\+g. {\ttfamily $<$cmd$>$}) indicate required input. Square brackets (e.\+g. {\ttfamily \mbox{[}env\mbox{]}}) indicate optional input.

\subsection*{Git-\/style sub-\/commands}


\begin{DoxyCode}
// file: ./examples/pm
var program = require('commander');

program
  .version('0.1.0')
  .command('install [name]', 'install one or more packages')
  .command('search [query]', 'search with optional query')
  .command('list', 'list packages installed', \{isDefault: true\})
  .parse(process.argv);
\end{DoxyCode}


When {\ttfamily .command()} is invoked with a description argument, no {\ttfamily .action(callback)} should be called to handle sub-\/commands, otherwise there will be an error. This tells commander that you\textquotesingle{}re going to use separate executables for sub-\/commands, much like {\ttfamily git(1)} and other popular tools. ~\newline
The commander will try to search the executables in the directory of the entry script (like {\ttfamily ./examples/pm}) with the name {\ttfamily program-\/command}, like {\ttfamily pm-\/install}, {\ttfamily pm-\/search}.

Options can be passed with the call to {\ttfamily .command()}. Specifying {\ttfamily true} for {\ttfamily opts.\+no\+Help} will remove the subcommand from the generated help output. Specifying {\ttfamily true} for {\ttfamily opts.\+is\+Default} will run the subcommand if no other subcommand is specified.

If the program is designed to be installed globally, make sure the executables have proper modes, like {\ttfamily 755}.

\subsubsection*{{\ttfamily -\/-\/harmony}}

You can enable {\ttfamily -\/-\/harmony} option in two ways\+:
\begin{DoxyItemize}
\item Use {\ttfamily \#! /usr/bin/env node -\/-\/harmony} in the sub-\/commands scripts. Note some os version donâ€™t support this pattern.
\item Use the {\ttfamily -\/-\/harmony} option when call the command, like {\ttfamily node -\/-\/harmony examples/pm publish}. The {\ttfamily -\/-\/harmony} option will be preserved when spawning sub-\/command process.
\end{DoxyItemize}

\subsection*{Automated --help}

The help information is auto-\/generated based on the information commander already knows about your program, so the following {\ttfamily -\/-\/help} info is for free\+:


\begin{DoxyCode}
$ ./examples/pizza --help
Usage: pizza [options]

An application for pizzas ordering

Options:
  -h, --help           output usage information
  -V, --version        output the version number
  -p, --peppers        Add peppers
  -P, --pineapple      Add pineapple
  -b, --bbq            Add bbq sauce
  -c, --cheese <type>  Add the specified type of cheese [marble]
  -C, --no-cheese      You do not want any cheese
\end{DoxyCode}


\subsection*{Custom help}

You can display arbitrary {\ttfamily -\/h, -\/-\/help} information by listening for \char`\"{}-\/-\/help\char`\"{}. Commander will automatically exit once you are done so that the remainder of your program does not execute causing undesired behaviors, for example in the following executable \char`\"{}stuff\char`\"{} will not output when {\ttfamily -\/-\/help} is used.


\begin{DoxyCode}
#!/usr/bin/env node

/**
 * Module dependencies.
 */

var program = require('commander');

program
  .version('0.1.0')
  .option('-f, --foo', 'enable some foo')
  .option('-b, --bar', 'enable some bar')
  .option('-B, --baz', 'enable some baz');

// must be before .parse() since
// node's emit() is immediate

program.on('--help', function()\{
  console.log('')
  console.log('Examples:');
  console.log('  $ custom-help --help');
  console.log('  $ custom-help -h');
\});

program.parse(process.argv);

console.log('stuff');
\end{DoxyCode}


Yields the following help output when {\ttfamily node script-\/name.\+js -\/h} or {\ttfamily node script-\/name.\+js -\/-\/help} are run\+:


\begin{DoxyCode}
Usage: custom-help [options]

Options:
  -h, --help     output usage information
  -V, --version  output the version number
  -f, --foo      enable some foo
  -b, --bar      enable some bar
  -B, --baz      enable some baz

Examples:
  $ custom-help --help
  $ custom-help -h
\end{DoxyCode}


\subsection*{.output\+Help(cb)}

Output help information without exiting. Optional callback cb allows post-\/processing of help text before it is displayed.

If you want to display help by default (e.\+g. if no command was provided), you can use something like\+:


\begin{DoxyCode}
var program = require('commander');
var colors = require('colors');

program
  .version('0.1.0')
  .command('getstream [url]', 'get stream URL')
  .parse(process.argv);

if (!process.argv.slice(2).length) \{
  program.outputHelp(make\_red);
\}

function make\_red(txt) \{
  return colors.red(txt); //display the help text in red on the console
\}
\end{DoxyCode}


\subsection*{.help(cb)}

Output help information and exit immediately. Optional callback cb allows post-\/processing of help text before it is displayed.

\subsection*{Custom event listeners}

You can execute custom actions by listening to command and option events.


\begin{DoxyCode}
program.on('option:verbose', function () \{
  process.env.VERBOSE = this.verbose;
\});

// error on unknown commands
program.on('command:*', function () \{
  console.error('Invalid command: %s\(\backslash\)nSee --help for a list of available commands.', program.args.join('
       '));
  process.exit(1);
\});
\end{DoxyCode}


\subsection*{Examples}


\begin{DoxyCode}
var program = require('commander');

program
  .version('0.1.0')
  .option('-C, --chdir <path>', 'change the working directory')
  .option('-c, --config <path>', 'set config path. defaults to ./deploy.conf')
  .option('-T, --no-tests', 'ignore test hook');

program
  .command('setup [env]')
  .description('run setup commands for all envs')
  .option("-s, --setup\_mode [mode]", "Which setup mode to use")
  .action(function(env, options)\{
    var mode = options.setup\_mode || "normal";
    env = env || 'all';
    console.log('setup for %s env(s) with %s mode', env, mode);
  \});

program
  .command('exec <cmd>')
  .alias('ex')
  .description('execute the given remote cmd')
  .option("-e, --exec\_mode <mode>", "Which exec mode to use")
  .action(function(cmd, options)\{
    console.log('exec "%s" using %s mode', cmd, options.exec\_mode);
  \}).on('--help', function() \{
    console.log('');
    console.log('Examples:');
    console.log('');
    console.log('  $ deploy exec sequential');
    console.log('  $ deploy exec async');
  \});

program
  .command('*')
  .action(function(env)\{
    console.log('deploying "%s"', env);
  \});

program.parse(process.argv);
\end{DoxyCode}


More Demos can be found in the \href{https://github.com/tj/commander.js/tree/master/examples}{\tt examples} directory.

\subsection*{License}

\href{https://github.com/tj/commander.js/blob/master/LICENSE}{\tt M\+IT} 