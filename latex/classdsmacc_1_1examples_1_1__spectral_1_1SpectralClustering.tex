\hypertarget{classdsmacc_1_1examples_1_1__spectral_1_1SpectralClustering}{}\section{dsmacc.\+examples.\+\_\+spectral.\+Spectral\+Clustering Class Reference}
\label{classdsmacc_1_1examples_1_1__spectral_1_1SpectralClustering}\index{dsmacc.\+examples.\+\_\+spectral.\+Spectral\+Clustering@{dsmacc.\+examples.\+\_\+spectral.\+Spectral\+Clustering}}
Inheritance diagram for dsmacc.\+examples.\+\_\+spectral.\+Spectral\+Clustering\+:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=1.978799cm]{classdsmacc_1_1examples_1_1__spectral_1_1SpectralClustering}
\end{center}
\end{figure}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{classdsmacc_1_1examples_1_1__spectral_1_1SpectralClustering_a850315e1678fb3638054fd7e3db1de60}\label{classdsmacc_1_1examples_1_1__spectral_1_1SpectralClustering_a850315e1678fb3638054fd7e3db1de60}} 
def {\bfseries \+\_\+\+\_\+init\+\_\+\+\_\+} (self, n\+\_\+clusters=8, eigen\+\_\+solver=None, n\+\_\+components=None, random\+\_\+state=None, n\+\_\+init=10, gamma=1., affinity=\textquotesingle{}rbf\textquotesingle{}, n\+\_\+neighbors=10, eigen\+\_\+tol=0.\+0, assign\+\_\+labels=\textquotesingle{}kmeans\textquotesingle{}, degree=3, coef0=1, kernel\+\_\+params=None, n\+\_\+jobs=None)
\item 
def \mbox{\hyperlink{classdsmacc_1_1examples_1_1__spectral_1_1SpectralClustering_a5af13c6812bd105744f4682a0f084511}{fit}} (self, X, y=None)
\item 
def \mbox{\hyperlink{classdsmacc_1_1examples_1_1__spectral_1_1SpectralClustering_a2199033bd2458f93914ca1a1ad26ca23}{fit\+\_\+predict}} (self, X, y=None)
\end{DoxyCompactItemize}
\subsection*{Public Attributes}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{classdsmacc_1_1examples_1_1__spectral_1_1SpectralClustering_aa5bf2b5cac4103f9837f50dfac13e1c6}\label{classdsmacc_1_1examples_1_1__spectral_1_1SpectralClustering_aa5bf2b5cac4103f9837f50dfac13e1c6}} 
{\bfseries n\+\_\+clusters}
\item 
\mbox{\Hypertarget{classdsmacc_1_1examples_1_1__spectral_1_1SpectralClustering_aba12ac3e483a35b287709872664a4ebc}\label{classdsmacc_1_1examples_1_1__spectral_1_1SpectralClustering_aba12ac3e483a35b287709872664a4ebc}} 
{\bfseries eigen\+\_\+solver}
\item 
\mbox{\Hypertarget{classdsmacc_1_1examples_1_1__spectral_1_1SpectralClustering_a6b47d41f0a09f3349091539ec9947d3b}\label{classdsmacc_1_1examples_1_1__spectral_1_1SpectralClustering_a6b47d41f0a09f3349091539ec9947d3b}} 
{\bfseries n\+\_\+components}
\item 
\mbox{\Hypertarget{classdsmacc_1_1examples_1_1__spectral_1_1SpectralClustering_abea0baa6809240593656bcf0936913c5}\label{classdsmacc_1_1examples_1_1__spectral_1_1SpectralClustering_abea0baa6809240593656bcf0936913c5}} 
{\bfseries random\+\_\+state}
\item 
\mbox{\Hypertarget{classdsmacc_1_1examples_1_1__spectral_1_1SpectralClustering_a78f94706fca848791697e809c978da5d}\label{classdsmacc_1_1examples_1_1__spectral_1_1SpectralClustering_a78f94706fca848791697e809c978da5d}} 
{\bfseries n\+\_\+init}
\item 
\mbox{\Hypertarget{classdsmacc_1_1examples_1_1__spectral_1_1SpectralClustering_a23dc7f166fed307997567d8f1974b1cf}\label{classdsmacc_1_1examples_1_1__spectral_1_1SpectralClustering_a23dc7f166fed307997567d8f1974b1cf}} 
{\bfseries gamma}
\item 
\mbox{\Hypertarget{classdsmacc_1_1examples_1_1__spectral_1_1SpectralClustering_a8e59c078b139bdb5926704652b20ed84}\label{classdsmacc_1_1examples_1_1__spectral_1_1SpectralClustering_a8e59c078b139bdb5926704652b20ed84}} 
{\bfseries affinity}
\item 
\mbox{\Hypertarget{classdsmacc_1_1examples_1_1__spectral_1_1SpectralClustering_a697d0e9c49ece85db9183cb7920d1c5d}\label{classdsmacc_1_1examples_1_1__spectral_1_1SpectralClustering_a697d0e9c49ece85db9183cb7920d1c5d}} 
{\bfseries n\+\_\+neighbors}
\item 
\mbox{\Hypertarget{classdsmacc_1_1examples_1_1__spectral_1_1SpectralClustering_aa5e9631e6a8e9ffa65735a59d06e9ef4}\label{classdsmacc_1_1examples_1_1__spectral_1_1SpectralClustering_aa5e9631e6a8e9ffa65735a59d06e9ef4}} 
{\bfseries eigen\+\_\+tol}
\item 
\mbox{\Hypertarget{classdsmacc_1_1examples_1_1__spectral_1_1SpectralClustering_a94b0921d29987261844f3a00341f4cfe}\label{classdsmacc_1_1examples_1_1__spectral_1_1SpectralClustering_a94b0921d29987261844f3a00341f4cfe}} 
{\bfseries assign\+\_\+labels}
\item 
\mbox{\Hypertarget{classdsmacc_1_1examples_1_1__spectral_1_1SpectralClustering_ae8ec8f3855e335b5d246914d80112468}\label{classdsmacc_1_1examples_1_1__spectral_1_1SpectralClustering_ae8ec8f3855e335b5d246914d80112468}} 
{\bfseries degree}
\item 
\mbox{\Hypertarget{classdsmacc_1_1examples_1_1__spectral_1_1SpectralClustering_acd77a122fba25696e63b265ef89d89e8}\label{classdsmacc_1_1examples_1_1__spectral_1_1SpectralClustering_acd77a122fba25696e63b265ef89d89e8}} 
{\bfseries coef0}
\item 
\mbox{\Hypertarget{classdsmacc_1_1examples_1_1__spectral_1_1SpectralClustering_a1dfa3f4606cc0e7bd50bf346e745aebf}\label{classdsmacc_1_1examples_1_1__spectral_1_1SpectralClustering_a1dfa3f4606cc0e7bd50bf346e745aebf}} 
{\bfseries kernel\+\_\+params}
\item 
\mbox{\Hypertarget{classdsmacc_1_1examples_1_1__spectral_1_1SpectralClustering_a139a5d2dee1a79c5a4a8a9afdda22b36}\label{classdsmacc_1_1examples_1_1__spectral_1_1SpectralClustering_a139a5d2dee1a79c5a4a8a9afdda22b36}} 
{\bfseries n\+\_\+jobs}
\item 
\mbox{\Hypertarget{classdsmacc_1_1examples_1_1__spectral_1_1SpectralClustering_a7ef3a45e4b2af7f8addecf187fa409b1}\label{classdsmacc_1_1examples_1_1__spectral_1_1SpectralClustering_a7ef3a45e4b2af7f8addecf187fa409b1}} 
{\bfseries affinity\+\_\+matrix\+\_\+}
\item 
\mbox{\Hypertarget{classdsmacc_1_1examples_1_1__spectral_1_1SpectralClustering_ae73c7ce7d73f1cfc4220c9bb0b130cb4}\label{classdsmacc_1_1examples_1_1__spectral_1_1SpectralClustering_ae73c7ce7d73f1cfc4220c9bb0b130cb4}} 
{\bfseries labels\+\_\+}
\end{DoxyCompactItemize}


\subsection{Detailed Description}
\begin{DoxyVerb}Apply clustering to a projection of the normalized Laplacian.

In practice Spectral Clustering is very useful when the structure of
the individual clusters is highly non-convex or more generally when
a measure of the center and spread of the cluster is not a suitable
description of the complete cluster. For instance when clusters are
nested circles on the 2D plane.

If affinity is the adjacency matrix of a graph, this method can be
used to find normalized graph cuts.

When calling ``fit``, an affinity matrix is constructed using either
kernel function such the Gaussian (aka RBF) kernel of the euclidean
distanced ``d(X, X)``::

        np.exp(-gamma * d(X,X) ** 2)

or a k-nearest neighbors connectivity matrix.

Alternatively, using ``precomputed``, a user-provided affinity
matrix can be used.

Read more in the :ref:`User Guide <spectral_clustering>`.

Parameters
----------
n_clusters : integer, optional
    The dimension of the projection subspace.

eigen_solver : {None, 'arpack', 'lobpcg', or 'amg'}
    The eigenvalue decomposition strategy to use. AMG requires pyamg
    to be installed. It can be faster on very large, sparse problems,
    but may also lead to instabilities.

n_components : integer, optional, default=n_clusters
    Number of eigen vectors to use for the spectral embedding

random_state : int, RandomState instance or None (default)
    A pseudo random number generator used for the initialization of the
    lobpcg eigen vectors decomposition when ``eigen_solver='amg'`` and by
    the K-Means initialization. Use an int to make the randomness
    deterministic.
    See :term:`Glossary <random_state>`.

n_init : int, optional, default: 10
    Number of time the k-means algorithm will be run with different
    centroid seeds. The final results will be the best output of
    n_init consecutive runs in terms of inertia.

gamma : float, default=1.0
    Kernel coefficient for rbf, poly, sigmoid, laplacian and chi2 kernels.
    Ignored for ``affinity='nearest_neighbors'``.

affinity : string or callable, default 'rbf'
    How to construct the affinity matrix.
     - 'nearest_neighbors' : construct the affinity matrix by computing a
       graph of nearest neighbors.
     - 'rbf' : construct the affinity matrix using a radial basis function
       (RBF) kernel.
     - 'precomputed' : interpret ``X`` as a precomputed affinity matrix.
     - 'precomputed_nearest_neighbors' : interpret ``X`` as a sparse graph
       of precomputed nearest neighbors, and constructs the affinity matrix
       by selecting the ``n_neighbors`` nearest neighbors.
     - one of the kernels supported by
       :func:`~sklearn.metrics.pairwise_kernels`.

    Only kernels that produce similarity scores (non-negative values that
    increase with similarity) should be used. This property is not checked
    by the clustering algorithm.

n_neighbors : integer
    Number of neighbors to use when constructing the affinity matrix using
    the nearest neighbors method. Ignored for ``affinity='rbf'``.

eigen_tol : float, optional, default: 0.0
    Stopping criterion for eigendecomposition of the Laplacian matrix
    when ``eigen_solver='arpack'``.

assign_labels : {'kmeans', 'discretize'}, default: 'kmeans'
    The strategy to use to assign labels in the embedding
    space. There are two ways to assign labels after the laplacian
    embedding. k-means can be applied and is a popular choice. But it can
    also be sensitive to initialization. Discretization is another approach
    which is less sensitive to random initialization.

degree : float, default=3
    Degree of the polynomial kernel. Ignored by other kernels.

coef0 : float, default=1
    Zero coefficient for polynomial and sigmoid kernels.
    Ignored by other kernels.

kernel_params : dictionary of string to any, optional
    Parameters (keyword arguments) and values for kernel passed as
    callable object. Ignored by other kernels.

n_jobs : int or None, optional (default=None)
    The number of parallel jobs to run.
    ``None`` means 1 unless in a :obj:`joblib.parallel_backend` context.
    ``-1`` means using all processors. See :term:`Glossary <n_jobs>`
    for more details.

Attributes
----------
affinity_matrix_ : array-like, shape (n_samples, n_samples)
    Affinity matrix used for clustering. Available only if after calling
    ``fit``.

labels_ : array, shape (n_samples,)
    Labels of each point

Examples
--------
>>> from sklearn.cluster import SpectralClustering
>>> import numpy as np
>>> X = np.array([[1, 1], [2, 1], [1, 0],
...               [4, 7], [3, 5], [3, 6]])
>>> clustering = SpectralClustering(n_clusters=2,
...         assign_labels="discretize",
...         random_state=0).fit(X)
>>> clustering.labels_
array([1, 1, 1, 0, 0, 0])
>>> clustering
SpectralClustering(assign_labels='discretize', n_clusters=2,
    random_state=0)

Notes
-----
If you have an affinity matrix, such as a distance matrix,
for which 0 means identical elements, and high values means
very dissimilar elements, it can be transformed in a
similarity matrix that is well suited for the algorithm by
applying the Gaussian (RBF, heat) kernel::

    np.exp(- dist_matrix ** 2 / (2. * delta ** 2))

Where ``delta`` is a free parameter representing the width of the Gaussian
kernel.

Another alternative is to take a symmetric version of the k
nearest neighbors connectivity matrix of the points.

If the pyamg package is installed, it is used: this greatly
speeds up computation.

References
----------

- Normalized cuts and image segmentation, 2000
  Jianbo Shi, Jitendra Malik
  http://citeseer.ist.psu.edu/viewdoc/summary?doi=10.1.1.160.2324

- A Tutorial on Spectral Clustering, 2007
  Ulrike von Luxburg
  http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.165.9323

- Multiclass spectral clustering, 2003
  Stella X. Yu, Jianbo Shi
  https://www1.icsi.berkeley.edu/~stellayu/publication/doc/2003kwayICCV.pdf
\end{DoxyVerb}
 

\subsection{Member Function Documentation}
\mbox{\Hypertarget{classdsmacc_1_1examples_1_1__spectral_1_1SpectralClustering_a5af13c6812bd105744f4682a0f084511}\label{classdsmacc_1_1examples_1_1__spectral_1_1SpectralClustering_a5af13c6812bd105744f4682a0f084511}} 
\index{dsmacc\+::examples\+::\+\_\+spectral\+::\+Spectral\+Clustering@{dsmacc\+::examples\+::\+\_\+spectral\+::\+Spectral\+Clustering}!fit@{fit}}
\index{fit@{fit}!dsmacc\+::examples\+::\+\_\+spectral\+::\+Spectral\+Clustering@{dsmacc\+::examples\+::\+\_\+spectral\+::\+Spectral\+Clustering}}
\subsubsection{\texorpdfstring{fit()}{fit()}}
{\footnotesize\ttfamily def dsmacc.\+examples.\+\_\+spectral.\+Spectral\+Clustering.\+fit (\begin{DoxyParamCaption}\item[{}]{self,  }\item[{}]{X,  }\item[{}]{y = {\ttfamily None} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Perform spectral clustering from features, or affinity matrix.

Parameters
----------
X : array-like or sparse matrix, shape (n_samples, n_features), or \
    array-like, shape (n_samples, n_samples)
    Training instances to cluster, or similarities / affinities between
    instances if ``affinity='precomputed'``. If a sparse matrix is
    provided in a format other than ``csr_matrix``, ``csc_matrix``,
    or ``coo_matrix``, it will be converted into a sparse
    ``csr_matrix``.

y : Ignored
    Not used, present here for API consistency by convention.

Returns
-------
self\end{DoxyVerb}
 
\begin{DoxyCode}
459     \textcolor{keyword}{def }fit(self, X, y=None):
460         \textcolor{stringliteral}{"""Perform spectral clustering from features, or affinity matrix.}
461 \textcolor{stringliteral}{}
462 \textcolor{stringliteral}{        Parameters}
463 \textcolor{stringliteral}{        ----------}
464 \textcolor{stringliteral}{        X : array-like or sparse matrix, shape (n\_samples, n\_features), or \(\backslash\)}
465 \textcolor{stringliteral}{            array-like, shape (n\_samples, n\_samples)}
466 \textcolor{stringliteral}{            Training instances to cluster, or similarities / affinities between}
467 \textcolor{stringliteral}{            instances if ``affinity='precomputed'``. If a sparse matrix is}
468 \textcolor{stringliteral}{            provided in a format other than ``csr\_matrix``, ``csc\_matrix``,}
469 \textcolor{stringliteral}{            or ``coo\_matrix``, it will be converted into a sparse}
470 \textcolor{stringliteral}{            ``csr\_matrix``.}
471 \textcolor{stringliteral}{}
472 \textcolor{stringliteral}{        y : Ignored}
473 \textcolor{stringliteral}{            Not used, present here for API consistency by convention.}
474 \textcolor{stringliteral}{}
475 \textcolor{stringliteral}{        Returns}
476 \textcolor{stringliteral}{        -------}
477 \textcolor{stringliteral}{        self}
478 \textcolor{stringliteral}{}
479 \textcolor{stringliteral}{        """}
480         X = check\_array(X, accept\_sparse=[\textcolor{stringliteral}{'csr'}, \textcolor{stringliteral}{'csc'}, \textcolor{stringliteral}{'coo'}],
481                         dtype=np.float64, ensure\_min\_samples=2)
482         allow\_squared = self.affinity \textcolor{keywordflow}{in} [\textcolor{stringliteral}{"precomputed"},
483                                           \textcolor{stringliteral}{"precomputed\_nearest\_neighbors"}]
484         \textcolor{keywordflow}{if} X.shape[0] == X.shape[1] \textcolor{keywordflow}{and} \textcolor{keywordflow}{not} allow\_squared:
485             warnings.warn(\textcolor{stringliteral}{"The spectral clustering API has changed. ``fit``"}
486                           \textcolor{stringliteral}{"now constructs an affinity matrix from data. To use"}
487                           \textcolor{stringliteral}{" a custom affinity matrix, "}
488                           \textcolor{stringliteral}{"set ``affinity=precomputed``."})
489 
490         \textcolor{keywordflow}{if} self.affinity == \textcolor{stringliteral}{'nearest\_neighbors'}:
491             connectivity = kneighbors\_graph(X, n\_neighbors=self.n\_neighbors,
492                                             include\_self=\textcolor{keyword}{True},
493                                             n\_jobs=self.n\_jobs)
494             self.affinity\_matrix\_ = 0.5 * (connectivity + connectivity.T)
495         \textcolor{keywordflow}{elif} self.affinity == \textcolor{stringliteral}{'precomputed\_nearest\_neighbors'}:
496             estimator = NearestNeighbors(n\_neighbors=self.n\_neighbors,
497                                          n\_jobs=self.n\_jobs,
498                                          metric=\textcolor{stringliteral}{"precomputed"}).fit(X)
499             connectivity = estimator.kneighbors\_graph(X=X, mode=\textcolor{stringliteral}{'connectivity'})
500             self.affinity\_matrix\_ = 0.5 * (connectivity + connectivity.T)
501         \textcolor{keywordflow}{elif} self.affinity == \textcolor{stringliteral}{'precomputed'}:
502             self.affinity\_matrix\_ = X
503         \textcolor{keywordflow}{else}:
504             params = self.kernel\_params
505             \textcolor{keywordflow}{if} params \textcolor{keywordflow}{is} \textcolor{keywordtype}{None}:
506                 params = \{\}
507             \textcolor{keywordflow}{if} \textcolor{keywordflow}{not} callable(self.affinity):
508                 params[\textcolor{stringliteral}{'gamma'}] = self.gamma
509                 params[\textcolor{stringliteral}{'degree'}] = self.degree
510                 params[\textcolor{stringliteral}{'coef0'}] = self.coef0
511             self.affinity\_matrix\_ = pairwise\_kernels(X, metric=self.affinity,
512                                                      filter\_params=\textcolor{keyword}{True},
513                                                      **params)
514 
515         random\_state = check\_random\_state(self.random\_state)
516         self.labels\_ = spectral\_clustering(self.affinity\_matrix\_,
517                                            n\_clusters=self.n\_clusters,
518                                            n\_components=self.n\_components,
519                                            eigen\_solver=self.eigen\_solver,
520                                            random\_state=random\_state,
521                                            n\_init=self.n\_init,
522                                            eigen\_tol=self.eigen\_tol,
523                                            assign\_labels=self.assign\_labels)
524         \textcolor{keywordflow}{return} self
525 
\end{DoxyCode}
\mbox{\Hypertarget{classdsmacc_1_1examples_1_1__spectral_1_1SpectralClustering_a2199033bd2458f93914ca1a1ad26ca23}\label{classdsmacc_1_1examples_1_1__spectral_1_1SpectralClustering_a2199033bd2458f93914ca1a1ad26ca23}} 
\index{dsmacc\+::examples\+::\+\_\+spectral\+::\+Spectral\+Clustering@{dsmacc\+::examples\+::\+\_\+spectral\+::\+Spectral\+Clustering}!fit\+\_\+predict@{fit\+\_\+predict}}
\index{fit\+\_\+predict@{fit\+\_\+predict}!dsmacc\+::examples\+::\+\_\+spectral\+::\+Spectral\+Clustering@{dsmacc\+::examples\+::\+\_\+spectral\+::\+Spectral\+Clustering}}
\subsubsection{\texorpdfstring{fit\+\_\+predict()}{fit\_predict()}}
{\footnotesize\ttfamily def dsmacc.\+examples.\+\_\+spectral.\+Spectral\+Clustering.\+fit\+\_\+predict (\begin{DoxyParamCaption}\item[{}]{self,  }\item[{}]{X,  }\item[{}]{y = {\ttfamily None} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Perform spectral clustering from features, or affinity matrix,
and return cluster labels.

Parameters
----------
X : array-like or sparse matrix, shape (n_samples, n_features), or \
    array-like, shape (n_samples, n_samples)
    Training instances to cluster, or similarities / affinities between
    instances if ``affinity='precomputed'``. If a sparse matrix is
    provided in a format other than ``csr_matrix``, ``csc_matrix``,
    or ``coo_matrix``, it will be converted into a sparse
    ``csr_matrix``.

y : Ignored
    Not used, present here for API consistency by convention.

Returns
-------
labels : ndarray, shape (n_samples,)
    Cluster labels.
\end{DoxyVerb}
 
\begin{DoxyCode}
526     \textcolor{keyword}{def }fit\_predict(self, X, y=None):
527         \textcolor{stringliteral}{"""Perform spectral clustering from features, or affinity matrix,}
528 \textcolor{stringliteral}{        and return cluster labels.}
529 \textcolor{stringliteral}{}
530 \textcolor{stringliteral}{        Parameters}
531 \textcolor{stringliteral}{        ----------}
532 \textcolor{stringliteral}{        X : array-like or sparse matrix, shape (n\_samples, n\_features), or \(\backslash\)}
533 \textcolor{stringliteral}{            array-like, shape (n\_samples, n\_samples)}
534 \textcolor{stringliteral}{            Training instances to cluster, or similarities / affinities between}
535 \textcolor{stringliteral}{            instances if ``affinity='precomputed'``. If a sparse matrix is}
536 \textcolor{stringliteral}{            provided in a format other than ``csr\_matrix``, ``csc\_matrix``,}
537 \textcolor{stringliteral}{            or ``coo\_matrix``, it will be converted into a sparse}
538 \textcolor{stringliteral}{            ``csr\_matrix``.}
539 \textcolor{stringliteral}{}
540 \textcolor{stringliteral}{        y : Ignored}
541 \textcolor{stringliteral}{            Not used, present here for API consistency by convention.}
542 \textcolor{stringliteral}{}
543 \textcolor{stringliteral}{        Returns}
544 \textcolor{stringliteral}{        -------}
545 \textcolor{stringliteral}{        labels : ndarray, shape (n\_samples,)}
546 \textcolor{stringliteral}{            Cluster labels.}
547 \textcolor{stringliteral}{        """}
548         \textcolor{keywordflow}{return} super().fit\_predict(X, y)
549 
\end{DoxyCode}


The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
dsmacc/examples/\+\_\+spectral.\+py\end{DoxyCompactItemize}
