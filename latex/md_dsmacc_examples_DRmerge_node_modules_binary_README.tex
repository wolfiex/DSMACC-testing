Unpack multibyte binary values from buffers and streams. You can specify the endianness and signedness of the fields to be unpacked too.

This module is a cleaner and more complete version of \href{https://github.com/substack/node-bufferlist}{\tt bufferlist}\textquotesingle{}s binary module that runs on pre-\/allocated buffers instead of a linked list.

\href{http://travis-ci.org/substack/node-binary}{\tt }

\section*{examples }

\subsection*{stream.\+js }


\begin{DoxyCode}
var binary = require('binary');

var ws = binary()
    .word32lu('x')
    .word16bs('y')
    .word16bu('z')
    .tap(function (vars) \{
        console.dir(vars);
    \})
;
process.stdin.pipe(ws);
process.stdin.resume();
\end{DoxyCode}


output\+:


\begin{DoxyCode}
$ node examples/stream.js
abcdefgh
\{ x: 1684234849, y: 25958, z: 26472 \}
^D
\end{DoxyCode}


\subsection*{parse.\+js }


\begin{DoxyCode}
var buf = new Buffer([ 97, 98, 99, 100, 101, 102, 0 ]);

var binary = require('binary');
var vars = binary.parse(buf)
    .word16ls('ab')
    .word32bu('cf')
    .word8('x')
    .vars
;
console.dir(vars);
\end{DoxyCode}


output\+:


\begin{DoxyCode}
\{ ab: 25185, cf: 1667523942, x: 0 \}
\end{DoxyCode}


\section*{methods }

`var binary = require(\textquotesingle{}binary')\`{}

\subsection*{var b = binary() }

Return a new writable stream {\ttfamily b} that has the chainable methods documented below for buffering binary input.

\subsection*{binary.\+parse(buf) }

Parse a static buffer in one pass. Returns a chainable interface with the methods below plus a {\ttfamily vars} field to get at the variable stash as the last item in a chain.

In parse mode, methods will set their keys to {\ttfamily null} if the buffer isn\textquotesingle{}t big enough except {\ttfamily buffer()} and {\ttfamily scan()} which read up up to the end of the buffer and stop.

\subsection*{b.\+word\{8,16,32,64\}\{l,b\}\{e,u,s\}(key) }

Parse bytes in the buffer or stream given\+:


\begin{DoxyItemize}
\item number of bits
\item endianness ( l \+: little, b \+: big ),
\item signedness ( u and e \+: unsigned, s \+: signed )
\end{DoxyItemize}

These functions won\textquotesingle{}t start parsing until all previous parser functions have run and the data is available.

The result of the parse goes into the variable stash at {\ttfamily key}. If {\ttfamily key} has dots ({\ttfamily .}s), it refers to a nested address. If parent container values don\textquotesingle{}t exist they will be created automatically, so for instance you can assign into {\ttfamily dst.\+addr} and {\ttfamily dst.\+port} and the {\ttfamily dst} key in the variable stash will be {\ttfamily \{ addr \+: x, port \+: y \}} afterwards.

\subsection*{b.\+buffer(key, size) }

Take {\ttfamily size} bytes directly off the buffer stream, putting the resulting buffer slice in the variable stash at {\ttfamily key}. If {\ttfamily size} is a string, use the value at {\ttfamily vars\mbox{[}size\mbox{]}}. The key follows the same dotted address rules as the word functions.

\subsection*{b.\+scan(key, buffer) }

Search for {\ttfamily buffer} in the stream and store all the intervening data in the stash at at {\ttfamily key}, excluding the search buffer. If {\ttfamily buffer} passed as a string, it will be converted into a Buffer internally.

For example, to read in a line you can just do\+:


\begin{DoxyCode}
var b = binary()
    .scan('line', new Buffer('\(\backslash\)r\(\backslash\)n'))
    .tap(function (vars) \{
        console.log(vars.line)
    \})
;
stream.pipe(b);
\end{DoxyCode}


\subsection*{b.\+tap(cb) }

The callback {\ttfamily cb} is provided with the variable stash from all the previous actions once they\textquotesingle{}ve all finished.

You can nest additional actions onto {\ttfamily this} inside the callback.

\subsection*{b.\+into(key, cb) }

Like {\ttfamily .tap()}, except all nested actions will assign into a {\ttfamily key} in the {\ttfamily vars} stash.

\subsection*{b.\+loop(cb) }

Loop, each time calling {\ttfamily cb(end, vars)} for function {\ttfamily end} and the variable stash with {\ttfamily this} set to a new chain for nested parsing. The loop terminates once {\ttfamily end} is called.

\subsection*{b.\+flush() }

Clear the variable stash entirely.

\section*{installation }

To install with \href{http://github.com/isaacs/npm}{\tt npm}\+:


\begin{DoxyCode}
npm install binary
\end{DoxyCode}


\section*{notes }

The word64 functions will only return approximations since javascript uses ieee floating point for all number types. Mind the loss of precision.

\section*{license }

M\+IT 