insert implicit module globals ({\ttfamily \+\_\+\+\_\+filename}, {\ttfamily \+\_\+\+\_\+dirname}, {\ttfamily process}, {\ttfamily global}, {\ttfamily set\+Immediate}, {\ttfamily clear\+Immediate} and {\ttfamily Buffer}) as a browserify-\/style transform

\href{http://travis-ci.org/browserify/insert-module-globals}{\tt }

\section*{example}


\begin{DoxyCode}
var mdeps = require('module-deps');
var bpack = require('browser-pack');
var insert = require('insert-module-globals');
function inserter (file) \{
    return insert(file, \{ basedir: \_\_dirname + '/files' \});
\}

var files = [ \_\_dirname + '/files/main.js' ];
mdeps(files, \{ transform: inserter \})
    .pipe(bpack(\{ raw: true \}))
    .pipe(process.stdout)
;
\end{DoxyCode}



\begin{DoxyCode}
$ node example/insert.js | node
in main.js: \{"\_\_filename":"/main.js","\_\_dirname":"/"\}
in foo/index.js: \{"\_\_filename":"/foo/index.js","\_\_dirname":"/foo"\}
\end{DoxyCode}


or use the command-\/line scripts\+:


\begin{DoxyCode}
$ module-deps main.js | insert-module-globals | browser-pack | node
in main.js: \{"\_\_filename":"/main.js","\_\_dirname":"/"\}
in foo/index.js: \{"\_\_filename":"/foo/index.js","\_\_dirname":"/foo"\}
\end{DoxyCode}


or use insert-\/module-\/globals as a transform\+:


\begin{DoxyCode}
$ module-deps main.js --transform insert-module-globals | browser-pack | node
in main.js: \{"\_\_filename":"/main.js","\_\_dirname":"/"\}
in foo/index.js: \{"\_\_filename":"/foo/index.js","\_\_dirname":"/foo"\}
\end{DoxyCode}


\section*{methods}


\begin{DoxyCode}
var insertGlobals = require('insert-module-globals')
\end{DoxyCode}


\subsection*{var inserter = insert\+Globals(file, opts)}

Return a transform stream {\ttfamily inserter} for the filename {\ttfamily file} that will accept a javascript file as input and will output the file with a closure around the contents as necessary to define extra builtins.

When {\ttfamily opts.\+always} is true, wrap every file with all the global variables without parsing. This is handy because parsing the scope can take a long time, so you can prioritize fast builds over saving bytes in the final output. When {\ttfamily opts.\+always} is truthy but not true, avoid parsing but perform a quick test to determine if wrapping should be skipped.

Use {\ttfamily opts.\+vars} to override the default inserted variables, or set {\ttfamily opts.\+vars\mbox{[}name\mbox{]}} to {\ttfamily undefined} to not insert a variable which would otherwise be inserted.

{\ttfamily opts.\+vars} properties with a {\ttfamily .} in their name will be executed instead of the parent object if O\+N\+LY that property is used. For example, {\ttfamily \char`\"{}\+Buffer.\+is\+Buffer\char`\"{}} will mask {\ttfamily \char`\"{}\+Buffer\char`\"{}} only when there is a {\ttfamily Buffer.\+is\+Buffer()} call in a file and no other references to {\ttfamily Buffer}.

If {\ttfamily opts.\+debug} is true, an inline source map will be generated to compensate for the extra lines.

\section*{events}

\subsection*{inserter.\+on(\textquotesingle{}global\textquotesingle{}, function (name) \{\})}

When a global is detected, the inserter stream emits a `\textquotesingle{}global'\`{} event.

\section*{usage}


\begin{DoxyCode}
usage: insert-module-globals \{basedir\}
\end{DoxyCode}


\section*{install}

With \href{https://npmjs.org}{\tt npm}, to get the library do\+:


\begin{DoxyCode}
npm install insert-module-globals
\end{DoxyCode}


and to get the bin script do\+:


\begin{DoxyCode}
npm install -g insert-module-globals
\end{DoxyCode}


\section*{insert custom globals.}

{\ttfamily insert-\/module-\/globals} can also insert arbitary globals into files. Pass in an object of functions as the {\ttfamily vars} option.


\begin{DoxyCode}
var vars = \{
    process: function (file, basedir) \{
        return \{
            id: "path/to/custom\_process.js",
            source: customProcessContent
        \}
    \},
    Buffer: function (file, basedir) \{
        return \{
            id: 'path/to/custom\_buffer.js',
            source: customProcessContent,
            //suffix is optional
            //it's used to extract the value from the module.
            //it becomes: require(...).Buffer in this case.
            suffix: '.Buffer'
        \}
    \},
    Math: function () \{
        //if you return a string,
        //it's simply set as the value.
        return '\{\}'
        //^ any attempt to use Math[x] will throw!
    \}
\}

function inserter (file) \{
    return insert(file, \{ vars: vars \});
\}
mdeps(files, \{ transform: inserter \})
    .pipe(bpack(\{ raw: true \}))
    .pipe(process.stdout)
\end{DoxyCode}


\section*{license}

M\+IT 