\begin{quote}
Fast, pluggable and easy-\/to-\/use parser-\/renderer factory. \end{quote}


\subsection*{Install}

Install with \href{https://www.npmjs.com/}{\tt npm}\+:


\begin{DoxyCode}
$ npm install --save snapdragon
\end{DoxyCode}


Created by \href{https://github.com/jonschlinkert}{\tt jonschlinkert} and \href{https://github.com/doowb}{\tt doowb}.

{\bfseries Features}


\begin{DoxyItemize}
\item Bootstrap your own parser, get sourcemap support for free
\item All parsing and compiling is handled by simple, reusable middleware functions
\item Inspired by the parsers in \href{http://jade-lang.com}{\tt pug} and \href{https://github.com/reworkcss/css}{\tt css}.
\end{DoxyItemize}

\subsection*{History}

\subsubsection*{v0.\+5.\+0}

{\bfseries Breaking changes}

Substantial breaking changes were made in v0.\+5.\+0! Most of these changes are part of a larger refactor that will be finished in 0.\+6.\+0, including the introduction of a {\ttfamily Lexer} class.


\begin{DoxyItemize}
\item Renderer was renamed to {\ttfamily Compiler}
\item the {\ttfamily .render} method was renamed to {\ttfamily .compile}
\item Many other smaller changes. A more detailed overview will be provided in 0.\+6.\+0. If you don\textquotesingle{}t have to time review code, I recommend you wait for the 0.\+6.\+0 release.
\end{DoxyItemize}

\subsection*{Usage examples}


\begin{DoxyCode}
var Snapdragon = require('snapdragon');
var snapdragon = new Snapdragon();
\end{DoxyCode}


{\bfseries Parse}


\begin{DoxyCode}
var ast = snapdragon.parser('some string', options)
  // parser middleware that can be called by other middleware
  .set('foo', function () \{\})
  // parser middleware, runs immediately in the order defined
  .use(bar())
  .use(baz())
\end{DoxyCode}


{\bfseries Render}


\begin{DoxyCode}
// pass the `ast` from the parse method
var res = snapdragon.compiler(ast)
  // compiler middleware, called when the name of the middleware
  // matches the `node.type` (defined in a parser middleware)
  .set('bar', function () \{\})
  .set('baz', function () \{\})
  .compile()
\end{DoxyCode}


See the \href{./examples/}{\tt examples}.

\subsection*{Getting started}

{\bfseries Parsers}

Parsers are middleware functions used for parsing a string into an ast node.


\begin{DoxyCode}
var ast = snapdragon.parser(str, options)
  .use(function() \{
    var pos = this.position();
    var m = this.match(/^\(\backslash\)./);
    if (!m) return;
    return pos(\{
      // `type` specifies the compiler to use
      type: 'dot',
      val: m[0]
    \});
  \})
\end{DoxyCode}


{\bfseries A\+ST node}

When the parser finds a match, {\ttfamily pos()} is called, pushing a token for that node onto the ast that looks something like\+:


\begin{DoxyCode}
\{ type: 'dot',
  val: '.',
  position:
   \{ start: \{ lineno: 1, column: 1 \},
     end: \{ lineno: 1, column: 2 \} \}\}
\end{DoxyCode}


{\bfseries Renderers}

Renderers are {\itshape named} middleware functions that visit over an array of ast nodes to compile a string.


\begin{DoxyCode}
var res = snapdragon.compiler(ast)
  .set('dot', function (node) \{
    console.log(node.val)
    //=> '.'
    return this.emit(node.val);
  \})
\end{DoxyCode}


{\bfseries Source maps}

If you want source map support, make sure to emit the position as well.


\begin{DoxyCode}
var res = snapdragon.compiler(ast)
  .set('dot', function (node) \{
    return this.emit(node.val, node.position);
  \})
\end{DoxyCode}


\subsection*{Docs}

\subsubsection*{Parser middleware}

A parser middleware is a function that returns an abject called a {\ttfamily token}. This token is pushed onto the A\+ST as a node.

{\bfseries Example token}


\begin{DoxyCode}
\{ type: 'dot',
  val: '.',
  position:
   \{ start: \{ lineno: 1, column: 1 \},
     end: \{ lineno: 1, column: 2 \} \}\}
\end{DoxyCode}


{\bfseries Example parser middleware}

Match a single {\ttfamily .} in a string\+:


\begin{DoxyEnumerate}
\item Get the starting position by calling {\ttfamily this.\+position()}
\item pass a regex for matching a single dot to the {\ttfamily .match} method
\item if {\bfseries no match} is found, return {\ttfamily undefined}
\item if a {\bfseries match} is found, {\ttfamily pos()} is called, which returns a token with\+:
\begin{DoxyItemize}
\item {\ttfamily type}\+: the name of the \mbox{[}compiler\mbox{]} to use
\item {\ttfamily val}\+: The actual value captured by the regex. In this case, a {\ttfamily .}. Note that you can capture and return whatever will be needed by the corresponding \mbox{[}compiler\mbox{]}.
\item The ending position\+: automatically calculated by adding the length of the first capture group to the starting position.
\end{DoxyItemize}
\end{DoxyEnumerate}

\subsection*{Renderer middleware}

Renderers are run when the name of the compiler middleware matches the {\ttfamily type} defined on an ast {\ttfamily node} (which is defined in a parser).

{\bfseries Example}

Exercise\+: Parse a dot, then compile it as an escaped dot.


\begin{DoxyCode}
var ast = snapdragon.parser('.')
  .use(function () \{
    var pos = this.position();
    var m = this.match(/^\(\backslash\)./);
    if (!m) return;
    return pos(\{
      // define the `type` of compiler to use
      type: 'dot',
      val: m[0]
    \})
  \})

var result = snapdragon.compiler(ast)
  .set('dot', function (node) \{
    return this.emit('\(\backslash\)\(\backslash\)' + node.val);
  \})
  .compile()

console.log(result.output);
//=> '\(\backslash\).'
\end{DoxyCode}


\subsection*{A\+PI}

\subsubsection*{\href{lib/parser.js#L19}{\tt Parser}}

Create a new {\ttfamily Parser} with the given {\ttfamily input} and {\ttfamily options}.

{\bfseries Params}


\begin{DoxyItemize}
\item {\ttfamily input} $\ast$$\ast$\{String\}$\ast$$\ast$
\item {\ttfamily options} $\ast$$\ast$\{Object\}$\ast$$\ast$
\end{DoxyItemize}

\subsubsection*{\href{lib/parser.js#L103}{\tt .define}}

Define a non-\/enumberable property on the {\ttfamily Parser} instance.

{\bfseries Example}


\begin{DoxyCode}
parser.define('foo', 'bar');
\end{DoxyCode}


{\bfseries Params}


\begin{DoxyItemize}
\item {\ttfamily key} $\ast$$\ast$\{String\}$\ast$$\ast$\+: propery name
\item {\ttfamily val} $\ast$$\ast$\{any\}$\ast$$\ast$\+: property value
\item {\ttfamily returns} $\ast$$\ast$\{Object\}$\ast$$\ast$\+: Returns the Parser instance for chaining.
\end{DoxyItemize}

Set parser {\ttfamily name} with the given {\ttfamily fn}

{\bfseries Params}


\begin{DoxyItemize}
\item {\ttfamily name} $\ast$$\ast$\{String\}$\ast$$\ast$
\item {\ttfamily fn} $\ast$$\ast$\{Function\}$\ast$$\ast$
\end{DoxyItemize}

Get parser {\ttfamily name}

{\bfseries Params}


\begin{DoxyItemize}
\item {\ttfamily name} $\ast$$\ast$\{String\}$\ast$$\ast$
\end{DoxyItemize}

Push a {\ttfamily token} onto the {\ttfamily type} stack.

{\bfseries Params}


\begin{DoxyItemize}
\item {\ttfamily type} $\ast$$\ast$\{String\}$\ast$$\ast$
\item {\ttfamily returns} $\ast$$\ast$\{Object\}$\ast$$\ast$ {\ttfamily token}
\end{DoxyItemize}

Pop a token off of the {\ttfamily type} stack

{\bfseries Params}


\begin{DoxyItemize}
\item {\ttfamily type} $\ast$$\ast$\{String\}$\ast$$\ast$
\item {\ttfamily returns} $\ast$$\ast$\{Object\}$\ast$$\ast$\+: Returns a token
\end{DoxyItemize}

Return true if inside a {\ttfamily stack} node. Types are {\ttfamily braces}, {\ttfamily parens} or {\ttfamily brackets}.

{\bfseries Params}


\begin{DoxyItemize}
\item {\ttfamily type} $\ast$$\ast$\{String\}$\ast$$\ast$
\item {\ttfamily returns} $\ast$$\ast$\{Boolean\}$\ast$$\ast$
\end{DoxyItemize}

{\bfseries Example}


\begin{DoxyCode}
parser.isType(node, 'brace');
\end{DoxyCode}


{\bfseries Params}


\begin{DoxyItemize}
\item {\ttfamily node} $\ast$$\ast$\{Object\}$\ast$$\ast$
\item {\ttfamily type} $\ast$$\ast$\{String\}$\ast$$\ast$
\item {\ttfamily returns} $\ast$$\ast$\{Boolean\}$\ast$$\ast$
\end{DoxyItemize}

\subsubsection*{\href{lib/compiler.js#L71}{\tt .define}}

Define a non-\/enumberable property on the {\ttfamily Compiler} instance.

{\bfseries Example}


\begin{DoxyCode}
compiler.define('foo', 'bar');
\end{DoxyCode}


{\bfseries Params}


\begin{DoxyItemize}
\item {\ttfamily key} $\ast$$\ast$\{String\}$\ast$$\ast$\+: propery name
\item {\ttfamily val} $\ast$$\ast$\{any\}$\ast$$\ast$\+: property value
\item {\ttfamily returns} $\ast$$\ast$\{Object\}$\ast$$\ast$\+: Returns the Compiler instance for chaining.
\end{DoxyItemize}

\subsection*{About}

\subsubsection*{Related projects}


\begin{DoxyItemize}
\item \href{https://www.npmjs.com/package/braces}{\tt braces}\+: Fastest brace expansion for node.\+js, with the most complete support for the Bash 4.\+3 braces… \href{https://github.com/jonschlinkert/braces}{\tt more} $\vert$ \href{https://github.com/jonschlinkert/braces}{\tt homepage}
\item \href{https://www.npmjs.com/package/expand-brackets}{\tt expand-\/brackets}\+: Expand P\+O\+S\+IX bracket expressions (character classes) in glob patterns. $\vert$ \mbox{[}homepage\mbox{]}(\href{https://github.com/jonschlinkert/expand-brackets}{\tt https\+://github.\+com/jonschlinkert/expand-\/brackets} \char`\"{}\+Expand P\+O\+S\+I\+X bracket expressions (character classes) in glob patterns.\char`\"{})
\item \href{https://www.npmjs.com/package/extglob}{\tt extglob}\+: Convert extended globs to regex-\/compatible strings. Add (almost) the expressive power of regular expressions to… \href{https://github.com/jonschlinkert/extglob}{\tt more} $\vert$ \mbox{[}homepage\mbox{]}(\href{https://github.com/jonschlinkert/extglob}{\tt https\+://github.\+com/jonschlinkert/extglob} \char`\"{}\+Convert extended globs to regex-\/compatible strings. Add (almost) the expressive power of regular expressions to glob patterns.\char`\"{})
\item \href{https://www.npmjs.com/package/micromatch}{\tt micromatch}\+: Glob matching for javascript/node.\+js. A drop-\/in replacement and faster alternative to minimatch and multimatch. $\vert$ \href{https://github.com/jonschlinkert/micromatch}{\tt homepage}
\end{DoxyItemize}

\subsubsection*{Contributing}

Pull requests and stars are always welcome. For bugs and feature requests, \href{../../issues/new}{\tt please create an issue}.

\subsubsection*{Contributors}

\tabulinesep=1mm
\begin{longtabu} spread 0pt [c]{*{2}{|X[-1]}|}
\hline
\rowcolor{\tableheadbgcolor}\multicolumn{2}{|p{(\linewidth-\tabcolsep*2-\arrayrulewidth*1)*2/2}|}{\cellcolor{\tableheadbgcolor}\textbf{ $\ast$$\ast$\+Commits$\ast$   }}\\\cline{1-2}
\endfirsthead
\hline
\endfoot
\hline
\rowcolor{\tableheadbgcolor}\multicolumn{2}{|p{(\linewidth-\tabcolsep*2-\arrayrulewidth*1)*2/2}|}{\cellcolor{\tableheadbgcolor}\textbf{ $\ast$$\ast$\+Commits$\ast$   }}\\\cline{1-2}
\endhead
106  &\href{https://github.com/jonschlinkert}{\tt jonschlinkert}   \\\cline{1-2}
2  &\href{https://github.com/doowb}{\tt doowb}   \\\cline{1-2}
\end{longtabu}


\subsubsection*{Building docs}

\+\_\+(This document was generated by \href{https://github.com/verbose/verb-generate-readme}{\tt verb-\/generate-\/readme} (a \href{https://github.com/verbose/verb}{\tt verb} generator), please don\textquotesingle{}t edit the readme directly. Any changes to the readme must be made in .verb.\+md \char`\"{}.\+verb.\+md\char`\"{}.)\+\_\+

To generate the readme and A\+PI documentation with \href{https://github.com/verbose/verb}{\tt verb}\+:


\begin{DoxyCode}
$ npm install -g verb verb-generate-readme && verb
\end{DoxyCode}


\subsubsection*{Running tests}

Install dev dependencies\+:


\begin{DoxyCode}
$ npm install -d && npm test
\end{DoxyCode}


\subsubsection*{Author}

{\bfseries Jon Schlinkert}


\begin{DoxyItemize}
\item \href{https://github.com/jonschlinkert}{\tt github/jonschlinkert}
\item \href{http://twitter.com/jonschlinkert}{\tt twitter/jonschlinkert}
\end{DoxyItemize}

\subsubsection*{License}

Copyright © 2016, \href{https://github.com/jonschlinkert}{\tt Jon Schlinkert}. Released under the \href{https://github.com/jonschlinkert/snapdragon/blob/master/LICENSE}{\tt M\+IT license}.





{\itshape This file was generated by \href{https://github.com/verbose/verb-generate-readme}{\tt verb-\/generate-\/readme}, v0.\+1.\+31, on October 10, 2016.} 