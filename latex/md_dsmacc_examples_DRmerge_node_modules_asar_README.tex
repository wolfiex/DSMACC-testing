\href{https://travis-ci.org/electron/asar}{\tt } \href{https://ci.appveyor.com/project/electron-bot/asar}{\tt } \href{https://david-dm.org/electron/asar}{\tt } \href{https://npmjs.org/package/asar}{\tt }

Asar is a simple extensive archive format, it works like {\ttfamily tar} that concatenates all files together without compression, while having random access support.

\subsection*{Features}


\begin{DoxyItemize}
\item Support random access
\item Use J\+S\+ON to store files\textquotesingle{} information
\item Very easy to write a parser
\end{DoxyItemize}

\subsection*{Command line utility}

\subsubsection*{Install}


\begin{DoxyCode}
$ npm install asar
\end{DoxyCode}


\subsubsection*{Usage}


\begin{DoxyCode}
$ asar --help

  Usage: asar [options] [command]

  Commands:

    pack|p <dir> <output>
       create asar archive

    list|l <archive>
       list files of asar archive

    extract-file|ef <archive> <filename>
       extract one file from archive

    extract|e <archive> <dest>
       extract archive


  Options:

    -h, --help     output usage information
    -V, --version  output the version number
\end{DoxyCode}


\paragraph*{Excluding multiple resources from being packed}

Given\+: 
\begin{DoxyCode}
    app
(a) ├── x1
(b) ├── x2
(c) ├── y3
(d) │   ├── x1
(e) │   └── z1
(f) │       └── x2
(g) └── z4
(h)     └── w1
\end{DoxyCode}


Exclude\+: a, b 
\begin{DoxyCode}
$ asar pack app app.asar --unpack-dir "\{x1,x2\}"
\end{DoxyCode}


Exclude\+: a, b, d, f 
\begin{DoxyCode}
$ asar pack app app.asar --unpack-dir "**/\{x1,x2\}"
\end{DoxyCode}


Exclude\+: a, b, d, f, h 
\begin{DoxyCode}
$ asar pack app app.asar --unpack-dir "\{**/x1,**/x2,z4/w1\}"
\end{DoxyCode}


\subsection*{Using programatically}

\subsubsection*{Example}


\begin{DoxyCode}
var asar = require('asar');

var src = 'some/path/';
var dest = 'name.asar';

asar.createPackage(src, dest, function() \{
  console.log('done.');
\})
\end{DoxyCode}


Please note that there is currently {\bfseries no} error handling provided!

\subsubsection*{Transform}

You can pass in a {\ttfamily transform} option, that is a function, which either returns nothing, or a {\ttfamily stream.\+Transform}. The latter will be used on files that will be in the {\ttfamily .asar} file to transform them (e.\+g. compress).


\begin{DoxyCode}
var asar = require('asar');

var src = 'some/path/';
var dest = 'name.asar';

function transform(filename) \{
  return new CustomTransformStream()
\}

asar.createPackageWithOptions(src, dest, \{ transform: transform \}, function() \{
  console.log('done.');
\})
\end{DoxyCode}


\subsection*{Using with grunt}

There is also an unofficial grunt plugin to generate asar archives at \href{https://github.com/bwin/grunt-asar}{\tt bwin/grunt-\/asar}.

\subsection*{Format}

Asar uses \href{https://chromium.googlesource.com/chromium/src/+/master/base/pickle.h}{\tt Pickle} to safely serialize binary value to file, there is also a \href{https://www.npmjs.org/package/chromium-pickle}{\tt node.\+js binding} of {\ttfamily Pickle} class.

The format of asar is very flat\+:


\begin{DoxyCode}
| UInt32: header\_size | String: header | Bytes: file1 | ... | Bytes: file42 |
\end{DoxyCode}


The {\ttfamily header\+\_\+size} and {\ttfamily header} are serialized with \href{https://chromium.googlesource.com/chromium/src/+/master/base/pickle.h}{\tt Pickle} class, and {\ttfamily header\+\_\+size}\textquotesingle{}s \href{https://chromium.googlesource.com/chromium/src/+/master/base/pickle.h}{\tt Pickle} object is 8 bytes.

The {\ttfamily header} is a J\+S\+ON string, and the {\ttfamily header\+\_\+size} is the size of {\ttfamily header}\textquotesingle{}s {\ttfamily Pickle} object.

Structure of {\ttfamily header} is something like this\+:


\begin{DoxyCode}
\{
   "files": \{
      "tmp": \{
         "files": \{\}
      \},
      "usr" : \{
         "files": \{
           "bin": \{
             "files": \{
               "ls": \{
                 "offset": "0",
                 "size": 100,
                 "executable": true
               \},
               "cd": \{
                 "offset": "100",
                 "size": 100,
                 "executable": true
               \}
             \}
           \}
         \}
      \},
      "etc": \{
         "files": \{
           "hosts": \{
             "offset": "200",
             "size": 32
           \}
         \}
      \}
   \}
\}
\end{DoxyCode}


{\ttfamily offset} and {\ttfamily size} records the information to read the file from archive, the {\ttfamily offset} starts from 0 so you have to manually add the size of {\ttfamily header\+\_\+size} and {\ttfamily header} to the {\ttfamily offset} to get the real offset of the file.

{\ttfamily offset} is a U\+I\+N\+T64 number represented in string, because there is no way to precisely represent U\+I\+N\+T64 in Java\+Script {\ttfamily Number}. {\ttfamily size} is a Java\+Script {\ttfamily Number} that is no larger than {\ttfamily Number.\+M\+A\+X\+\_\+\+S\+A\+F\+E\+\_\+\+I\+N\+T\+E\+G\+ER}, which has a value of {\ttfamily 9007199254740991} and is about 8\+PB in size. We didn\textquotesingle{}t store {\ttfamily size} in U\+I\+N\+T64 because file size in Node.\+js is represented as {\ttfamily Number} and it is not safe to convert {\ttfamily Number} to U\+I\+N\+T64. 