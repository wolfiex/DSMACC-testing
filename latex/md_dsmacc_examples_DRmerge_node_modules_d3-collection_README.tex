Handy data structures for elements keyed by string.

\subsection*{Installing}

If you use N\+PM, {\ttfamily npm install d3-\/collection}. Otherwise, download the \href{https://github.com/d3/d3-collection/releases/latest}{\tt latest release}. You can also load directly from \href{https://d3js.org}{\tt d3js.\+org}, either as a \href{https://d3js.org/d3-collection.v1.min.js}{\tt standalone library} or as part of \href{https://github.com/d3/d3}{\tt D3 4.\+0}. A\+MD, Common\+JS, and vanilla environments are supported. In vanilla, a {\ttfamily d3} global is exported\+:


\begin{DoxyCode}
<script src="https://d3js.org/d3-collection.v1.min.js"></script>
<script>

var map = d3.map()
    .set("foo", 1)
    .set("bar", 2);

</script>
\end{DoxyCode}


\href{https://tonicdev.com/npm/d3-collection}{\tt Try d3-\/collection in your browser.}

\subsection*{A\+PI Reference}


\begin{DoxyItemize}
\item \href{#objects}{\tt Objects}
\item \href{#maps}{\tt Maps}
\item \href{#sets}{\tt Sets}
\item \href{#nests}{\tt Nests}
\end{DoxyItemize}

\subsubsection*{Objects}

A common data type in Java\+Script is the {\itshape associative array}, or more simply the {\itshape object}, which has a set of named properties. The standard mechanism for iterating over the keys (or property names) in an associative array is the \href{https://developer.mozilla.org/en/JavaScript/Reference/Statements/for...in}{\tt for…in loop}. However, note that the iteration order is undefined. D3 provides several methods for converting associative arrays to standard arrays with numeric indexes.

A word of caution\+: it is tempting to use plain objects as maps, but this causes \href{http://www.devthought.com/2012/01/18/an-object-is-not-a-hash/}{\tt unexpected behavior} when built-\/in property names are used as keys, such as {\ttfamily object\mbox{[}\char`\"{}\+\_\+\+\_\+proto\+\_\+\+\_\+\char`\"{}\mbox{]} = 42} and {\ttfamily \char`\"{}has\+Own\+Property\char`\"{} in object}. If you cannot guarantee that map keys and set values will be safe, use \href{#maps}{\tt maps} and \href{#sets}{\tt sets} (or their E\+S6 equivalents) instead of plain objects.

\label{_keys}%
\# d3.{\bfseries keys}({\itshape object}) \href{https://github.com/d3/d3-collection/blob/master/src/keys.js}{\tt $<$$>$}

Returns an array containing the property names of the specified object (an associative array). The order of the returned array is undefined.

\label{_values}%
\# d3.{\bfseries values}({\itshape object}) \href{https://github.com/d3/d3-collection/blob/master/src/values.js}{\tt $<$$>$}

Returns an array containing the property values of the specified object (an associative array). The order of the returned array is undefined.

\label{_entries}%
\# d3.{\bfseries entries}({\itshape object}) \href{https://github.com/d3/d3-collection/blob/master/src/entries.js}{\tt $<$$>$}

Returns an array containing the property keys and values of the specified object (an associative array). Each entry is an object with a key and value attribute, such as {\ttfamily \{key\+: \char`\"{}foo\char`\"{}, value\+: 42\}}. The order of the returned array is undefined.


\begin{DoxyCode}
d3.entries(\{foo: 42, bar: true\}); // [\{key: "foo", value: 42\}, \{key: "bar", value: true\}]
\end{DoxyCode}


\subsubsection*{Maps}

Like \href{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map}{\tt E\+S6 Maps}, but with a few differences\+:


\begin{DoxyItemize}
\item Keys are coerced to strings.
\item \href{#map_each}{\tt map.\+each}, not \href{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/forEach}{\tt map.\+for\+Each}. (Also, no {\itshape this\+Arg}.)
\item \href{#map_remove}{\tt map.\+remove}, not \href{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/delete}{\tt map.\+delete}.
\item \href{#map_entries}{\tt map.\+entries} returns an array of \{key, value\} objects, not an iterator of \mbox{[}key, value\mbox{]}.
\item \href{#map_size}{\tt map.\+size} is a method, not a \href{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/size}{\tt property}; also, there’s \href{#map_empty}{\tt map.\+empty}.
\end{DoxyItemize}

\label{_map}%
\# d3.{\bfseries map}(\mbox{[}{\itshape object}\mbox{[}, {\itshape key}\mbox{]}\mbox{]}) \href{https://github.com/d3/d3-collection/blob/master/src/map.js}{\tt $<$$>$}

Constructs a new map. If {\itshape object} is specified, copies all enumerable properties from the specified object into this map. The specified object may also be an array or another map. An optional {\itshape key} function may be specified to compute the key for each value in the array. For example\+:


\begin{DoxyCode}
var map = d3.map([\{name: "foo"\}, \{name: "bar"\}], function(d) \{ return d.name; \});
map.get("foo"); // \{"name": "foo"\}
map.get("bar"); // \{"name": "bar"\}
map.get("baz"); // undefined
\end{DoxyCode}


See also \href{#nests}{\tt nests}.

\label{_map_has}%
\# {\itshape map}.{\bfseries has}({\itshape key}) \href{https://github.com/d3/d3-collection/blob/master/src/map.js#L7}{\tt $<$$>$}

Returns true if and only if this map has an entry for the specified {\itshape key} string. Note\+: the value may be {\ttfamily null} or {\ttfamily undefined}.

\label{_map_get}%
\# {\itshape map}.{\bfseries get}({\itshape key}) \href{https://github.com/d3/d3-collection/blob/master/src/map.js#L10}{\tt $<$$>$}

Returns the value for the specified {\itshape key} string. If the map does not have an entry for the specified {\itshape key}, returns {\ttfamily undefined}.

\label{_map_set}%
\# {\itshape map}.{\bfseries set}({\itshape key}, {\itshape value}) \href{https://github.com/d3/d3-collection/blob/master/src/map.js#L13}{\tt $<$$>$}

Sets the {\itshape value} for the specified {\itshape key} string. If the map previously had an entry for the same {\itshape key} string, the old entry is replaced with the new value. Returns the map, allowing chaining. For example\+:


\begin{DoxyCode}
var map = d3.map()
    .set("foo", 1)
    .set("bar", 2)
    .set("baz", 3);

map.get("foo"); // 1
\end{DoxyCode}


\label{_map_remove}%
\# {\itshape map}.{\bfseries remove}({\itshape key}) \href{https://github.com/d3/d3-collection/blob/master/src/map.js#L17}{\tt $<$$>$}

If the map has an entry for the specified {\itshape key} string, removes the entry and returns true. Otherwise, this method does nothing and returns false.

\label{_map_clear}%
\# {\itshape map}.{\bfseries clear}() \href{https://github.com/d3/d3-collection/blob/master/src/map.js#L21}{\tt $<$$>$}

Removes all entries from this map.

\label{_map_keys}%
\# {\itshape map}.{\bfseries keys}() \href{https://github.com/d3/d3-collection/blob/master/src/map.js#L24}{\tt $<$$>$}

Returns an array of string keys for every entry in this map. The order of the returned keys is arbitrary.

\label{_map_values}%
\# {\itshape map}.{\bfseries values}() \href{https://github.com/d3/d3-collection/blob/master/src/map.js#L29}{\tt $<$$>$}

Returns an array of values for every entry in this map. The order of the returned values is arbitrary.

\label{_map_entries}%
\# {\itshape map}.{\bfseries entries}() \href{https://github.com/d3/d3-collection/blob/master/src/map.js#L34}{\tt $<$$>$}

Returns an array of key-\/value objects for each entry in this map. The order of the returned entries is arbitrary. Each entry’s key is a string, but the value has arbitrary type.

\label{_map_each}%
\# {\itshape map}.{\bfseries each}({\itshape function}) \href{https://github.com/d3/d3-collection/blob/master/src/map.js#L48}{\tt $<$$>$}

Calls the specified {\itshape function} for each entry in this map, passing the entry’s value and key as arguments, followed by the map itself. Returns undefined. The iteration order is arbitrary.

\label{_map_empty}%
\# {\itshape map}.{\bfseries empty}() \href{https://github.com/d3/d3-collection/blob/master/src/map.js#L44}{\tt $<$$>$}

Returns true if and only if this map has zero entries.

\label{_map_size}%
\# {\itshape map}.{\bfseries size}() \href{https://github.com/d3/d3-collection/blob/master/src/map.js#L39}{\tt $<$$>$}

Returns the number of entries in this map.

\subsubsection*{Sets}

Like \href{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set}{\tt E\+S6 Sets}, but with a few differences\+:


\begin{DoxyItemize}
\item Values are coerced to strings.
\item \href{#set_each}{\tt set.\+each}, not \href{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set/forEach}{\tt set.\+for\+Each}. (Also, no {\itshape this\+Arg}.)
\item \href{#set_remove}{\tt set.\+remove}, not \href{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set/delete}{\tt set.\+delete}.
\item \href{#set_size}{\tt set.\+size} is a method, not a \href{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set/size}{\tt property}; also, there’s \href{#set_empty}{\tt set.\+empty}.
\end{DoxyItemize}

\label{_set}%
\# d3.{\bfseries set}(\mbox{[}{\itshape array}\mbox{[}, {\itshape accessor}\mbox{]}\mbox{]}) \href{https://github.com/d3/d3-collection/blob/master/src/set.js}{\tt $<$$>$}

Constructs a new set. If {\itshape array} is specified, adds the given {\itshape array} of string values to the returned set. The specified array may also be another set. An optional {\itshape accessor} function may be specified, which is equivalent to calling {\itshape array.\+map(accessor)} before constructing the set.

\label{_set_has}%
\# {\itshape set}.{\bfseries has}({\itshape value}) \href{https://github.com/d3/d3-collection/blob/master/src/set.js#L9}{\tt $<$$>$}

Returns true if and only if this set has an entry for the specified {\itshape value} string.

\label{_set_add}%
\# {\itshape set}.{\bfseries add}({\itshape value}) \href{https://github.com/d3/d3-collection/blob/master/src/set.js#L10}{\tt $<$$>$}

Adds the specified {\itshape value} string to this set. Returns the set, allowing chaining. For example\+:


\begin{DoxyCode}
var set = d3.set()
    .add("foo")
    .add("bar")
    .add("baz");

set.has("foo"); // true
\end{DoxyCode}


\label{_set_remove}%
\# {\itshape set}.{\bfseries remove}({\itshape value}) \href{https://github.com/d3/d3-collection/blob/master/src/set.js#L15}{\tt $<$$>$}

If the set contains the specified {\itshape value} string, removes it and returns true. Otherwise, this method does nothing and returns false.

\label{_set_clear}%
\# {\itshape set}.{\bfseries clear}() \href{https://github.com/d3/d3-collection/blob/master/src/set.js#L16}{\tt $<$$>$}

Removes all values from this set.

\label{_set_values}%
\# {\itshape set}.{\bfseries values}() \href{https://github.com/d3/d3-collection/blob/master/src/set.js#L17}{\tt $<$$>$}

Returns an array of the string values in this set. The order of the returned values is arbitrary. Can be used as a convenient way of computing the unique values for a set of strings. For example\+:


\begin{DoxyCode}
d3.set(["foo", "bar", "foo", "baz"]).values(); // "foo", "bar", "baz"
\end{DoxyCode}


\label{_set_each}%
\# {\itshape set}.{\bfseries each}({\itshape function}) \href{https://github.com/d3/d3-collection/blob/master/src/set.js#L20}{\tt $<$$>$}

Calls the specified {\itshape function} for each value in this set, passing the value as the first two arguments (for symmetry with \href{#map_each}{\tt {\itshape map}.each}), followed by the set itself. Returns undefined. The iteration order is arbitrary.

\label{_set_empty}%
\# {\itshape set}.{\bfseries empty}() \href{https://github.com/d3/d3-collection/blob/master/src/set.js#L19}{\tt $<$$>$}

Returns true if and only if this set has zero values.

\label{_set_size}%
\# {\itshape set}.{\bfseries size}() \href{https://github.com/d3/d3-collection/blob/master/src/set.js#L18}{\tt $<$$>$}

Returns the number of values in this set.

\subsubsection*{Nests}

Nesting allows elements in an array to be grouped into a hierarchical tree structure; think of it like the G\+R\+O\+UP BY operator in S\+QL, except you can have multiple levels of grouping, and the resulting output is a tree rather than a flat table. The levels in the tree are specified by key functions. The leaf nodes of the tree can be sorted by value, while the internal nodes can be sorted by key. An optional rollup function will collapse the elements in each leaf node using a summary function. The nest operator (the object returned by \href{#nest}{\tt nest}) is reusable, and does not retain any references to the data that is nested.

For example, consider the following tabular data structure of Barley yields, from various sites in Minnesota during 1931-\/2\+:


\begin{DoxyCode}
var yields = [
  \{yield: 27.00, variety: "Manchuria", year: 1931, site: "University Farm"\},
  \{yield: 48.87, variety: "Manchuria", year: 1931, site: "Waseca"\},
  \{yield: 27.43, variety: "Manchuria", year: 1931, site: "Morris"\},
  ...
];
\end{DoxyCode}


To facilitate visualization, it may be useful to nest the elements first by year, and then by variety, as follows\+:


\begin{DoxyCode}
var entries = d3.nest()
    .key(function(d) \{ return d.year; \})
    .key(function(d) \{ return d.variety; \})
    .entries(yields);
\end{DoxyCode}


This returns a nested array. Each element of the outer array is a key-\/values pair, listing the values for each distinct key\+:


\begin{DoxyCode}
[\{key: "1931", values: [
   \{key: "Manchuria", values: [
     \{yield: 27.00, variety: "Manchuria", year: 1931, site: "University Farm"\},
     \{yield: 48.87, variety: "Manchuria", year: 1931, site: "Waseca"\},
     \{yield: 27.43, variety: "Manchuria", year: 1931, site: "Morris"\}, ...]\},
   \{key: "Glabron", values: [
     \{yield: 43.07, variety: "Glabron", year: 1931, site: "University Farm"\},
     \{yield: 55.20, variety: "Glabron", year: 1931, site: "Waseca"\}, ...]\}, ...]\},
 \{key: "1932", values: ...\}]
\end{DoxyCode}


The nested form allows easy iteration and generation of hierarchical structures in S\+VG or H\+T\+ML.

For a longer introduction to nesting, see\+:


\begin{DoxyItemize}
\item Phoebe Bright’s \href{http://bl.ocks.org/phoebebright/raw/3176159/}{\tt D3 Nest Tutorial and examples}
\item Shan Carter’s \href{http://bl.ocks.org/shancarter/raw/4748131/}{\tt Mister Nester}
\end{DoxyItemize}

\label{_nest}%
\# d3.{\bfseries nest}() \href{https://github.com/d3/d3-collection/blob/master/src/nest.js}{\tt $<$$>$}

Creates a new nest operator. The set of keys is initially empty.

\label{_nest_key}%
\# {\itshape nest}.{\bfseries key}({\itshape key}) \href{https://github.com/d3/d3-collection/blob/master/src/nest.js#L4}{\tt $<$$>$}

Registers a new {\itshape key} function. The {\itshape key} function will be invoked for each element in the input array and must return a string identifier to assign the element to its group. Most often, the function is a simple accessor, such as the year and variety accessors above. (Keys functions are {\itshape not} passed the input array index.) Each time a key is registered, it is pushed onto the end of the internal array of keys, and the nest operator applies an additional level of nesting.

\label{_nest_sortKeys}%
\# {\itshape nest}.{\bfseries sort\+Keys}({\itshape comparator}) \href{https://github.com/d3/d3-collection/blob/master/src/nest.js#L5}{\tt $<$$>$}

Sorts key values for the \href{#nest_key}{\tt current key} using the specified {\itshape comparator} function, such as \href{https://github.com/d3/d3-array#ascending}{\tt d3.\+ascending} or \href{https://github.com/d3/d3-array#descending}{\tt d3.\+descending}. If no comparator is specified for the current key, the order in which keys will be returned is undefined. For example, to sort years in ascending order and varieties in descending order\+:


\begin{DoxyCode}
var entries = d3.nest()
    .key(function(d) \{ return d.year; \}).sortKeys(d3.ascending)
    .key(function(d) \{ return d.variety; \}).sortKeys(d3.descending)
    .entries(yields);
\end{DoxyCode}


Note that this only affects the result of \href{#nest_entries}{\tt {\itshape nest}.entries}; the order of keys returned by \href{#nest_map}{\tt {\itshape nest}.map} and \href{#nest_object}{\tt {\itshape nest}.object} is always undefined, regardless of comparator.

\label{_nest_sortValues}%
\# {\itshape nest}.{\bfseries sort\+Values}({\itshape comparator}) \href{https://github.com/d3/d3-collection/blob/master/src/nest.js#L6}{\tt $<$$>$}

Sorts leaf elements using the specified {\itshape comparator} function, such as \href{https://github.com/d3/d3-array#ascending}{\tt d3.\+ascending} or \href{https://github.com/d3/d3-array#descending}{\tt d3.\+descending}. This is roughly equivalent to sorting the input array before applying the nest operator; however it is typically more efficient as the size of each group is smaller. If no value comparator is specified, elements will be returned in the order they appeared in the input array. This applies to \href{#nest_map}{\tt {\itshape nest}.map}, \href{#nest_entries}{\tt {\itshape nest}.entries} and \href{#nest_object}{\tt {\itshape nest}.object}.

\label{_nest_rollup}%
\# {\itshape nest}.{\bfseries rollup}({\itshape function}) \href{https://github.com/d3/d3-collection/blob/master/src/nest.js#L7}{\tt $<$$>$}

Specifies a rollup {\itshape function} to be applied on each group of leaf elements. The return value of the rollup function will replace the array of leaf values in either the associative array returned by \href{#nest_map}{\tt {\itshape nest}.map} or \href{#nest_object}{\tt {\itshape nest}.object}; for \href{#nest_entries}{\tt {\itshape nest}.entries}, it replaces the leaf {\itshape entry}.values with {\itshape entry}.value. If a \href{#nest_sortValues}{\tt leaf comparator} is specified, the leaf elements are sorted prior to invoking the rollup function.

\label{_nest_map}%
\# {\itshape nest}.{\bfseries map}({\itshape array}) \href{https://github.com/d3/d3-collection/blob/master/src/nest.js#L50}{\tt $<$$>$}

Applies the nest operator to the specified {\itshape array}, returning a nested \href{#map}{\tt map}. Each entry in the returned map corresponds to a distinct key value returned by the first key function. The entry value depends on the number of registered key functions\+: if there is an additional key, the value is another map; otherwise, the value is the array of elements filtered from the input {\itshape array} that have the given key value. If no keys are defined, returns the input {\itshape array}.

\label{_nest_object}%
\# {\itshape nest}.{\bfseries object}({\itshape array}) \href{https://github.com/d3/d3-collection/blob/master/src/nest.js#L49}{\tt $<$$>$}

Applies the nest operator to the specified {\itshape array}, returning a nested object. Each entry in the returned associative array corresponds to a distinct key value returned by the first key function. The entry value depends on the number of registered key functions\+: if there is an additional key, the value is another associative array; otherwise, the value is the array of elements filtered from the input {\itshape array} that have the given key value.

Note\+: this method is unsafe if any of the keys conflict with built-\/in Java\+Script properties, such as {\ttfamily \+\_\+\+\_\+proto\+\_\+\+\_\+}. If you cannot guarantee that the keys will be safe, you should use \href{#nest_map}{\tt nest.\+map} instead.

\label{_nest_entries}%
\# {\itshape nest}.{\bfseries entries}({\itshape array}) \href{https://github.com/d3/d3-collection/blob/master/src/nest.js#L51}{\tt $<$$>$}

Applies the nest operator to the specified {\itshape array}, returning an array of key-\/values entries. Conceptually, this is similar to applying \href{#map_entries}{\tt {\itshape map}.entries} to the associative array returned by \href{#nest_map}{\tt {\itshape nest}.map}, but it applies to every level of the hierarchy rather than just the first (outermost) level. Each entry in the returned array corresponds to a distinct key value returned by the first key function. The entry value depends on the number of registered key functions\+: if there is an additional key, the value is another nested array of entries; otherwise, the value is the array of elements filtered from the input {\itshape array} that have the given key value. 