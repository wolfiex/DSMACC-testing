\href{https://travis-ci.org/anodynos/upath}{\tt } \href{https://david-dm.org/anodynos/upath}{\tt }

A drop-\/in replacement / proxy to nodejs\textquotesingle{}s {\ttfamily path} that\+:


\begin{DoxyItemize}
\item Replaces the windows {\ttfamily \textbackslash{}} with the unix {\ttfamily /} in all string params \& results. This has significant positives -\/ see below.
\item Adds {\bfseries filename extensions} functions {\ttfamily add\+Ext}, {\ttfamily trim\+Ext}, {\ttfamily remove\+Ext}, {\ttfamily change\+Ext}, and {\ttfamily default\+Ext}.
\item Add a {\ttfamily normalize\+Safe} function to preserve any meaningful leading {\ttfamily ./} \& a {\ttfamily normalize\+Trim} which additionally trims any useless ending {\ttfamily /}.
\item Plus a helper {\ttfamily to\+Unix} that simply converts {\ttfamily \textbackslash{}} to {\ttfamily /} and consolidates duplicates.
\end{DoxyItemize}

{\bfseries Useful note\+: these docs are actually auto generated from \href{https://github.com/anodynos/upath/blob/master/source/spec/upath-spec.coffee}{\tt specs}, running on Linux.}

Notes\+:


\begin{DoxyItemize}
\item {\ttfamily upath.\+sep} is set to `'/\textquotesingle{}\`{} for seamless replacement (as of 1.\+0.\+3).
\item upath has no runtime dependencies, except built-\/in {\ttfamily path} (as of 1.\+0.\+4)
\item travis-\/ci tested in node versions 4 to 10 ~\newline
 \subsection*{Why ?}
\end{DoxyItemize}

Normal {\ttfamily path} doesn\textquotesingle{}t convert paths to a unified format (ie {\ttfamily /}) before calculating paths ({\ttfamily normalize}, {\ttfamily join}), which can lead to numerous problems. Also path joining, normalization etc on the two formats is not consistent, depending on where it runs. Running {\ttfamily path} on Windows yields different results than when it runs on Linux / Mac.

In general, if you code your paths logic while developing on Unix/\+Mac and it runs on Windows, you may run into problems when using {\ttfamily path}.

Note that using {\bfseries Unix {\ttfamily /} on Windows} works perfectly inside nodejs (and other languages), so there\textquotesingle{}s no reason to stick to the Windows legacy at all.

\subparagraph*{Examples / specs}

Check out the different (improved) behavior to vanilla {\ttfamily path}\+: \begin{DoxyVerb}`upath.normalize(path)`        --returns-->

      ✓ `'c:/windows/nodejs/path'`           --->      `'c:/windows/nodejs/path'`  // equal to `path.normalize()`
      ✓ `'c:/windows/../nodejs/path'`        --->              `'c:/nodejs/path'`  // equal to `path.normalize()`
      ✓ `'c:\\windows\\nodejs\\path'`        --->      `'c:/windows/nodejs/path'`  // `path.normalize()` gives `'c:\windows\nodejs\path'`
      ✓ `'c:\\windows\\..\\nodejs\\path'`    --->              `'c:/nodejs/path'`  // `path.normalize()` gives `'c:\windows\..\nodejs\path'`
      ✓ `'//windows\\unix/mixed'`            --->         `'/windows/unix/mixed'`  // `path.normalize()` gives `'/windows\unix/mixed'`
      ✓ `'\\windows//unix/mixed'`            --->         `'/windows/unix/mixed'`  // `path.normalize()` gives `'\windows/unix/mixed'`
      ✓ `'////\\windows\\..\\unix/mixed/'`   --->                `'/unix/mixed/'`  // `path.normalize()` gives `'/\windows\..\unix/mixed/'`
\end{DoxyVerb}


Joining paths can also be a problem\+: \begin{DoxyVerb}`upath.join(paths...)`        --returns-->

      ✓ `'some/nodejs/deep', '../path'`       --->       `'some/nodejs/path'`  // equal to `path.join()`
      ✓ `'some/nodejs\\windows', '../path'`   --->       `'some/nodejs/path'`  // `path.join()` gives `'some/path'`
      ✓ `'some\\windows\\only', '..\\path'`   --->      `'some/windows/path'`  // `path.join()` gives `'some\windows\only/..\path'`
\end{DoxyVerb}


Parsing with {\ttfamily path.\+parse()} should also be consistent across O\+Ses\+:

{\ttfamily upath.\+parse(path)} --returns--$>$ \begin{DoxyVerb}    ✓ `'c:\Windows\Directory\somefile.ext'`      ---> `{ root: '', dir: 'c:/Windows/Directory', base: 'somefile.ext', ext: '.ext', name: 'somefile' }`
                              // `path.parse()` gives `'{ root: '', dir: '', base: 'c:\\Windows\\Directory\\somefile.ext', ext: '.ext', name: 'c:\\Windows\\Directory\\somefile' }'`
    ✓ `'/root/of/unix/somefile.ext'`             ---> `{ root: '/', dir: '/root/of/unix', base: 'somefile.ext', ext: '.ext', name: 'somefile' }`  // equal to `path.parse()`
\end{DoxyVerb}


\subsection*{Added functions}

\paragraph*{{\ttfamily upath.\+to\+Unix(path)}}

Just converts all \`{}{\ttfamily to}/\`{} and consolidates duplicates, without performing any normalization.

\subparagraph*{Examples / specs}

\begin{DoxyVerb}`upath.toUnix(path)`        --returns-->

    ✓ `'.//windows\//unix//mixed////'`      --->         `'./windows/unix/mixed/'`
    ✓ `'..///windows\..\\unix/mixed'`       --->      `'../windows/../unix/mixed'`
\end{DoxyVerb}


\paragraph*{{\ttfamily upath.\+normalize\+Safe(path)}}

Exactly like {\ttfamily path.\+normalize(path)}, but it keeps the first meaningful {\ttfamily ./}.

Note that the unix {\ttfamily /} is returned everywhere, so windows {\ttfamily \textbackslash{}} is always converted to unix {\ttfamily /}.

\subparagraph*{Examples / specs \& how it differs from vanilla {\ttfamily path}}

\begin{DoxyVerb}`upath.normalizeSafe(path)`        --returns-->

    ✓ `''`                               --->                          `'.'`  // equal to `path.normalize()`
    ✓ `'.'`                              --->                          `'.'`  // equal to `path.normalize()`
    ✓ `'./'`                             --->                         `'./'`  // equal to `path.normalize()`
    ✓ `'.//'`                            --->                         `'./'`  // equal to `path.normalize()`
    ✓ `'.\\'`                            --->                         `'./'`  // `path.normalize()` gives `'.\'`
    ✓ `'.\\//'`                          --->                         `'./'`  // `path.normalize()` gives `'.\/'`
    ✓ `'./..'`                           --->                         `'..'`  // equal to `path.normalize()`
    ✓ `'.//..'`                          --->                         `'..'`  // equal to `path.normalize()`
    ✓ `'./../'`                          --->                        `'../'`  // equal to `path.normalize()`
    ✓ `'.\\..\\'`                        --->                        `'../'`  // `path.normalize()` gives `'.\..\'`
    ✓ `'./../dep'`                       --->                     `'../dep'`  // equal to `path.normalize()`
    ✓ `'../dep'`                         --->                     `'../dep'`  // equal to `path.normalize()`
    ✓ `'../path/dep'`                    --->                `'../path/dep'`  // equal to `path.normalize()`
    ✓ `'../path/../dep'`                 --->                     `'../dep'`  // equal to `path.normalize()`
    ✓ `'dep'`                            --->                        `'dep'`  // equal to `path.normalize()`
    ✓ `'path//dep'`                      --->                   `'path/dep'`  // equal to `path.normalize()`
    ✓ `'./dep'`                          --->                      `'./dep'`  // `path.normalize()` gives `'dep'`
    ✓ `'./path/dep'`                     --->                 `'./path/dep'`  // `path.normalize()` gives `'path/dep'`
    ✓ `'./path/../dep'`                  --->                      `'./dep'`  // `path.normalize()` gives `'dep'`
    ✓ `'.//windows\\unix/mixed/'`        --->      `'./windows/unix/mixed/'`  // `path.normalize()` gives `'windows\unix/mixed/'`
    ✓ `'..//windows\\unix/mixed'`        --->      `'../windows/unix/mixed'`  // `path.normalize()` gives `'../windows\unix/mixed'`
    ✓ `'windows\\unix/mixed/'`           --->        `'windows/unix/mixed/'`  // `path.normalize()` gives `'windows\unix/mixed/'`
    ✓ `'..//windows\\..\\unix/mixed'`    --->              `'../unix/mixed'`  // `path.normalize()` gives `'../windows\..\unix/mixed'`
\end{DoxyVerb}


\paragraph*{{\ttfamily upath.\+normalize\+Trim(path)}}

Exactly like {\ttfamily path.\+normalize\+Safe(path)}, but it trims any useless ending {\ttfamily /}.

\subparagraph*{Examples / specs}

\begin{DoxyVerb}`upath.normalizeTrim(path)`        --returns-->

    ✓ `'./'`                          --->                         `'.'`  // `upath.normalizeSafe()` gives `'./'`
    ✓ `'./../'`                       --->                        `'..'`  // `upath.normalizeSafe()` gives `'../'`
    ✓ `'./../dep/'`                   --->                    `'../dep'`  // `upath.normalizeSafe()` gives `'../dep/'`
    ✓ `'path//dep\\'`                 --->                  `'path/dep'`  // `upath.normalizeSafe()` gives `'path/dep/'`
    ✓ `'.//windows\\unix/mixed/'`     --->      `'./windows/unix/mixed'`  // `upath.normalizeSafe()` gives `'./windows/unix/mixed/'`
\end{DoxyVerb}


\paragraph*{{\ttfamily upath.\+join\+Safe(\mbox{[}path1\mbox{]}\mbox{[}, path2\mbox{]}\mbox{[}, ...\mbox{]})}}

Exactly like {\ttfamily path.\+join()}, but it keeps the first meaningful {\ttfamily ./}.

Note that the unix {\ttfamily /} is returned everywhere, so windows {\ttfamily \textbackslash{}} is always converted to unix {\ttfamily /}.

\subparagraph*{Examples / specs \& how it differs from vanilla {\ttfamily path}}

\begin{DoxyVerb}`upath.joinSafe(path)`        --returns-->

    ✓ `'some/nodejs/deep', '../path'`                --->           `'some/nodejs/path'`  // equal to `path.join()`
    ✓ `'./some/local/unix/', '../path'`              --->          `'./some/local/path'`  // `path.join()` gives `'some/local/path'`
    ✓ `'./some\\current\\mixed', '..\\path'`         --->        `'./some/current/path'`  // `path.join()` gives `'some\current\mixed/..\path'`
    ✓ `'../some/relative/destination', '..\\path'`   --->      `'../some/relative/path'`  // `path.join()` gives `'../some/relative/destination/..\path'`
\end{DoxyVerb}


\subsection*{Added functions for {\itshape filename extension} manipulation.}

{\bfseries Happy notes\+:}

In all functions you can\+:


\begin{DoxyItemize}
\item use both {\ttfamily .ext} \& {\ttfamily ext} -\/ the dot {\ttfamily .} on the extension is always adjusted correctly.
\item omit the {\ttfamily ext} param (pass null/undefined/empty string) and the common sense thing will happen.
\item ignore specific extensions from being considered as valid ones (eg {\ttfamily .min}, {\ttfamily .dev} {\ttfamily .a\+Long\+Ext\+Is\+Not\+An\+Ext} etc), hence no trimming or replacement takes place on them.
\end{DoxyItemize}

\paragraph*{{\ttfamily upath.\+add\+Ext(filename, \mbox{[}ext\mbox{]})}}

Adds {\ttfamily .ext} to {\ttfamily filename}, but only if it doesn\textquotesingle{}t already have the exact extension.

\subparagraph*{Examples / specs}

\begin{DoxyVerb}`upath.addExt(filename, 'js')`     --returns-->

    ✓ `'myfile/addExt'`           --->           `'myfile/addExt.js'`
    ✓ `'myfile/addExt.txt'`       --->       `'myfile/addExt.txt.js'`
    ✓ `'myfile/addExt.js'`        --->           `'myfile/addExt.js'`
    ✓ `'myfile/addExt.min.'`      --->      `'myfile/addExt.min..js'`
\end{DoxyVerb}


It adds nothing if no {\ttfamily ext} param is passed. \begin{DoxyVerb}`upath.addExt(filename)`           --returns-->

      ✓ `'myfile/addExt'`           --->              `'myfile/addExt'`
      ✓ `'myfile/addExt.txt'`       --->          `'myfile/addExt.txt'`
      ✓ `'myfile/addExt.js'`        --->           `'myfile/addExt.js'`
      ✓ `'myfile/addExt.min.'`      --->         `'myfile/addExt.min.'`
\end{DoxyVerb}


\paragraph*{{\ttfamily upath.\+trim\+Ext(filename, \mbox{[}ignore\+Exts\mbox{]}, \mbox{[}max\+Size=7\mbox{]})}}

Trims a filename\textquotesingle{}s extension.


\begin{DoxyItemize}
\item Extensions are considered to be up to {\ttfamily max\+Size} chars long, counting the dot (defaults to 7).
\item An {\ttfamily Array} of {\ttfamily ignore\+Exts} (eg `\mbox{[}'.min\textquotesingle{}\mbox{]}\`{}) prevents these from being considered as extension, thus are not trimmed.
\end{DoxyItemize}

\subparagraph*{Examples / specs}

\begin{DoxyVerb}`upath.trimExt(filename)`          --returns-->

    ✓ `'my/trimedExt.txt'`             --->                 `'my/trimedExt'`
    ✓ `'my/trimedExt'`                 --->                 `'my/trimedExt'`
    ✓ `'my/trimedExt.min'`             --->                 `'my/trimedExt'`
    ✓ `'my/trimedExt.min.js'`          --->             `'my/trimedExt.min'`
    ✓ `'../my/trimedExt.longExt'`      --->      `'../my/trimedExt.longExt'`
\end{DoxyVerb}


It is ignoring {\ttfamily .min} \& {\ttfamily .dev} as extensions, and considers exts with up to 8 chars. \begin{DoxyVerb}`upath.removeExt(filename, ['min', '.dev'], 8)`          --returns-->

      ✓ `'my/trimedExt.txt'`              --->                  `'my/trimedExt'`
      ✓ `'my/trimedExt.min'`              --->              `'my/trimedExt.min'`
      ✓ `'my/trimedExt.dev'`              --->              `'my/trimedExt.dev'`
      ✓ `'../my/trimedExt.longExt'`       --->               `'../my/trimedExt'`
      ✓ `'../my/trimedExt.longRExt'`      --->      `'../my/trimedExt.longRExt'`
\end{DoxyVerb}


\paragraph*{{\ttfamily upath.\+remove\+Ext(filename, ext)}}

Removes the specific {\ttfamily ext} extension from filename, if it has it. Otherwise it leaves it as is. As in all upath functions, it be {\ttfamily .ext} or {\ttfamily ext}.

\subparagraph*{Examples / specs}

\begin{DoxyVerb}`upath.removeExt(filename, '.js')`          --returns-->

    ✓ `'removedExt.js'`          --->          `'removedExt'`
    ✓ `'removedExt.txt.js'`      --->      `'removedExt.txt'`
    ✓ `'notRemoved.txt'`         --->      `'notRemoved.txt'`
\end{DoxyVerb}


\paragraph*{{\ttfamily upath.\+change\+Ext(filename, \mbox{[}ext\mbox{]}, \mbox{[}ignore\+Exts\mbox{]}, \mbox{[}max\+Size=7\mbox{]})}}

Changes a filename\textquotesingle{}s extension to {\ttfamily ext}. If it has no (valid) extension, it adds it.


\begin{DoxyItemize}
\item Valid extensions are considered to be up to {\ttfamily max\+Size} chars long, counting the dot (defaults to 7).
\item An {\ttfamily Array} of {\ttfamily ignore\+Exts} (eg `\mbox{[}'.min\textquotesingle{}\mbox{]}\`{}) prevents these from being considered as extension, thus are not changed -\/ the new extension is added instead.
\end{DoxyItemize}

\subparagraph*{Examples / specs}

\begin{DoxyVerb}`upath.changeExt(filename, '.js')`  --returns-->

    ✓ `'my/module.min'`            --->                `'my/module.js'`
    ✓ `'my/module.coffee'`         --->                `'my/module.js'`
    ✓ `'my/module'`                --->                `'my/module.js'`
    ✓ `'file/withDot.'`            --->             `'file/withDot.js'`
    ✓ `'file/change.longExt'`      --->      `'file/change.longExt.js'`
\end{DoxyVerb}


If no {\ttfamily ext} param is given, it trims the current extension (if any). \begin{DoxyVerb}`upath.changeExt(filename)`        --returns-->

      ✓ `'my/module.min'`            --->                   `'my/module'`
      ✓ `'my/module.coffee'`         --->                   `'my/module'`
      ✓ `'my/module'`                --->                   `'my/module'`
      ✓ `'file/withDot.'`            --->                `'file/withDot'`
      ✓ `'file/change.longExt'`      --->         `'file/change.longExt'`
\end{DoxyVerb}


It is ignoring {\ttfamily .min} \& {\ttfamily .dev} as extensions, and considers exts with up to 8 chars. \begin{DoxyVerb}`upath.changeExt(filename, 'js', ['min', '.dev'], 8)`        --returns-->

      ✓ `'my/module.coffee'`          --->                 `'my/module.js'`
      ✓ `'file/notValidExt.min'`      --->      `'file/notValidExt.min.js'`
      ✓ `'file/notValidExt.dev'`      --->      `'file/notValidExt.dev.js'`
      ✓ `'file/change.longExt'`       --->               `'file/change.js'`
      ✓ `'file/change.longRExt'`      --->      `'file/change.longRExt.js'`
\end{DoxyVerb}


\paragraph*{{\ttfamily upath.\+default\+Ext(filename, \mbox{[}ext\mbox{]}, \mbox{[}ignore\+Exts\mbox{]}, \mbox{[}max\+Size=7\mbox{]})}}

Adds {\ttfamily .ext} to {\ttfamily filename}, only if it doesn\textquotesingle{}t already have {\itshape any} {\itshape old} extension.


\begin{DoxyItemize}
\item (Old) extensions are considered to be up to {\ttfamily max\+Size} chars long, counting the dot (defaults to 7).
\item An {\ttfamily Array} of {\ttfamily ignore\+Exts} (eg `\mbox{[}'.min\textquotesingle{}\mbox{]}{\ttfamily ) will force adding default}.ext\`{} even if one of these is present.
\end{DoxyItemize}

\subparagraph*{Examples / specs}

\begin{DoxyVerb}`upath.defaultExt(filename, 'js')`   --returns-->

    ✓ `'fileWith/defaultExt'`              --->              `'fileWith/defaultExt.js'`
    ✓ `'fileWith/defaultExt.js'`           --->              `'fileWith/defaultExt.js'`
    ✓ `'fileWith/defaultExt.min'`          --->             `'fileWith/defaultExt.min'`
    ✓ `'fileWith/defaultExt.longExt'`      --->      `'fileWith/defaultExt.longExt.js'`
\end{DoxyVerb}


If no {\ttfamily ext} param is passed, it leaves filename intact. \begin{DoxyVerb}`upath.defaultExt(filename)`       --returns-->

      ✓ `'fileWith/defaultExt'`              --->                 `'fileWith/defaultExt'`
      ✓ `'fileWith/defaultExt.js'`           --->              `'fileWith/defaultExt.js'`
      ✓ `'fileWith/defaultExt.min'`          --->             `'fileWith/defaultExt.min'`
      ✓ `'fileWith/defaultExt.longExt'`      --->         `'fileWith/defaultExt.longExt'`
\end{DoxyVerb}


It is ignoring {\ttfamily .min} \& {\ttfamily .dev} as extensions, and considers exts with up to 8 chars. \begin{DoxyVerb}`upath.defaultExt(filename, 'js', ['min', '.dev'], 8)` --returns-->

      ✓ `'fileWith/defaultExt'`               --->               `'fileWith/defaultExt.js'`
      ✓ `'fileWith/defaultExt.min'`           --->           `'fileWith/defaultExt.min.js'`
      ✓ `'fileWith/defaultExt.dev'`           --->           `'fileWith/defaultExt.dev.js'`
      ✓ `'fileWith/defaultExt.longExt'`       --->          `'fileWith/defaultExt.longExt'`
      ✓ `'fileWith/defaultExt.longRext'`      --->      `'fileWith/defaultExt.longRext.js'`
\end{DoxyVerb}


Copyright(c) 2014-\/2017 Angelos Pikoulas (\href{mailto:agelos.pikoulas@gmail.com}{\tt agelos.\+pikoulas@gmail.\+com})

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \char`\"{}\+Software\char`\"{}), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions\+:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

T\+HE S\+O\+F\+T\+W\+A\+RE IS P\+R\+O\+V\+I\+D\+ED \char`\"{}\+A\+S I\+S\char`\"{}, W\+I\+T\+H\+O\+UT W\+A\+R\+R\+A\+N\+TY OF A\+NY K\+I\+ND, E\+X\+P\+R\+E\+SS OR I\+M\+P\+L\+I\+ED, I\+N\+C\+L\+U\+D\+I\+NG B\+UT N\+OT L\+I\+M\+I\+T\+ED TO T\+HE W\+A\+R\+R\+A\+N\+T\+I\+ES OF M\+E\+R\+C\+H\+A\+N\+T\+A\+B\+I\+L\+I\+TY, F\+I\+T\+N\+E\+SS F\+OR A P\+A\+R\+T\+I\+C\+U\+L\+AR P\+U\+R\+P\+O\+SE A\+ND N\+O\+N\+I\+N\+F\+R\+I\+N\+G\+E\+M\+E\+NT. IN NO E\+V\+E\+NT S\+H\+A\+LL T\+HE A\+U\+T\+H\+O\+RS OR C\+O\+P\+Y\+R\+I\+G\+HT H\+O\+L\+D\+E\+RS BE L\+I\+A\+B\+LE F\+OR A\+NY C\+L\+A\+IM, D\+A\+M\+A\+G\+ES OR O\+T\+H\+ER L\+I\+A\+B\+I\+L\+I\+TY, W\+H\+E\+T\+H\+ER IN AN A\+C\+T\+I\+ON OF C\+O\+N\+T\+R\+A\+CT, T\+O\+RT OR O\+T\+H\+E\+R\+W\+I\+SE, A\+R\+I\+S\+I\+NG F\+R\+OM, O\+UT OF OR IN C\+O\+N\+N\+E\+C\+T\+I\+ON W\+I\+TH T\+HE S\+O\+F\+T\+W\+A\+RE OR T\+HE U\+SE OR O\+T\+H\+ER D\+E\+A\+L\+I\+N\+GS IN T\+HE S\+O\+F\+T\+W\+A\+RE.

97 passing (33ms) 