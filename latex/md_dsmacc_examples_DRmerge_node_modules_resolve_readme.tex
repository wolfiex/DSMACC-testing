implements the \href{https://nodejs.org/api/modules.html#modules_all_together}{\tt node {\ttfamily require.\+resolve()} algorithm} such that you can {\ttfamily require.\+resolve()} on behalf of a file asynchronously and synchronously

\href{http://travis-ci.org/browserify/node-resolve}{\tt }

\section*{example}

asynchronously resolve\+:


\begin{DoxyCode}
var resolve = require('resolve');
resolve('tap', \{ basedir: \_\_dirname \}, function (err, res) \{
    if (err) console.error(err);
    else console.log(res);
\});
\end{DoxyCode}



\begin{DoxyCode}
$ node example/async.js
/home/substack/projects/node-resolve/node\_modules/tap/lib/main.js
\end{DoxyCode}


synchronously resolve\+:


\begin{DoxyCode}
var resolve = require('resolve');
var res = resolve.sync('tap', \{ basedir: \_\_dirname \});
console.log(res);
\end{DoxyCode}



\begin{DoxyCode}
$ node example/sync.js
/home/substack/projects/node-resolve/node\_modules/tap/lib/main.js
\end{DoxyCode}


\section*{methods}


\begin{DoxyCode}
var resolve = require('resolve');
\end{DoxyCode}


\subsection*{resolve(id, opts=\{\}, cb)}

Asynchronously resolve the module path string {\ttfamily id} into {\ttfamily cb(err, res \mbox{[}, pkg\mbox{]})}, where {\ttfamily pkg} (if defined) is the data from {\ttfamily package.\+json}.

options are\+:


\begin{DoxyItemize}
\item opts.\+basedir -\/ directory to begin resolving from
\item opts.\+package -\/ {\ttfamily package.\+json} data applicable to the module being loaded
\item opts.\+extensions -\/ array of file extensions to search in order
\item opts.\+read\+File -\/ how to read files asynchronously
\item opts.\+is\+File -\/ function to asynchronously test whether a file exists
\item opts.\+is\+Directory -\/ function to asynchronously test whether a directory exists
\item {\ttfamily opts.\+package\+Filter(pkg, pkgfile)} -\/ transform the parsed package.\+json contents before looking at the \char`\"{}main\char`\"{} field
\begin{DoxyItemize}
\item pkg -\/ package data
\item pkgfile -\/ path to package.\+json
\end{DoxyItemize}
\item {\ttfamily opts.\+path\+Filter(pkg, path, relative\+Path)} -\/ transform a path within a package
\begin{DoxyItemize}
\item pkg -\/ package data
\item path -\/ the path being resolved
\item relative\+Path -\/ the path relative from the package.\+json location
\item returns -\/ a relative path that will be joined from the package.\+json location
\end{DoxyItemize}
\item opts.\+paths -\/ require.\+paths array to use if nothing is found on the normal {\ttfamily node\+\_\+modules} recursive walk (probably don\textquotesingle{}t use this)

For advanced users, {\ttfamily paths} can also be a {\ttfamily opts.\+paths(request, start, opts)} function
\begin{DoxyItemize}
\item request -\/ the import specifier being resolved
\item start -\/ lookup path
\item get\+Node\+Modules\+Dirs -\/ a thunk (no-\/argument function) that returns the paths using standard {\ttfamily node\+\_\+modules} resolution
\item opts -\/ the resolution options
\end{DoxyItemize}
\item opts.\+module\+Directory -\/ directory (or directories) in which to recursively look for modules. default\+: {\ttfamily \char`\"{}node\+\_\+modules\char`\"{}}
\item opts.\+preserve\+Symlinks -\/ if true, doesn\textquotesingle{}t resolve {\ttfamily basedir} to real path before resolving. This is the way \mbox{\hyperlink{classNode}{Node}} resolves dependencies when executed with the \href{https://nodejs.org/api/all.html#cli_preserve_symlinks}{\tt --preserve-\/symlinks} flag. {\bfseries Note\+:} this property is currently {\ttfamily true} by default but it will be changed to {\ttfamily false} in the next major version because {\itshape \mbox{\hyperlink{classNode}{Node}}\textquotesingle{}s resolution algorithm does not preserve symlinks by default}.
\end{DoxyItemize}

default {\ttfamily opts} values\+:


\begin{DoxyCode}
\{
    paths: [],
    basedir: \_\_dirname,
    extensions: ['.js'],
    readFile: fs.readFile,
    isFile: function isFile(file, cb) \{
        fs.stat(file, function (err, stat) \{
            if (!err) \{
                return cb(null, stat.isFile() || stat.isFIFO());
            \}
            if (err.code === 'ENOENT' || err.code === 'ENOTDIR') return cb(null, false);
            return cb(err);
        \});
    \},
    isDirectory: function isDirectory(dir, cb) \{
        fs.stat(dir, function (err, stat) \{
            if (!err) \{
                return cb(null, stat.isDirectory());
            \}
            if (err.code === 'ENOENT' || err.code === 'ENOTDIR') return cb(null, false);
            return cb(err);
        \});
    \},
    moduleDirectory: 'node\_modules',
    preserveSymlinks: true
\}
\end{DoxyCode}


\subsection*{resolve.\+sync(id, opts)}

Synchronously resolve the module path string {\ttfamily id}, returning the result and throwing an error when {\ttfamily id} can\textquotesingle{}t be resolved.

options are\+:


\begin{DoxyItemize}
\item opts.\+basedir -\/ directory to begin resolving from
\item opts.\+extensions -\/ array of file extensions to search in order
\item opts.\+read\+File -\/ how to read files synchronously
\item opts.\+is\+File -\/ function to synchronously test whether a file exists
\item opts.\+is\+Directory -\/ function to synchronously test whether a directory exists
\item {\ttfamily opts.\+package\+Filter(pkg, dir)} -\/ transform the parsed package.\+json contents before looking at the \char`\"{}main\char`\"{} field
\begin{DoxyItemize}
\item pkg -\/ package data
\item dir -\/ directory for package.\+json (Note\+: the second argument will change to \char`\"{}pkgfile\char`\"{} in v2)
\end{DoxyItemize}
\item {\ttfamily opts.\+path\+Filter(pkg, path, relative\+Path)} -\/ transform a path within a package
\begin{DoxyItemize}
\item pkg -\/ package data
\item path -\/ the path being resolved
\item relative\+Path -\/ the path relative from the package.\+json location
\item returns -\/ a relative path that will be joined from the package.\+json location
\end{DoxyItemize}
\item opts.\+paths -\/ require.\+paths array to use if nothing is found on the normal {\ttfamily node\+\_\+modules} recursive walk (probably don\textquotesingle{}t use this)
\item opts.\+module\+Directory -\/ directory (or directories) in which to recursively look for modules. default\+: {\ttfamily \char`\"{}node\+\_\+modules\char`\"{}}
\item opts.\+preserve\+Symlinks -\/ if true, doesn\textquotesingle{}t resolve {\ttfamily basedir} to real path before resolving. This is the way \mbox{\hyperlink{classNode}{Node}} resolves dependencies when executed with the \href{https://nodejs.org/api/all.html#cli_preserve_symlinks}{\tt --preserve-\/symlinks} flag. {\bfseries Note\+:} this property is currently {\ttfamily true} by default but it will be changed to {\ttfamily false} in the next major version because {\itshape \mbox{\hyperlink{classNode}{Node}}\textquotesingle{}s resolution algorithm does not preserve symlinks by default}.
\end{DoxyItemize}

default {\ttfamily opts} values\+:


\begin{DoxyCode}
\{
    paths: [],
    basedir: \_\_dirname,
    extensions: ['.js'],
    readFileSync: fs.readFileSync,
    isFile: function isFile(file) \{
        try \{
            var stat = fs.statSync(file);
        \} catch (e) \{
            if (e && (e.code === 'ENOENT' || e.code === 'ENOTDIR')) return false;
            throw e;
        \}
        return stat.isFile() || stat.isFIFO();
    \},
    isDirectory: function isDirectory(dir) \{
        try \{
            var stat = fs.statSync(dir);
        \} catch (e) \{
            if (e && (e.code === 'ENOENT' || e.code === 'ENOTDIR')) return false;
            throw e;
        \}
        return stat.isDirectory();
    \},
    moduleDirectory: 'node\_modules',
    preserveSymlinks: true
\}
\end{DoxyCode}


\subsection*{resolve.\+is\+Core(pkg)}

Return whether a package is in core.

\section*{install}

With \href{https://npmjs.org}{\tt npm} do\+:


\begin{DoxyCode}
npm install resolve
\end{DoxyCode}


\section*{license}

M\+IT 