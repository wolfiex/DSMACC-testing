This module provides a parser and formatter for delimiter-\/separated values, most commonly \href{https://en.wikipedia.org/wiki/Comma-separated_values}{\tt comma-\/} (C\+SV) or tab-\/separated values (T\+SV). These tabular formats are popular with spreadsheet programs such as Microsoft Excel, and are often more space-\/efficient than J\+S\+ON. This implementation is based on \href{http://tools.ietf.org/html/rfc4180}{\tt R\+FC 4180}.

Comma (C\+SV) and tab (T\+SV) delimiters are built-\/in. For example, to parse\+:


\begin{DoxyCode}
d3.csvParse("foo,bar\(\backslash\)n1,2"); // [\{foo: "1", bar: "2"\}, columns: ["foo", "bar"]]
d3.tsvParse("foo\(\backslash\)tbar\(\backslash\)n1\(\backslash\)t2"); // [\{foo: "1", bar: "2"\}, columns: ["foo", "bar"]]
\end{DoxyCode}


Or to format\+:


\begin{DoxyCode}
d3.csvFormat([\{foo: "1", bar: "2"\}]); // "foo,bar\(\backslash\)n1,2"
d3.tsvFormat([\{foo: "1", bar: "2"\}]); // "foo\(\backslash\)tbar\(\backslash\)n1\(\backslash\)t2"
\end{DoxyCode}


To use a different delimiter, such as “$\vert$” for pipe-\/separated values, use \href{#dsvFormat}{\tt d3.\+dsv\+Format}\+:


\begin{DoxyCode}
var psv = d3.dsvFormat("|");

console.log(psv.parse("foo|bar\(\backslash\)n1|2")); // [\{foo: "1", bar: "2"\}, columns: ["foo", "bar"]]
\end{DoxyCode}


For easy loading of D\+SV files in a browser, see \href{https://github.com/d3/d3-request}{\tt d3-\/request}’s \href{https://github.com/d3/d3-request#csv}{\tt d3.\+csv} and \href{https://github.com/d3/d3-request#tsv}{\tt d3.\+tsv} methods.

\subsection*{Installing}

If you use N\+PM, {\ttfamily npm install d3-\/dsv}. Otherwise, download the \href{https://github.com/d3/d3-dsv/releases/latest}{\tt latest release}. You can also load directly from \href{https://d3js.org}{\tt d3js.\+org}, either as a \href{https://d3js.org/d3-dsv.v1.min.js}{\tt standalone library} or as part of \href{https://github.com/d3/d3}{\tt D3 4.\+0}. A\+MD, Common\+JS, and vanilla environments are supported. In vanilla, a {\ttfamily d3} global is exported\+:


\begin{DoxyCode}
<script src="https://d3js.org/d3-dsv.v1.min.js"></script>
<script>

var data = d3.csvParse(string);

</script>
\end{DoxyCode}


\href{https://tonicdev.com/npm/d3-dsv}{\tt Try d3-\/dsv in your browser.}

\subsection*{A\+PI Reference}

\label{_csvParse}%
\# d3.{\bfseries csv\+Parse}({\itshape string}\mbox{[}, {\itshape row}\mbox{]}) \href{https://github.com/d3/d3-dsv/blob/master/src/csv.js#L5}{\tt $<$$>$}

Equivalent to \href{#dsvFormat}{\tt dsv\+Format}(\char`\"{},\char`\"{}).\href{#dsv_parse}{\tt parse}.

\label{_csvParseRows}%
\# d3.{\bfseries csv\+Parse\+Rows}({\itshape string}\mbox{[}, {\itshape row}\mbox{]}) \href{https://github.com/d3/d3-dsv/blob/master/src/csv.js#L6}{\tt $<$$>$}

Equivalent to \href{#dsvFormat}{\tt dsv\+Format}(\char`\"{},\char`\"{}).\href{#dsv_parseRows}{\tt parse\+Rows}.

\label{_csvFormat}%
\# d3.{\bfseries csv\+Format}({\itshape rows}\mbox{[}, {\itshape columns}\mbox{]}) \href{https://github.com/d3/d3-dsv/blob/master/src/csv.js#L7}{\tt $<$$>$}

Equivalent to \href{#dsvFormat}{\tt dsv\+Format}(\char`\"{},\char`\"{}).\href{#dsv_format}{\tt format}.

\label{_csvFormatRows}%
\# d3.{\bfseries csv\+Format\+Rows}({\itshape rows}) \href{https://github.com/d3/d3-dsv/blob/master/src/csv.js#L8}{\tt $<$$>$}

Equivalent to \href{#dsvFormat}{\tt dsv\+Format}(\char`\"{},\char`\"{}).\href{#dsv_formatRows}{\tt format\+Rows}.

\label{_tsvParse}%
\# d3.{\bfseries tsv\+Parse}({\itshape string}\mbox{[}, {\itshape row}\mbox{]}) \href{https://github.com/d3/d3-dsv/blob/master/src/tsv.js#L5}{\tt $<$$>$}

Equivalent to \href{#dsvFormat}{\tt dsv\+Format}(\char`\"{}\textbackslash{}t\char`\"{}).\href{#dsv_parse}{\tt parse}.

\label{_tsvParseRows}%
\# d3.{\bfseries tsv\+Parse\+Rows}({\itshape string}\mbox{[}, {\itshape row}\mbox{]}) \href{https://github.com/d3/d3-dsv/blob/master/src/tsv.js#L6}{\tt $<$$>$}

Equivalent to \href{#dsvFormat}{\tt dsv\+Format}(\char`\"{}\textbackslash{}t\char`\"{}).\href{#dsv_parseRows}{\tt parse\+Rows}.

\label{_tsvFormat}%
\# d3.{\bfseries tsv\+Format}({\itshape rows}\mbox{[}, {\itshape columns}\mbox{]}) \href{https://github.com/d3/d3-dsv/blob/master/src/tsv.js#L7}{\tt $<$$>$}

Equivalent to \href{#dsvFormat}{\tt dsv\+Format}(\char`\"{}\textbackslash{}t\char`\"{}).\href{#dsv_format}{\tt format}.

\label{_tsvFormatRows}%
\# d3.{\bfseries tsv\+Format\+Rows}({\itshape rows}) \href{https://github.com/d3/d3-dsv/blob/master/src/tsv.js#L8}{\tt $<$$>$}

Equivalent to \href{#dsvFormat}{\tt dsv\+Format}(\char`\"{}\textbackslash{}t\char`\"{}).\href{#dsv_formatRows}{\tt format\+Rows}.

\label{_dsvFormat}%
\# d3.{\bfseries dsv\+Format}({\itshape delimiter}) \href{https://github.com/d3/d3-dsv/blob/master/src/dsv.js#L30}{\tt $<$$>$}

Constructs a new D\+SV parser and formatter for the specified {\itshape delimiter}. The {\itshape delimiter} must be a single character ({\itshape i.\+e.}, a single 16-\/bit code unit); so, A\+S\+C\+II delimiters are fine, but emoji delimiters are not.

\label{_dsv_parse}%
\# {\itshape dsv}.{\bfseries parse}({\itshape string}\mbox{[}, {\itshape row}\mbox{]}) \href{https://github.com/d3/d3-dsv/blob/master/src/dsv.js#L34}{\tt $<$$>$}

Parses the specified {\itshape string}, which must be in the delimiter-\/separated values format with the appropriate delimiter, returning an array of objects representing the parsed rows.

Unlike \href{#dsv_parseRows}{\tt {\itshape dsv}.parse\+Rows}, this method requires that the first line of the D\+SV content contains a delimiter-\/separated list of column names; these column names become the attributes on the returned objects. For example, consider the following C\+SV file\+:


\begin{DoxyCode}
Year,Make,Model,Length
1997,Ford,E350,2.34
2000,Mercury,Cougar,2.38
\end{DoxyCode}


The resulting Java\+Script array is\+:


\begin{DoxyCode}
[
  \{"Year": "1997", "Make": "Ford", "Model": "E350", "Length": "2.34"\},
  \{"Year": "2000", "Make": "Mercury", "Model": "Cougar", "Length": "2.38"\}
]
\end{DoxyCode}


The returned array also exposes a {\ttfamily columns} property containing the column names in input order (in contrast to Object.\+keys, whose iteration order is arbitrary). For example\+:


\begin{DoxyCode}
data.columns; // ["Year", "Make", "Model", "Length"]
\end{DoxyCode}


If a {\itshape row} conversion function is not specified, field values are strings. For safety, there is no automatic conversion to numbers, dates, or other types. In some cases, Java\+Script may coerce strings to numbers for you automatically (for example, using the {\ttfamily +} operator), but better is to specify a {\itshape row} conversion function.

If a {\itshape row} conversion function is specified, the specified function is invoked for each row, being passed an object representing the current row ({\ttfamily d}), the index ({\ttfamily i}) starting at zero for the first non-\/header row, and the array of column names. If the returned value is null or undefined, the row is skipped and will be ommitted from the array returned by {\itshape dsv}.parse; otherwise, the returned value defines the corresponding row object. For example\+:


\begin{DoxyCode}
var data = d3.csvParse(string, function(d) \{
  return \{
    year: new Date(+d.Year, 0, 1), // lowercase and convert "Year" to Date
    make: d.Make, // lowercase
    model: d.Model, // lowercase
    length: +d.Length // lowercase and convert "Length" to number
  \};
\});
\end{DoxyCode}


Note\+: using {\ttfamily +} rather than \href{https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/parseInt}{\tt parse\+Int} or \href{https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/parseFloat}{\tt parse\+Float} is typically faster, though more restrictive. For example, {\ttfamily \char`\"{}30px\char`\"{}} when coerced using {\ttfamily +} returns {\ttfamily NaN}, while parse\+Int and parse\+Float return {\ttfamily 30}.

\label{_dsv_parseRows}%
\# {\itshape dsv}.{\bfseries parse\+Rows}({\itshape string}\mbox{[}, {\itshape row}\mbox{]}) \href{https://github.com/d3/d3-dsv/blob/master/src/dsv.js#L43}{\tt $<$$>$}

Parses the specified {\itshape string}, which must be in the delimiter-\/separated values format with the appropriate delimiter, returning an array of arrays representing the parsed rows.

Unlike \href{#dsv_parse}{\tt {\itshape dsv}.parse}, this method treats the header line as a standard row, and should be used whenever D\+SV content does not contain a header. Each row is represented as an array rather than an object. Rows may have variable length. For example, consider the following C\+SV file, which notably lacks a header line\+:


\begin{DoxyCode}
1997,Ford,E350,2.34
2000,Mercury,Cougar,2.38
\end{DoxyCode}


The resulting Java\+Script array is\+:


\begin{DoxyCode}
[
  ["1997", "Ford", "E350", "2.34"],
  ["2000", "Mercury", "Cougar", "2.38"]
]
\end{DoxyCode}


If a {\itshape row} conversion function is not specified, field values are strings. For safety, there is no automatic conversion to numbers, dates, or other types. In some cases, Java\+Script may coerce strings to numbers for you automatically (for example, using the {\ttfamily +} operator), but better is to specify a {\itshape row} conversion function.

If a {\itshape row} conversion function is specified, the specified function is invoked for each row, being passed an array representing the current row ({\ttfamily d}), the index ({\ttfamily i}) starting at zero for the first row, and the array of column names. If the returned value is null or undefined, the row is skipped and will be ommitted from the array returned by {\itshape dsv}.parse; otherwise, the returned value defines the corresponding row object. For example\+:


\begin{DoxyCode}
var data = d3.csvParseRows(string, function(d, i) \{
  return \{
    year: new Date(+d[0], 0, 1), // convert first colum column to Date
    make: d[1],
    model: d[2],
    length: +d[3] // convert fourth column to number
  \};
\});
\end{DoxyCode}


In effect, {\itshape row} is similar to applying a \href{https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/map}{\tt map} and \href{https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/filter}{\tt filter} operator to the returned rows.

\label{_dsv_format}%
\# {\itshape dsv}.{\bfseries format}({\itshape rows}\mbox{[}, {\itshape columns}\mbox{]}) \href{https://github.com/d3/d3-dsv/blob/master/src/dsv.js#L105}{\tt $<$$>$}

Formats the specified array of object {\itshape rows} as delimiter-\/separated values, returning a string. This operation is the inverse of \href{#dsv_parse}{\tt {\itshape dsv}.parse}. Each row will be separated by a newline ({\ttfamily \textbackslash{}n}), and each column within each row will be separated by the delimiter (such as a comma, {\ttfamily ,}). Values that contain either the delimiter, a double-\/quote ({\ttfamily "}) or a newline will be escaped using double-\/quotes.

If {\itshape columns} is not specified, the list of column names that forms the header row is determined by the union of all properties on all objects in {\itshape rows}; the order of columns is nondeterministic. If {\itshape columns} is specified, it is an array of strings representing the column names. For example\+:


\begin{DoxyCode}
var string = d3.csvFormat(data, ["year", "make", "model", "length"]);
\end{DoxyCode}


All fields on each row object will be coerced to strings. For more control over which and how fields are formatted, first map {\itshape rows} to an array of array of string, and then use \href{#dsv_formatRows}{\tt {\itshape dsv}.format\+Rows}.

\label{_dsv_formatRows}%
\# {\itshape dsv}.{\bfseries format\+Rows}({\itshape rows}) \href{https://github.com/d3/d3-dsv/blob/master/src/dsv.js#L114}{\tt $<$$>$}

Formats the specified array of array of string {\itshape rows} as delimiter-\/separated values, returning a string. This operation is the reverse of \href{#dsv_parseRows}{\tt {\itshape dsv}.parse\+Rows}. Each row will be separated by a newline ({\ttfamily \textbackslash{}n}), and each column within each row will be separated by the delimiter (such as a comma, {\ttfamily ,}). Values that contain either the delimiter, a double-\/quote (") or a newline will be escaped using double-\/quotes.

To convert an array of objects to an array of arrays while explicitly specifying the columns, use \href{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map}{\tt {\itshape array}.map}. For example\+:


\begin{DoxyCode}
var string = d3.csvFormatRows(data.map(function(d, i) \{
  return [
    d.year.getFullYear(), // Assuming d.year is a Date object.
    d.make,
    d.model,
    d.length
  ];
\}));
\end{DoxyCode}


If you like, you can also \href{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/concat}{\tt {\itshape array}.concat} this result with an array of column names to generate the first row\+:


\begin{DoxyCode}
var string = d3.csvFormatRows([[
    "year",
    "make",
    "model",
    "length"
  ]].concat(data.map(function(d, i) \{
  return [
    d.year.getFullYear(), // Assuming d.year is a Date object.
    d.make,
    d.model,
    d.length
  ];
\})));
\end{DoxyCode}


\subsubsection*{Content Security Policy}

If a \href{http://www.w3.org/TR/CSP/}{\tt content security policy} is in place, note that \href{#dsv_parse}{\tt {\itshape dsv}.parse} requires {\ttfamily unsafe-\/eval} in the {\ttfamily script-\/src} directive, due to the (safe) use of dynamic code generation for fast parsing. (See \href{https://github.com/d3/d3-dsv/blob/master/src/dsv.js}{\tt source}.) Alternatively, use \href{#dsv_parseRows}{\tt {\itshape dsv}.parse\+Rows}.

\subsubsection*{Byte-\/\+Order Marks}

D\+SV files sometimes begin with a \href{https://en.wikipedia.org/wiki/Byte_order_mark}{\tt byte order mark (B\+OM)}; saving a spreadsheet in C\+SV U\+T\+F-\/8 format from Microsoft Excel, for example, will include a B\+OM. On the web this is not usually a problem because the \href{https://encoding.spec.whatwg.org/#utf-8-decode}{\tt U\+T\+F-\/8 decode algorithm} specified in the Encoding standard removes the B\+OM. Node.\+js, on the other hand, \href{https://github.com/nodejs/node-v0.x-archive/issues/1918}{\tt does not remove the B\+OM} when decoding U\+T\+F-\/8.

If the B\+OM is not removed, the first character of the text is a zero-\/width non-\/breaking space. So if a C\+SV file with a B\+OM is parsed by \href{#csvParse}{\tt d3.\+csv\+Parse}, the first column’s name will begin with a zero-\/width non-\/breaking space. This can be hard to spot since this character is usually invisible when printed.

To remove the B\+OM before parsing, consider using \href{https://www.npmjs.com/package/strip-bom}{\tt strip-\/bom}.

\subsection*{Command Line Reference}

\subsubsection*{dsv2dsv}

\label{_dsv2dsv}%
\# {\bfseries dsv2dsv} \mbox{[}{\itshape options…}\mbox{]} \mbox{[}{\itshape file}\mbox{]}

Converts the specified D\+SV input {\itshape file} to D\+SV (typically with a different delimiter or encoding). If {\itshape file} is not specified, defaults to reading from stdin. For example, to convert to C\+SV to T\+SV\+:


\begin{DoxyCode}
csv2tsv < example.csv > example.tsv
\end{DoxyCode}


To convert windows-\/1252 C\+SV to utf-\/8 C\+SV\+:


\begin{DoxyCode}
dsv2dsv --input-encoding windows-1252 < latin1.csv > utf8.csv
\end{DoxyCode}


\label{_dsv2dsv_help}%
\# dsv2dsv {\bfseries -\/h} ~\newline
\href{dsv2dsv_help}{\tt \#} dsv2dsv {\bfseries --help}

Output usage information.

\label{_dsv2dsv_version}%
\# dsv2dsv {\bfseries -\/V} ~\newline
\href{dsv2dsv_version}{\tt \#} dsv2dsv {\bfseries --version}

Output the version number.

\label{_dsv2dsv_out}%
\# dsv2dsv {\bfseries -\/o} {\itshape file} ~\newline
\href{dsv2dsv_out}{\tt \#} dsv2dsv {\bfseries --out} {\itshape file}

Specify the output file name. Defaults to “-\/” for stdout.

\label{_dsv2dsv_input_delimiter}%
\# dsv2dsv {\bfseries -\/r} {\itshape delimiter} ~\newline
\href{dsv2dsv_input_delimiter}{\tt \#} dsv2dsv {\bfseries --input-\/delimiter} {\itshape delimiter}

Specify the input delimiter character. Defaults to “,” for reading C\+SV. (You can enter a tab on the command line by typing ⌃V.)

\label{_dsv2dsv_input_encoding}%
\# dsv2dsv {\bfseries --input-\/encoding} {\itshape encoding}

Specify the input character encoding. Defaults to “utf8”.

\label{_dsv2dsv_output_delimiter}%
\# dsv2dsv {\bfseries -\/w} {\itshape delimiter} ~\newline
\href{dsv2dsv_output_delimiter}{\tt \#} dsv2dsv {\bfseries --output-\/delimiter} {\itshape delimiter}

Specify the output delimiter character. Defaults to “,” for writing C\+SV. (You can enter a tab on the command line by typing ⌃V.)

\label{_dsv2dsv_output_encoding}%
\# dsv2dsv {\bfseries --output-\/encoding} {\itshape encoding}

Specify the output character encoding. Defaults to “utf8”.

\label{_csv2tsv}%
\# {\bfseries csv2tsv} \mbox{[}{\itshape options…}\mbox{]} \mbox{[}{\itshape file}\mbox{]}

Equivalent to \href{#dsv2dsv}{\tt dsv2dsv}, but the \href{#dsv2dsv_output_delimiter}{\tt output delimiter} defaults to the tab character ().

\label{_tsv2csv}%
\# {\bfseries tsv2csv} \mbox{[}{\itshape options…}\mbox{]} \mbox{[}{\itshape file}\mbox{]}

Equivalent to \href{#dsv2dsv}{\tt dsv2dsv}, but the \href{#dsv2dsv_output_delimiter}{\tt input delimiter} defaults to the tab character ().

\subsubsection*{dsv2json}

\label{_dsv2json}%
\# {\bfseries dsv2json} \mbox{[}{\itshape options…}\mbox{]} \mbox{[}{\itshape file}\mbox{]}

Converts the specified D\+SV input {\itshape file} to J\+S\+ON. If {\itshape file} is not specified, defaults to reading from stdin. For example, to convert to C\+SV to J\+S\+ON\+:


\begin{DoxyCode}
csv2json < example.csv > example.json
\end{DoxyCode}


Or to convert C\+SV to a newline-\/delimited J\+S\+ON stream\+:


\begin{DoxyCode}
csv2json -n < example.csv > example.ndjson
\end{DoxyCode}


\label{_dsv2json_help}%
\# dsv2json {\bfseries -\/h} ~\newline
\href{dsv2json_help}{\tt \#} dsv2json {\bfseries --help}

Output usage information.

\label{_dsv2json_version}%
\# dsv2json {\bfseries -\/V} ~\newline
\href{dsv2json_version}{\tt \#} dsv2json {\bfseries --version}

Output the version number.

\label{_dsv2json_out}%
\# dsv2json {\bfseries -\/o} {\itshape file} ~\newline
\href{dsv2json_out}{\tt \#} dsv2json {\bfseries --out} {\itshape file}

Specify the output file name. Defaults to “-\/” for stdout.

\label{_dsv2json_input_delimiter}%
\# dsv2json {\bfseries -\/r} {\itshape delimiter} ~\newline
\href{dsv2json_input_delimiter}{\tt \#} dsv2json {\bfseries --input-\/delimiter} {\itshape delimiter}

Specify the input delimiter character. Defaults to “,” for reading C\+SV. (You can enter a tab on the command line by typing ⌃V.)

\label{_dsv2json_input_encoding}%
\# dsv2json {\bfseries --input-\/encoding} {\itshape encoding}

Specify the input character encoding. Defaults to “utf8”.

\label{_dsv2json_output_encoding}%
\# dsv2json {\bfseries -\/r} {\itshape encoding} ~\newline
\href{dsv2json_output_encoding}{\tt \#} dsv2json {\bfseries --output-\/encoding} {\itshape encoding}

Specify the output character encoding. Defaults to “utf8”.

\label{_dsv2json_newline_delimited}%
\# dsv2json {\bfseries -\/n} ~\newline
\href{dsv2json_newline_delimited}{\tt \#} dsv2json {\bfseries --newline-\/delimited}

Output \href{https://github.com/mbostock/ndjson-cli}{\tt newline-\/delimited J\+S\+ON} instead of a single J\+S\+ON array.

\label{_csv2json}%
\# {\bfseries csv2json} \mbox{[}{\itshape options…}\mbox{]} \mbox{[}{\itshape file}\mbox{]}

Equivalent to \href{#dsv2json}{\tt dsv2json}.

\label{_tsv2json}%
\# {\bfseries tsv2json} \mbox{[}{\itshape options…}\mbox{]} \mbox{[}{\itshape file}\mbox{]}

Equivalent to \href{#dsv2json}{\tt dsv2json}, but the \href{#dsv2json_input_delimiter}{\tt input delimiter} defaults to the tab character ().

\subsubsection*{json2dsv}

\label{_json2dsv}%
\# {\bfseries json2dsv} \mbox{[}{\itshape options…}\mbox{]} \mbox{[}{\itshape file}\mbox{]}

Converts the specified J\+S\+ON input {\itshape file} to D\+SV. If {\itshape file} is not specified, defaults to reading from stdin. For example, to convert to J\+S\+ON to C\+SV\+:


\begin{DoxyCode}
json2csv < example.json > example.csv
\end{DoxyCode}


Or to convert a newline-\/delimited J\+S\+ON stream to C\+SV\+:


\begin{DoxyCode}
json2csv -n < example.ndjson > example.csv
\end{DoxyCode}


\label{_json2dsv_help}%
\# json2dsv {\bfseries -\/h} ~\newline
\href{json2dsv_help}{\tt \#} json2dsv {\bfseries --help}

Output usage information.

\label{_json2dsv_version}%
\# json2dsv {\bfseries -\/V} ~\newline
\href{json2dsv_version}{\tt \#} json2dsv {\bfseries --version}

Output the version number.

\label{_json2dsv_out}%
\# json2dsv {\bfseries -\/o} {\itshape file} ~\newline
\href{json2dsv_out}{\tt \#} json2dsv {\bfseries --out} {\itshape file}

Specify the output file name. Defaults to “-\/” for stdout.

\label{_json2dsv_input_encoding}%
\# json2dsv {\bfseries --input-\/encoding} {\itshape encoding}

Specify the input character encoding. Defaults to “utf8”.

\label{_json2dsv_output_delimiter}%
\# json2dsv {\bfseries -\/w} {\itshape delimiter} ~\newline
\href{json2dsv_output_delimiter}{\tt \#} json2dsv {\bfseries --output-\/delimiter} {\itshape delimiter}

Specify the output delimiter character. Defaults to “,” for writing C\+SV. (You can enter a tab on the command line by typing ⌃V.)

\label{_json2dsv_output_encoding}%
\# json2dsv {\bfseries --output-\/encoding} {\itshape encoding}

Specify the output character encoding. Defaults to “utf8”.

\label{_json2dsv_newline_delimited}%
\# json2dsv {\bfseries -\/n} ~\newline
\href{json2dsv_newline_delimited}{\tt \#} json2dsv {\bfseries --newline-\/delimited}

Read \href{https://github.com/mbostock/ndjson-cli}{\tt newline-\/delimited J\+S\+ON} instead of a single J\+S\+ON array.

\label{_csv2json}%
\# {\bfseries csv2json} \mbox{[}{\itshape options…}\mbox{]} \mbox{[}{\itshape file}\mbox{]}

Equivalent to \href{#json2dsv}{\tt json2dsv}.

\label{_tsv2json}%
\# {\bfseries tsv2json} \mbox{[}{\itshape options…}\mbox{]} \mbox{[}{\itshape file}\mbox{]}

Equivalent to \href{#json2dsv}{\tt json2dsv}, but the \href{#json2dsv_output_delimiter}{\tt output delimiter} defaults to the tab character (). 