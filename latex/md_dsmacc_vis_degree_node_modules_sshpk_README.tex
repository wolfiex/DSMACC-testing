Parse, convert, fingerprint and use S\+SH keys (both public and private) in pure node -- no {\ttfamily ssh-\/keygen} or other external dependencies.

Supports R\+SA, D\+SA, E\+C\+D\+SA (nistp-\/$\ast$) and E\+D25519 key types, in P\+EM (P\+K\+CS\#1, P\+K\+CS\#8) and Open\+S\+SH formats.

This library has been extracted from \href{https://github.com/joyent/node-http-signature}{\tt {\ttfamily node-\/http-\/signature}} (work by \href{https://github.com/mcavage}{\tt Mark Cavage} and \href{https://github.com/bahamas10}{\tt Dave Eddy}) and \href{https://github.com/bahamas10/node-ssh-fingerprint}{\tt {\ttfamily node-\/ssh-\/fingerprint}} (work by Dave Eddy), with additions (including E\+C\+D\+SA support) by \href{https://github.com/arekinath}{\tt Alex Wilson}.

\subsection*{Install }


\begin{DoxyCode}
npm install sshpk
\end{DoxyCode}


\subsection*{Examples }


\begin{DoxyCode}
var sshpk = require('sshpk');

var fs = require('fs');

/* Read in an OpenSSH-format public key */
var keyPub = fs.readFileSync('id\_rsa.pub');
var key = sshpk.parseKey(keyPub, 'ssh');

/* Get metadata about the key */
console.log('type => %s', key.type);
console.log('size => %d bits', key.size);
console.log('comment => %s', key.comment);

/* Compute key fingerprints, in new OpenSSH (>6.7) format, and old MD5 */
console.log('fingerprint => %s', key.fingerprint().toString());
console.log('old-style fingerprint => %s', key.fingerprint('md5').toString());
\end{DoxyCode}


Example output\+:


\begin{DoxyCode}
type => rsa
size => 2048 bits
comment => foo@foo.com
fingerprint => SHA256:PYC9kPVC6J873CSIbfp0LwYeczP/W4ffObNCuDJ1u5w
old-style fingerprint => a0:c8:ad:6c:32:9a:32:fa:59:cc:a9:8c:0a:0d:6e:bd
\end{DoxyCode}


More examples\+: converting between formats\+:


\begin{DoxyCode}
/* Read in a PEM public key */
var keyPem = fs.readFileSync('id\_rsa.pem');
var key = sshpk.parseKey(keyPem, 'pem');

/* Convert to PEM PKCS#8 public key format */
var pemBuf = key.toBuffer('pkcs8');

/* Convert to SSH public key format (and return as a string) */
var sshKey = key.toString('ssh');
\end{DoxyCode}


Signing and verifying\+:


\begin{DoxyCode}
/* Read in an OpenSSH/PEM *private* key */
var keyPriv = fs.readFileSync('id\_ecdsa');
var key = sshpk.parsePrivateKey(keyPriv, 'pem');

var data = 'some data';

/* Sign some data with the key */
var s = key.createSign('sha1');
s.update(data);
var signature = s.sign();

/* Now load the public key (could also use just key.toPublic()) */
var keyPub = fs.readFileSync('id\_ecdsa.pub');
key = sshpk.parseKey(keyPub, 'ssh');

/* Make a crypto.Verifier with this key */
var v = key.createVerify('sha1');
v.update(data);
var valid = v.verify(signature);
/* => true! */
\end{DoxyCode}


Matching fingerprints with keys\+:


\begin{DoxyCode}
var fp = sshpk.parseFingerprint('SHA256:PYC9kPVC6J873CSIbfp0LwYeczP/W4ffObNCuDJ1u5w');

var keys = [sshpk.parseKey(...), sshpk.parseKey(...), ...];

keys.forEach(function (key) \{
    if (fp.matches(key))
        console.log('found it!');
\});
\end{DoxyCode}


\subsection*{Usage }

\subsection*{Public keys}

\subsubsection*{`parse\+Key(data\mbox{[}, format = \textquotesingle{}auto'\mbox{[}, options\mbox{]}\mbox{]})\`{}}

Parses a key from a given data format and returns a new {\ttfamily Key} object.

Parameters


\begin{DoxyItemize}
\item {\ttfamily data} -- Either a Buffer or String, containing the key
\item {\ttfamily format} -- String name of format to use, valid options are\+:
\begin{DoxyItemize}
\item {\ttfamily auto}\+: choose automatically from all below
\item {\ttfamily pem}\+: supports both P\+K\+CS\#1 and P\+K\+CS\#8
\item {\ttfamily ssh}\+: standard Open\+S\+SH format,
\item {\ttfamily pkcs1}, {\ttfamily pkcs8}\+: variants of {\ttfamily pem}
\item {\ttfamily rfc4253}\+: raw Open\+S\+SH wire format
\item {\ttfamily openssh}\+: new post-\/\+Open\+S\+SH 6.\+5 internal format, produced by {\ttfamily ssh-\/keygen -\/o}
\item {\ttfamily dnssec}\+: {\ttfamily .key} file format output by {\ttfamily dnssec-\/keygen} etc
\item {\ttfamily putty}\+: the Pu\+T\+TY {\ttfamily .ppk} file format (supports truncated variant without all the lines from {\ttfamily Private-\/\+Lines\+:} onwards)
\end{DoxyItemize}
\item {\ttfamily options} -- Optional Object, extra options, with keys\+:
\begin{DoxyItemize}
\item {\ttfamily filename} -- Optional String, name for the key being parsed (eg. the filename that was opened). Used to generate Error messages
\item {\ttfamily passphrase} -- Optional String, encryption passphrase used to decrypt an encrypted P\+EM file
\end{DoxyItemize}
\end{DoxyItemize}

\subsubsection*{{\ttfamily Key.\+is\+Key(obj)}}

Returns {\ttfamily true} if the given object is a valid {\ttfamily Key} object created by a version of {\ttfamily sshpk} compatible with this one.

Parameters


\begin{DoxyItemize}
\item {\ttfamily obj} -- Object to identify
\end{DoxyItemize}

\subsubsection*{{\ttfamily Key\+::type}}

String, the type of key. Valid options are {\ttfamily rsa}, {\ttfamily dsa}, {\ttfamily ecdsa}.

\subsubsection*{{\ttfamily Key\+::size}}

Integer, \char`\"{}size\char`\"{} of the key in bits. For R\+S\+A/\+D\+SA this is the size of the modulus; for E\+C\+D\+SA this is the bit size of the curve in use.

\subsubsection*{{\ttfamily Key\+::comment}}

Optional string, a key comment used by some formats (eg the {\ttfamily ssh} format).

\subsubsection*{{\ttfamily Key\+::curve}}

Only present if `this.\+type === \textquotesingle{}ecdsa'{\ttfamily , string containing the name of the named curve used with this key. Possible values include}nistp256{\ttfamily ,}nistp384{\ttfamily  and}nistp521\`{}.

\subsubsection*{`Key\+::to\+Buffer(\mbox{[}format = \textquotesingle{}ssh'\mbox{]})\`{}}

Convert the key into a given data format and return the serialized key as a Buffer.

Parameters


\begin{DoxyItemize}
\item {\ttfamily format} -- String name of format to use, for valid options see {\ttfamily parse\+Key()}
\end{DoxyItemize}

\subsubsection*{{\ttfamily Key\+::to\+String(\mbox{[}format = \textquotesingle{}ssh\mbox{]})}}

Same as {\ttfamily this.\+to\+Buffer(format).to\+String()}.

\subsubsection*{`Key\+::fingerprint(\mbox{[}algorithm = \textquotesingle{}sha256'\mbox{[}, hash\+Type = \textquotesingle{}ssh\textquotesingle{}\mbox{]}\mbox{]})\`{}}

Creates a new {\ttfamily Fingerprint} object representing this Key\textquotesingle{}s fingerprint.

Parameters


\begin{DoxyItemize}
\item {\ttfamily algorithm} -- String name of hash algorithm to use, valid options are {\ttfamily md5}, {\ttfamily sha1}, {\ttfamily sha256}, {\ttfamily sha384}, {\ttfamily sha512}
\item {\ttfamily hash\+Type} -- String name of fingerprint hash type to use, valid options are {\ttfamily ssh} (the type of fingerprint used by Open\+S\+SH, e.\+g. in {\ttfamily ssh-\/keygen}), {\ttfamily spki} (used by H\+P\+KP, some Open\+S\+SL applications)
\end{DoxyItemize}

\subsubsection*{{\ttfamily Key\+::create\+Verify(\mbox{[}hash\+Algorithm\mbox{]})}}

Creates a {\ttfamily crypto.\+Verifier} specialized to use this Key (and the correct public key algorithm to match it). The returned Verifier has the same A\+PI as a regular one, except that the {\ttfamily verify()} function takes only the target signature as an argument.

Parameters


\begin{DoxyItemize}
\item {\ttfamily hash\+Algorithm} -- optional String name of hash algorithm to use, any supported by Open\+S\+SL are valid, usually including {\ttfamily sha1}, {\ttfamily sha256}.
\end{DoxyItemize}

{\ttfamily v.\+verify(signature\mbox{[}, format\mbox{]})} Parameters


\begin{DoxyItemize}
\item {\ttfamily signature} -- either a Signature object, or a Buffer or String
\item {\ttfamily format} -- optional String, name of format to interpret given String with. Not valid if {\ttfamily signature} is a Signature or Buffer.
\end{DoxyItemize}

\subsubsection*{{\ttfamily Key\+::create\+Diffie\+Hellman()}}

\subsubsection*{{\ttfamily Key\+::create\+D\+H()}}

Creates a Diffie-\/\+Hellman key exchange object initialized with this key and all necessary parameters. This has the same A\+PI as a {\ttfamily crypto.\+Diffie\+Hellman} instance, except that functions take {\ttfamily Key} and {\ttfamily Private\+Key} objects as arguments, and return them where indicated for.

This is only valid for keys belonging to a cryptosystem that supports D\+HE or a close analogue (i.\+e. {\ttfamily dsa}, {\ttfamily ecdsa} and {\ttfamily curve25519} keys). An attempt to call this function on other keys will yield an {\ttfamily Error}.

\subsection*{Private keys}

\subsubsection*{`parse\+Private\+Key(data\mbox{[}, format = \textquotesingle{}auto'\mbox{[}, options\mbox{]}\mbox{]})\`{}}

Parses a private key from a given data format and returns a new {\ttfamily Private\+Key} object.

Parameters


\begin{DoxyItemize}
\item {\ttfamily data} -- Either a Buffer or String, containing the key
\item {\ttfamily format} -- String name of format to use, valid options are\+:
\begin{DoxyItemize}
\item {\ttfamily auto}\+: choose automatically from all below
\item {\ttfamily pem}\+: supports both P\+K\+CS\#1 and P\+K\+CS\#8
\item {\ttfamily ssh}, {\ttfamily openssh}\+: new post-\/\+Open\+S\+SH 6.\+5 internal format, produced by {\ttfamily ssh-\/keygen -\/o}
\item {\ttfamily pkcs1}, {\ttfamily pkcs8}\+: variants of {\ttfamily pem}
\item {\ttfamily rfc4253}\+: raw Open\+S\+SH wire format
\item {\ttfamily dnssec}\+: {\ttfamily .private} format output by {\ttfamily dnssec-\/keygen} etc.
\end{DoxyItemize}
\item {\ttfamily options} -- Optional Object, extra options, with keys\+:
\begin{DoxyItemize}
\item {\ttfamily filename} -- Optional String, name for the key being parsed (eg. the filename that was opened). Used to generate Error messages
\item {\ttfamily passphrase} -- Optional String, encryption passphrase used to decrypt an encrypted P\+EM file
\end{DoxyItemize}
\end{DoxyItemize}

\subsubsection*{{\ttfamily generate\+Private\+Key(type\mbox{[}, options\mbox{]})}}

Generates a new private key of a certain key type, from random data.

Parameters


\begin{DoxyItemize}
\item {\ttfamily type} -- String, type of key to generate. Currently supported are `\textquotesingle{}ecdsa'{\ttfamily  and}\textquotesingle{}ed25519\textquotesingle{}{\ttfamily  -\/}options{\ttfamily -\/-\/ optional Object, with keys\+: -\/}curve{\ttfamily -\/-\/ optional String, for}\textquotesingle{}ecdsa\textquotesingle{}\`{} keys, specifies the curve to use. If E\+C\+D\+SA is specified and this option is not given, defaults to using `\textquotesingle{}nistp256'\`{}.
\end{DoxyItemize}

\subsubsection*{{\ttfamily Private\+Key.\+is\+Private\+Key(obj)}}

Returns {\ttfamily true} if the given object is a valid {\ttfamily Private\+Key} object created by a version of {\ttfamily sshpk} compatible with this one.

Parameters


\begin{DoxyItemize}
\item {\ttfamily obj} -- Object to identify
\end{DoxyItemize}

\subsubsection*{{\ttfamily Private\+Key\+::type}}

String, the type of key. Valid options are {\ttfamily rsa}, {\ttfamily dsa}, {\ttfamily ecdsa}.

\subsubsection*{{\ttfamily Private\+Key\+::size}}

Integer, \char`\"{}size\char`\"{} of the key in bits. For R\+S\+A/\+D\+SA this is the size of the modulus; for E\+C\+D\+SA this is the bit size of the curve in use.

\subsubsection*{{\ttfamily Private\+Key\+::curve}}

Only present if `this.\+type === \textquotesingle{}ecdsa'{\ttfamily , string containing the name of the named curve used with this key. Possible values include}nistp256{\ttfamily ,}nistp384{\ttfamily  and}nistp521\`{}.

\subsubsection*{`Private\+Key\+::to\+Buffer(\mbox{[}format = \textquotesingle{}pkcs1'\mbox{]})\`{}}

Convert the key into a given data format and return the serialized key as a Buffer.

Parameters


\begin{DoxyItemize}
\item {\ttfamily format} -- String name of format to use, valid options are listed under {\ttfamily parse\+Private\+Key}. Note that E\+D25519 keys default to {\ttfamily openssh} format instead (as they have no {\ttfamily pkcs1} representation).
\end{DoxyItemize}

\subsubsection*{`Private\+Key\+::to\+String(\mbox{[}format = \textquotesingle{}pkcs1'\mbox{]})\`{}}

Same as {\ttfamily this.\+to\+Buffer(format).to\+String()}.

\subsubsection*{{\ttfamily Private\+Key\+::to\+Public()}}

Extract just the public part of this private key, and return it as a {\ttfamily Key} object.

\subsubsection*{`Private\+Key\+::fingerprint(\mbox{[}algorithm = \textquotesingle{}sha256'\mbox{]})\`{}}

Same as {\ttfamily this.\+to\+Public().fingerprint()}.

\subsubsection*{{\ttfamily Private\+Key\+::create\+Verify(\mbox{[}hash\+Algorithm\mbox{]})}}

Same as {\ttfamily this.\+to\+Public().create\+Verify()}.

\subsubsection*{{\ttfamily Private\+Key\+::create\+Sign(\mbox{[}hash\+Algorithm\mbox{]})}}

Creates a {\ttfamily crypto.\+Sign} specialized to use this Private\+Key (and the correct key algorithm to match it). The returned Signer has the same A\+PI as a regular one, except that the {\ttfamily sign()} function takes no arguments, and returns a {\ttfamily Signature} object.

Parameters


\begin{DoxyItemize}
\item {\ttfamily hash\+Algorithm} -- optional String name of hash algorithm to use, any supported by Open\+S\+SL are valid, usually including {\ttfamily sha1}, {\ttfamily sha256}.
\end{DoxyItemize}

{\ttfamily v.\+sign()} Parameters


\begin{DoxyItemize}
\item none
\end{DoxyItemize}

\subsubsection*{{\ttfamily Private\+Key\+::derive(new\+Type)}}

Derives a related key of type {\ttfamily new\+Type} from this key. Currently this is only supported to change between {\ttfamily ed25519} and {\ttfamily curve25519} keys which are stored with the same private key (but usually distinct public keys in order to avoid degenerate keys that lead to a weak Diffie-\/\+Hellman exchange).

Parameters


\begin{DoxyItemize}
\item {\ttfamily new\+Type} -- String, type of key to derive, either {\ttfamily ed25519} or {\ttfamily curve25519}
\end{DoxyItemize}

\subsection*{Fingerprints}

\subsubsection*{{\ttfamily parse\+Fingerprint(fingerprint\mbox{[}, options\mbox{]})}}

Pre-\/parses a fingerprint, creating a {\ttfamily Fingerprint} object that can be used to quickly locate a key by using the {\ttfamily Fingerprint\+::matches} function.

Parameters


\begin{DoxyItemize}
\item {\ttfamily fingerprint} -- String, the fingerprint value, in any supported format
\item {\ttfamily options} -- Optional Object, with properties\+:
\begin{DoxyItemize}
\item {\ttfamily algorithms} -- Array of strings, names of hash algorithms to limit support to. If {\ttfamily fingerprint} uses a hash algorithm not on this list, throws {\ttfamily Invalid\+Algorithm\+Error}.
\item {\ttfamily hash\+Type} -- String, the type of hash the fingerprint uses, either {\ttfamily ssh} or {\ttfamily spki} (normally auto-\/detected based on the format, but can be overridden)
\item {\ttfamily type} -- String, the entity this fingerprint identifies, either {\ttfamily key} or {\ttfamily certificate}
\end{DoxyItemize}
\end{DoxyItemize}

\subsubsection*{{\ttfamily Fingerprint.\+is\+Fingerprint(obj)}}

Returns {\ttfamily true} if the given object is a valid {\ttfamily Fingerprint} object created by a version of {\ttfamily sshpk} compatible with this one.

Parameters


\begin{DoxyItemize}
\item {\ttfamily obj} -- Object to identify
\end{DoxyItemize}

\subsubsection*{{\ttfamily Fingerprint\+::to\+String(\mbox{[}format\mbox{]})}}

Returns a fingerprint as a string, in the given format.

Parameters


\begin{DoxyItemize}
\item {\ttfamily format} -- Optional String, format to use, valid options are {\ttfamily hex} and {\ttfamily base64}. If this {\ttfamily Fingerprint} uses the {\ttfamily md5} algorithm, the default format is {\ttfamily hex}. Otherwise, the default is {\ttfamily base64}.
\end{DoxyItemize}

\subsubsection*{{\ttfamily Fingerprint\+::matches(key\+Or\+Certificate)}}

Verifies whether or not this {\ttfamily Fingerprint} matches a given {\ttfamily Key} or {\ttfamily Certificate}. This function uses double-\/hashing to avoid leaking timing information. Returns a boolean.

Note that a {\ttfamily Key}-\/type Fingerprint will always return {\ttfamily false} if asked to match a {\ttfamily Certificate} and vice versa.

Parameters


\begin{DoxyItemize}
\item {\ttfamily key\+Or\+Certificate} -- a {\ttfamily Key} object or {\ttfamily Certificate} object, the entity to match this fingerprint against
\end{DoxyItemize}

\subsection*{Signatures}

\subsubsection*{{\ttfamily parse\+Signature(signature, algorithm, format)}}

Parses a signature in a given format, creating a {\ttfamily Signature} object. Useful for converting between the S\+SH and A\+S\+N.\+1 (P\+K\+C\+S/\+Open\+S\+SL) signature formats, and also returned as output from {\ttfamily Private\+Key\+::create\+Sign().sign()}.

A Signature object can also be passed to a verifier produced by {\ttfamily Key\+::create\+Verify()} and it will automatically be converted internally into the correct format for verification.

Parameters


\begin{DoxyItemize}
\item {\ttfamily signature} -- a Buffer (binary) or String (base64), data of the actual signature in the given format
\item {\ttfamily algorithm} -- a String, name of the algorithm to be used, possible values are {\ttfamily rsa}, {\ttfamily dsa}, {\ttfamily ecdsa}
\item {\ttfamily format} -- a String, either {\ttfamily asn1} or {\ttfamily ssh}
\end{DoxyItemize}

\subsubsection*{{\ttfamily Signature.\+is\+Signature(obj)}}

Returns {\ttfamily true} if the given object is a valid {\ttfamily Signature} object created by a version of {\ttfamily sshpk} compatible with this one.

Parameters


\begin{DoxyItemize}
\item {\ttfamily obj} -- Object to identify
\end{DoxyItemize}

\subsubsection*{`Signature\+::to\+Buffer(\mbox{[}format = \textquotesingle{}asn1'\mbox{]})\`{}}

Converts a Signature to the given format and returns it as a Buffer.

Parameters


\begin{DoxyItemize}
\item {\ttfamily format} -- a String, either {\ttfamily asn1} or {\ttfamily ssh}
\end{DoxyItemize}

\subsubsection*{`Signature\+::to\+String(\mbox{[}format = \textquotesingle{}asn1'\mbox{]})\`{}}

Same as `this.\+to\+Buffer(format).to\+String(\textquotesingle{}base64')\`{}.

\subsection*{Certificates}

{\ttfamily sshpk} includes basic support for parsing certificates in X.\+509 (P\+EM) format and the Open\+S\+SH certificate format. This feature is intended to be used mainly to access basic metadata about certificates, extract public keys from them, and also to generate simple self-\/signed certificates from an existing key.

Notably, there is no implementation of CA chain-\/of-\/trust verification, and only very minimal support for key usage restrictions. Please do the security world a favour, and DO N\+OT use this code for certificate verification in the traditional X.\+509 CA chain style.

\subsubsection*{{\ttfamily parse\+Certificate(data, format)}}

Parameters


\begin{DoxyItemize}
\item {\ttfamily data} -- a Buffer or String
\item {\ttfamily format} -- a String, format to use, one of `\textquotesingle{}openssh'{\ttfamily ,}\textquotesingle{}pem\textquotesingle{}{\ttfamily (X.\+509 in a P\+EM wrapper), or}\textquotesingle{}x509\textquotesingle{}\`{} (raw D\+ER encoded)
\end{DoxyItemize}

\subsubsection*{{\ttfamily create\+Self\+Signed\+Certificate(subject, private\+Key\mbox{[}, options\mbox{]})}}

Parameters


\begin{DoxyItemize}
\item {\ttfamily subject} -- an Identity, the subject of the certificate
\item {\ttfamily private\+Key} -- a Private\+Key, the key of the subject\+: will be used both to be placed in the certificate and also to sign it (since this is a self-\/signed certificate)
\item {\ttfamily options} -- optional Object, with keys\+:
\begin{DoxyItemize}
\item {\ttfamily lifetime} -- optional Number, lifetime of the certificate from now in seconds
\item {\ttfamily valid\+From}, {\ttfamily valid\+Until} -- optional Dates, beginning and end of certificate validity period. If given {\ttfamily lifetime} will be ignored
\item {\ttfamily serial} -- optional Buffer, the serial number of the certificate
\item {\ttfamily purposes} -- optional Array of String, X.\+509 key usage restrictions
\end{DoxyItemize}
\end{DoxyItemize}

\subsubsection*{{\ttfamily create\+Certificate(subject, key, issuer, issuer\+Key\mbox{[}, options\mbox{]})}}

Parameters


\begin{DoxyItemize}
\item {\ttfamily subject} -- an Identity, the subject of the certificate
\item {\ttfamily key} -- a Key, the public key of the subject
\item {\ttfamily issuer} -- an Identity, the issuer of the certificate who will sign it
\item {\ttfamily issuer\+Key} -- a Private\+Key, the issuer\textquotesingle{}s private key for signing
\item {\ttfamily options} -- optional Object, with keys\+:
\begin{DoxyItemize}
\item {\ttfamily lifetime} -- optional Number, lifetime of the certificate from now in seconds
\item {\ttfamily valid\+From}, {\ttfamily valid\+Until} -- optional Dates, beginning and end of certificate validity period. If given {\ttfamily lifetime} will be ignored
\item {\ttfamily serial} -- optional Buffer, the serial number of the certificate
\item {\ttfamily purposes} -- optional Array of String, X.\+509 key usage restrictions
\end{DoxyItemize}
\end{DoxyItemize}

\subsubsection*{{\ttfamily Certificate\+::subjects}}

Array of {\ttfamily Identity} instances describing the subject of this certificate.

\subsubsection*{{\ttfamily Certificate\+::issuer}}

The {\ttfamily Identity} of the Certificate\textquotesingle{}s issuer (signer).

\subsubsection*{{\ttfamily Certificate\+::subject\+Key}}

The public key of the subject of the certificate, as a {\ttfamily Key} instance.

\subsubsection*{{\ttfamily Certificate\+::issuer\+Key}}

The public key of the signing issuer of this certificate, as a {\ttfamily Key} instance. May be {\ttfamily undefined} if the issuer\textquotesingle{}s key is unknown (e.\+g. on an X509 certificate).

\subsubsection*{{\ttfamily Certificate\+::serial}}

The serial number of the certificate. As this is normally a 64-\/bit or wider integer, it is returned as a Buffer.

\subsubsection*{{\ttfamily Certificate\+::purposes}}

Array of Strings indicating the X.\+509 key usage purposes that this certificate is valid for. The possible strings at the moment are\+:


\begin{DoxyItemize}
\item `\textquotesingle{}signature'{\ttfamily -\/-\/ key can be used for digital signatures $\ast$}\textquotesingle{}identity\textquotesingle{}{\ttfamily -\/-\/ key can be used to attest about the identity of the signer (X.\+509 calls this}non\+Repudiation{\ttfamily ) $\ast$}\textquotesingle{}code\+Signing\textquotesingle{}{\ttfamily -\/-\/ key can be used to sign executable code $\ast$}\textquotesingle{}key\+Encryption\textquotesingle{}{\ttfamily -\/-\/ key can be used to encrypt other keys $\ast$}\textquotesingle{}encryption\textquotesingle{}{\ttfamily -\/-\/ key can be used to encrypt data (only applies for R\+SA) $\ast$}\textquotesingle{}key\+Agreement\textquotesingle{}\`{} -- key can be used for key exchange protocols such as Diffie-\/\+Hellman
\item `\textquotesingle{}ca'\`{} -- key can be used to sign other certificates (is a Certificate Authority)
\item `\textquotesingle{}crl'\`{} -- key can be used to sign Certificate Revocation Lists (C\+R\+Ls)
\end{DoxyItemize}

\subsubsection*{{\ttfamily Certificate\+::get\+Extension(name\+Or\+Oid)}}

Retrieves information about a certificate extension, if present, or returns {\ttfamily undefined} if not. The string argument {\ttfamily name\+Or\+Oid} should be either the O\+ID (for X509 extensions) or the name (for Open\+S\+SH extensions) of the extension to retrieve.

The object returned will have the following properties\+:


\begin{DoxyItemize}
\item {\ttfamily format} -- String, set to either `\textquotesingle{}x509'{\ttfamily or}\textquotesingle{}openssh\textquotesingle{}{\ttfamily  $\ast$}name{\ttfamily or}oid{\ttfamily -\/-\/ String, only one set based on value of}format{\ttfamily  $\ast$}data\`{} -- Buffer, the raw data inside the extension
\end{DoxyItemize}

\subsubsection*{{\ttfamily Certificate\+::get\+Extensions()}}

Returns an Array of all present certificate extensions, in the same manner and format as {\ttfamily get\+Extension()}.

\subsubsection*{{\ttfamily Certificate\+::is\+Expired(\mbox{[}when\mbox{]})}}

Tests whether the Certificate is currently expired (i.\+e. the {\ttfamily valid\+From} and {\ttfamily valid\+Until} dates specify a range of time that does not include the current time).

Parameters


\begin{DoxyItemize}
\item {\ttfamily when} -- optional \mbox{\hyperlink{classDate}{Date}}, if specified, tests whether the Certificate was or will be expired at the specified time instead of now
\end{DoxyItemize}

Returns a Boolean.

\subsubsection*{{\ttfamily Certificate\+::is\+Signed\+By\+Key(key)}}

Tests whether the Certificate was validly signed by the given (public) Key.

Parameters


\begin{DoxyItemize}
\item {\ttfamily key} -- a Key instance
\end{DoxyItemize}

Returns a Boolean.

\subsubsection*{{\ttfamily Certificate\+::is\+Signed\+By(certificate)}}

Tests whether this Certificate was validly signed by the subject of the given certificate. Also tests that the issuer Identity of this Certificate and the subject Identity of the other Certificate are equivalent.

Parameters


\begin{DoxyItemize}
\item {\ttfamily certificate} -- another Certificate instance
\end{DoxyItemize}

Returns a Boolean.

\subsubsection*{{\ttfamily Certificate\+::fingerprint(\mbox{[}hash\+Algo\mbox{]})}}

Returns the X509-\/style fingerprint of the entire certificate (as a Fingerprint instance). This matches what a web-\/browser or similar would display as the certificate fingerprint and should not be confused with the fingerprint of the subject\textquotesingle{}s public key.

Parameters


\begin{DoxyItemize}
\item {\ttfamily hash\+Algo} -- an optional String, any hash function name
\end{DoxyItemize}

\subsubsection*{{\ttfamily Certificate\+::to\+Buffer(\mbox{[}format\mbox{]})}}

Serializes the Certificate to a Buffer and returns it.

Parameters


\begin{DoxyItemize}
\item {\ttfamily format} -- an optional String, output format, one of `\textquotesingle{}openssh'{\ttfamily ,}\textquotesingle{}pem\textquotesingle{}{\ttfamily or }\textquotesingle{}x509\textquotesingle{}{\ttfamily . Defaults to}\textquotesingle{}x509\textquotesingle{}\`{}.
\end{DoxyItemize}

Returns a Buffer.

\subsubsection*{{\ttfamily Certificate\+::to\+String(\mbox{[}format\mbox{]})}}


\begin{DoxyItemize}
\item {\ttfamily format} -- an optional String, output format, one of `\textquotesingle{}openssh'{\ttfamily ,}\textquotesingle{}pem\textquotesingle{}{\ttfamily or }\textquotesingle{}x509\textquotesingle{}{\ttfamily . Defaults to}\textquotesingle{}pem\textquotesingle{}\`{}.
\end{DoxyItemize}

Returns a String.

\subsection*{Certificate identities}

\subsubsection*{{\ttfamily identity\+For\+Host(hostname)}}

Constructs a host-\/type Identity for a given hostname.

Parameters


\begin{DoxyItemize}
\item {\ttfamily hostname} -- the fully qualified D\+NS name of the host
\end{DoxyItemize}

Returns an Identity instance.

\subsubsection*{{\ttfamily identity\+For\+User(uid)}}

Constructs a user-\/type Identity for a given U\+ID.

Parameters


\begin{DoxyItemize}
\item {\ttfamily uid} -- a String, user identifier (login name)
\end{DoxyItemize}

Returns an Identity instance.

\subsubsection*{{\ttfamily identity\+For\+Email(email)}}

Constructs an email-\/type Identity for a given email address.

Parameters


\begin{DoxyItemize}
\item {\ttfamily email} -- a String, email address
\end{DoxyItemize}

Returns an Identity instance.

\subsubsection*{{\ttfamily identity\+From\+D\+N(dn)}}

Parses an L\+D\+A\+P-\/style DN string (e.\+g. `\textquotesingle{}CN=foo, C=US'\`{}) and turns it into an Identity instance.

Parameters


\begin{DoxyItemize}
\item {\ttfamily dn} -- a String
\end{DoxyItemize}

Returns an Identity instance.

\subsubsection*{{\ttfamily identity\+From\+Array(arr)}}

Constructs an Identity from an array of DN components (see {\ttfamily Identity\+::to\+Array()} for the format).

Parameters


\begin{DoxyItemize}
\item {\ttfamily arr} -- an Array of Objects, DN components with {\ttfamily name} and {\ttfamily value}
\end{DoxyItemize}

Returns an Identity instance.

Supported attributes in D\+Ns\+:

\tabulinesep=1mm
\begin{longtabu} spread 0pt [c]{*{2}{|X[-1]}|}
\hline
\rowcolor{\tableheadbgcolor}\textbf{ Attribute name  }&\textbf{ O\+ID   }\\\cline{1-2}
\endfirsthead
\hline
\endfoot
\hline
\rowcolor{\tableheadbgcolor}\textbf{ Attribute name  }&\textbf{ O\+ID   }\\\cline{1-2}
\endhead
{\ttfamily cn}  &{\ttfamily 2.\+5.\+4.\+3}   \\\cline{1-2}
{\ttfamily o}  &{\ttfamily 2.\+5.\+4.\+10}   \\\cline{1-2}
{\ttfamily ou}  &{\ttfamily 2.\+5.\+4.\+11}   \\\cline{1-2}
{\ttfamily l}  &{\ttfamily 2.\+5.\+4.\+7}   \\\cline{1-2}
{\ttfamily s}  &{\ttfamily 2.\+5.\+4.\+8}   \\\cline{1-2}
{\ttfamily c}  &{\ttfamily 2.\+5.\+4.\+6}   \\\cline{1-2}
{\ttfamily sn}  &{\ttfamily 2.\+5.\+4.\+4}   \\\cline{1-2}
{\ttfamily postal\+Code}  &{\ttfamily 2.\+5.\+4.\+17}   \\\cline{1-2}
{\ttfamily serial\+Number}  &{\ttfamily 2.\+5.\+4.\+5}   \\\cline{1-2}
{\ttfamily street}  &{\ttfamily 2.\+5.\+4.\+9}   \\\cline{1-2}
{\ttfamily x500\+Unique\+Identifier}  &{\ttfamily 2.\+5.\+4.\+45}   \\\cline{1-2}
{\ttfamily role}  &{\ttfamily 2.\+5.\+4.\+72}   \\\cline{1-2}
{\ttfamily telephone\+Number}  &{\ttfamily 2.\+5.\+4.\+20}   \\\cline{1-2}
{\ttfamily description}  &{\ttfamily 2.\+5.\+4.\+13}   \\\cline{1-2}
{\ttfamily dc}  &{\ttfamily 0.\+9.\+2342.\+19200300.\+100.\+1.\+25}   \\\cline{1-2}
{\ttfamily uid}  &{\ttfamily 0.\+9.\+2342.\+19200300.\+100.\+1.\+1}   \\\cline{1-2}
{\ttfamily mail}  &{\ttfamily 0.\+9.\+2342.\+19200300.\+100.\+1.\+3}   \\\cline{1-2}
{\ttfamily title}  &{\ttfamily 2.\+5.\+4.\+12}   \\\cline{1-2}
{\ttfamily gn}  &{\ttfamily 2.\+5.\+4.\+42}   \\\cline{1-2}
{\ttfamily initials}  &{\ttfamily 2.\+5.\+4.\+43}   \\\cline{1-2}
{\ttfamily pseudonym}  &{\ttfamily 2.\+5.\+4.\+65}   \\\cline{1-2}
\end{longtabu}


\subsubsection*{{\ttfamily Identity\+::to\+String()}}

Returns the identity as an L\+D\+A\+P-\/style DN string. e.\+g. `\textquotesingle{}CN=foo, O=bar corp, C=us'\`{}

\subsubsection*{{\ttfamily Identity\+::type}}

The type of identity. One of `\textquotesingle{}host'{\ttfamily ,}\textquotesingle{}user\textquotesingle{}{\ttfamily ,}\textquotesingle{}email\textquotesingle{}{\ttfamily or}\textquotesingle{}unknown\textquotesingle{}\`{}

\subsubsection*{{\ttfamily Identity\+::hostname}}

\subsubsection*{{\ttfamily Identity\+::uid}}

\subsubsection*{{\ttfamily Identity\+::email}}

Set when {\ttfamily type} is `\textquotesingle{}host'{\ttfamily ,}\textquotesingle{}user\textquotesingle{}{\ttfamily , or}\textquotesingle{}email\textquotesingle{}\`{}, respectively. Strings.

\subsubsection*{{\ttfamily Identity\+::cn}}

The value of the first {\ttfamily CN=} in the DN, if any. It\textquotesingle{}s probably better to use the {\ttfamily \#get()} method instead of this property.

\subsubsection*{{\ttfamily Identity\+::get(name\mbox{[}, as\+Array\mbox{]})}}

Returns the value of a named attribute in the Identity DN. If there is no attribute of the given name, returns {\ttfamily undefined}. If multiple components of the DN contain an attribute of this name, an exception is thrown unless the {\ttfamily as\+Array} argument is given as {\ttfamily true} -- then they will be returned as an Array in the same order they appear in the DN.

Parameters


\begin{DoxyItemize}
\item {\ttfamily name} -- a String
\item {\ttfamily as\+Array} -- an optional Boolean
\end{DoxyItemize}

\subsubsection*{{\ttfamily Identity\+::to\+Array()}}

Returns the Identity as an Array of DN component objects. This looks like\+:


\begin{DoxyCode}
[ \{
  "name": "cn",
  "value": "Joe Bloggs"
\},
\{
  "name": "o",
  "value": "Organisation Ltd"
\} ]
\end{DoxyCode}


Each object has a {\ttfamily name} and a {\ttfamily value} property. The returned objects may be safely modified.

\subsection*{Errors }

\subsubsection*{{\ttfamily Invalid\+Algorithm\+Error}}

The specified algorithm is not valid, either because it is not supported, or because it was not included on a list of allowed algorithms.

Thrown by {\ttfamily Fingerprint.\+parse}, {\ttfamily Key\+::fingerprint}.

Properties


\begin{DoxyItemize}
\item {\ttfamily algorithm} -- the algorithm that could not be validated
\end{DoxyItemize}

\subsubsection*{{\ttfamily Fingerprint\+Format\+Error}}

The fingerprint string given could not be parsed as a supported fingerprint format, or the specified fingerprint format is invalid.

Thrown by {\ttfamily Fingerprint.\+parse}, {\ttfamily Fingerprint\+::to\+String}.

Properties


\begin{DoxyItemize}
\item {\ttfamily fingerprint} -- if caused by a fingerprint, the string value given
\item {\ttfamily format} -- if caused by an invalid format specification, the string value given
\end{DoxyItemize}

\subsubsection*{{\ttfamily Key\+Parse\+Error}}

The key data given could not be parsed as a valid key.

Properties


\begin{DoxyItemize}
\item {\ttfamily key\+Name} -- {\ttfamily filename} that was given to {\ttfamily parse\+Key}
\item {\ttfamily format} -- the {\ttfamily format} that was trying to parse the key (see {\ttfamily parse\+Key})
\item {\ttfamily inner\+Err} -- the inner Error thrown by the format parser
\end{DoxyItemize}

\subsubsection*{{\ttfamily Key\+Encrypted\+Error}}

The key is encrypted with a symmetric key (ie, it is password protected). The parsing operation would succeed if it was given the {\ttfamily passphrase} option.

Properties


\begin{DoxyItemize}
\item {\ttfamily key\+Name} -- {\ttfamily filename} that was given to {\ttfamily parse\+Key}
\item {\ttfamily format} -- the {\ttfamily format} that was trying to parse the key (currently can only be {\ttfamily \char`\"{}pem\char`\"{}})
\end{DoxyItemize}

\subsubsection*{{\ttfamily Certificate\+Parse\+Error}}

The certificate data given could not be parsed as a valid certificate.

Properties


\begin{DoxyItemize}
\item {\ttfamily cert\+Name} -- {\ttfamily filename} that was given to {\ttfamily parse\+Certificate}
\item {\ttfamily format} -- the {\ttfamily format} that was trying to parse the key (see {\ttfamily parse\+Certificate})
\item {\ttfamily inner\+Err} -- the inner Error thrown by the format parser
\end{DoxyItemize}

\subsection*{Friends of sshpk }


\begin{DoxyItemize}
\item \href{https://github.com/arekinath/node-sshpk-agent}{\tt {\ttfamily sshpk-\/agent}} is a library for speaking the {\ttfamily ssh-\/agent} protocol from node.\+js, which uses {\ttfamily sshpk} 
\end{DoxyItemize}