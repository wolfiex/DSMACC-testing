\hypertarget{classSafeInFile}{}\section{Safe\+In\+File Class Reference}
\label{classSafeInFile}\index{Safe\+In\+File@{Safe\+In\+File}}


{\ttfamily \#include $<$Safe\+File.\+h$>$}

Inheritance diagram for Safe\+In\+File\+:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=2.000000cm]{classSafeInFile}
\end{center}
\end{figure}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{classSafeInFile_af87f32791231d79d4a0744db88231d3e}\label{classSafeInFile_af87f32791231d79d4a0744db88231d3e}} 
{\bfseries Safe\+In\+File} (const char $\ast$filename, ios\+\_\+base\+::openmode mode=ios\+\_\+base\+::in)
\end{DoxyCompactItemize}


\subsection{Detailed Description}
A wrapper for the C++ file stream class that automatically closes the file stream when the destructor is called. Allocate it on the stack to have it automatically closed when going out of scope.

Note\+: In C++, the only code that can be guaranteed to be executed after an exception is thrown are the destructors of objects residing on the stack.

You can exploit that fact to avoid resource leaks by tying all resources to the lifespan of an object allocated on the stack. This technique is called Resource Acquisition Is Initialization (R\+A\+II). 

The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
dsmacc/graph/infomap/src/io/Safe\+File.\+h\end{DoxyCompactItemize}
