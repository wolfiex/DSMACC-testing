Data in Java\+Script is often represented by an array, and so one tends to manipulate arrays when visualizing or analyzing data. Some common forms of manipulation include taking a contiguous slice (subset) of an array, filtering an array using a predicate function, and mapping an array to a parallel set of values using a transform function. Before looking at the set of utilities that this module provides, familiarize yourself with the powerful \href{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/prototype}{\tt array methods built-\/in to Java\+Script}.

Java\+Script includes {\bfseries mutation methods} that modify the array\+:


\begin{DoxyItemize}
\item \href{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/pop}{\tt {\itshape array}.pop} -\/ Remove the last element from the array.
\item \href{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/push}{\tt {\itshape array}.push} -\/ Add one or more elements to the end of the array.
\item \href{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reverse}{\tt {\itshape array}.reverse} -\/ Reverse the order of the elements of the array.
\item \href{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/shift}{\tt {\itshape array}.shift} -\/ Remove the first element from the array.
\item \href{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort}{\tt {\itshape array}.sort} -\/ Sort the elements of the array.
\item \href{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/splice}{\tt {\itshape array}.splice} -\/ Add or remove elements from the array.
\item \href{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/unshift}{\tt {\itshape array}.unshift} -\/ Add one or more elements to the front of the array.
\end{DoxyItemize}

There are also {\bfseries access methods} that return some representation of the array\+:


\begin{DoxyItemize}
\item \href{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/concat}{\tt {\itshape array}.concat} -\/ Join the array with other array(s) or value(s).
\item \href{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/join}{\tt {\itshape array}.join} -\/ Join all elements of the array into a string.
\item \href{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/slice}{\tt {\itshape array}.slice} -\/ Extract a section of the array.
\item \href{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf}{\tt {\itshape array}.index\+Of} -\/ Find the first occurrence of a value within the array.
\item \href{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/lastIndexOf}{\tt {\itshape array}.last\+Index\+Of} -\/ Find the last occurrence of a value within the array.
\end{DoxyItemize}

And finally {\bfseries iteration methods} that apply functions to elements in the array\+:


\begin{DoxyItemize}
\item \href{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter}{\tt {\itshape array}.filter} -\/ Create a new array with only the elements for which a predicate is true.
\item \href{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach}{\tt {\itshape array}.for\+Each} -\/ Call a function for each element in the array.
\item \href{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/every}{\tt {\itshape array}.every} -\/ See if every element in the array satisfies a predicate.
\item \href{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map}{\tt {\itshape array}.map} -\/ Create a new array with the result of calling a function on every element in the array.
\item \href{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/some}{\tt {\itshape array}.some} -\/ See if at least one element in the array satisfies a predicate.
\item \href{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce}{\tt {\itshape array}.reduce} -\/ Apply a function to reduce the array to a single value (from left-\/to-\/right).
\item \href{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight}{\tt {\itshape array}.reduce\+Right} -\/ Apply a function to reduce the array to a single value (from right-\/to-\/left).
\end{DoxyItemize}

\subsection*{Installing}

If you use N\+PM, {\ttfamily npm install d3-\/array}. Otherwise, download the \href{https://github.com/d3/d3-array/releases/latest}{\tt latest release}. You can also load directly from \href{https://d3js.org}{\tt d3js.\+org}, either as a \href{https://d3js.org/d3-array.v1.min.js}{\tt standalone library} or as part of \href{https://github.com/d3/d3}{\tt D3 4.\+0}. A\+MD, Common\+JS, and vanilla environments are supported. In vanilla, a {\ttfamily d3} global is exported\+:


\begin{DoxyCode}
<script src="https://d3js.org/d3-array.v1.min.js"></script>
<script>

var min = d3.min(array);

</script>
\end{DoxyCode}


\href{https://tonicdev.com/npm/d3-array}{\tt Try d3-\/array in your browser.}

\subsection*{A\+PI Reference}


\begin{DoxyItemize}
\item \href{#statistics}{\tt Statistics}
\item \href{#search}{\tt Search}
\item \href{#transformations}{\tt Transformations}
\item \href{#histograms}{\tt Histograms}
\item \href{#histogram-thresholds}{\tt Histogram Thresholds}
\end{DoxyItemize}

\subsubsection*{Statistics}

Methods for computing basic summary statistics.

\label{_min}%
\# d3.{\bfseries min}({\itshape array}\mbox{[}, {\itshape accessor}\mbox{]}) \href{https://github.com/d3/d3-array/blob/master/src/min.js}{\tt $<$$>$}

Returns the minimum value in the given {\itshape array} using natural order. If the array is empty, returns undefined. An optional {\itshape accessor} function may be specified, which is equivalent to calling {\itshape array}.map({\itshape accessor}) before computing the minimum value.

Unlike the built-\/in \href{https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Math/min}{\tt Math.\+min}, this method ignores undefined, null and NaN values; this is useful for ignoring missing data. In addition, elements are compared using natural order rather than numeric order. For example, the minimum of the strings \mbox{[}“20”, “3”\mbox{]} is “20”, while the minimum of the numbers \mbox{[}20, 3\mbox{]} is 3.

See also \href{#scan}{\tt scan} and \href{#extent}{\tt extent}.

\label{_max}%
\# d3.{\bfseries max}({\itshape array}\mbox{[}, {\itshape accessor}\mbox{]}) \href{https://github.com/d3/d3-array/blob/master/src/max.js}{\tt $<$$>$}

Returns the maximum value in the given {\itshape array} using natural order. If the array is empty, returns undefined. An optional {\itshape accessor} function may be specified, which is equivalent to calling {\itshape array}.map({\itshape accessor}) before computing the maximum value.

Unlike the built-\/in \href{https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Math/max}{\tt Math.\+max}, this method ignores undefined values; this is useful for ignoring missing data. In addition, elements are compared using natural order rather than numeric order. For example, the maximum of the strings \mbox{[}“20”, “3”\mbox{]} is “3”, while the maximum of the numbers \mbox{[}20, 3\mbox{]} is 20.

See also \href{#scan}{\tt scan} and \href{#extent}{\tt extent}.

\label{_extent}%
\# d3.{\bfseries extent}({\itshape array}\mbox{[}, {\itshape accessor}\mbox{]}) \href{https://github.com/d3/d3-array/blob/master/src/extent.js}{\tt $<$$>$}

Returns the \href{#min}{\tt minimum} and \href{#max}{\tt maximum} value in the given {\itshape array} using natural order. If the array is empty, returns \mbox{[}undefined, undefined\mbox{]}. An optional {\itshape accessor} function may be specified, which is equivalent to calling {\itshape array}.map({\itshape accessor}) before computing the extent.

\label{_sum}%
\# d3.{\bfseries sum}({\itshape array}\mbox{[}, {\itshape accessor}\mbox{]}) \href{https://github.com/d3/d3-array/blob/master/src/sum.js}{\tt $<$$>$}

Returns the sum of the given {\itshape array} of numbers. If the array is empty, returns 0. An optional {\itshape accessor} function may be specified, which is equivalent to calling {\itshape array}.map({\itshape accessor}) before computing the sum. This method ignores undefined and NaN values; this is useful for ignoring missing data.

\label{_mean}%
\# d3.{\bfseries mean}({\itshape array}\mbox{[}, {\itshape accessor}\mbox{]}) \href{https://github.com/d3/d3-array/blob/master/src/mean.js}{\tt $<$$>$}

Returns the mean of the given {\itshape array} of numbers. If the array is empty, returns undefined. An optional {\itshape accessor} function may be specified, which is equivalent to calling {\itshape array}.map({\itshape accessor}) before computing the mean. This method ignores undefined and NaN values; this is useful for ignoring missing data.

\label{_median}%
\# d3.{\bfseries median}({\itshape array}\mbox{[}, {\itshape accessor}\mbox{]}) \href{https://github.com/d3/d3-array/blob/master/src/median.js}{\tt $<$$>$}

Returns the median of the given {\itshape array} of numbers using the \href{https://en.wikipedia.org/wiki/Quantile#Estimating_quantiles_from_a_sample}{\tt R-\/7 method}. If the array is empty, returns undefined. An optional {\itshape accessor} function may be specified, which is equivalent to calling {\itshape array}.map({\itshape accessor}) before computing the median. This method ignores undefined and NaN values; this is useful for ignoring missing data.

\label{_quantile}%
\# d3.{\bfseries quantile}({\itshape array}, {\itshape p}\mbox{[}, {\itshape accessor}\mbox{]}) \href{https://github.com/d3/d3-array/blob/master/src/quantile.js}{\tt $<$$>$}

Returns the {\itshape p}-\/quantile of the given {\bfseries sorted} {\itshape array} of numbers, where {\itshape p} is a number in the range \mbox{[}0, 1\mbox{]}. For example, the median can be computed using {\itshape p} = 0.\+5, the first quartile at {\itshape p} = 0.\+25, and the third quartile at {\itshape p} = 0.\+75. This particular implementation uses the \href{http://en.wikipedia.org/wiki/Quantile#Quantiles_of_a_population}{\tt R-\/7 method}, which is the default for the R programming language and Excel. For example\+:


\begin{DoxyCode}
var a = [0, 10, 30];
d3.quantile(a, 0); // 0
d3.quantile(a, 0.5); // 10
d3.quantile(a, 1); // 30
d3.quantile(a, 0.25); // 5
d3.quantile(a, 0.75); // 20
d3.quantile(a, 0.1); // 2
\end{DoxyCode}


An optional {\itshape accessor} function may be specified, which is equivalent to calling {\itshape array}.map({\itshape accessor}) before computing the quantile.

\label{_variance}%
\# d3.{\bfseries variance}({\itshape array}\mbox{[}, {\itshape accessor}\mbox{]}) \href{https://github.com/d3/d3-array/blob/master/src/variance.js}{\tt $<$$>$}

Returns an \href{http://mathworld.wolfram.com/SampleVariance.html}{\tt unbiased estimator of the population variance} of the given {\itshape array} of numbers. If the array has fewer than two values, returns undefined. An optional {\itshape accessor} function may be specified, which is equivalent to calling {\itshape array}.map({\itshape accessor}) before computing the variance. This method ignores undefined and NaN values; this is useful for ignoring missing data.

\label{_deviation}%
\# d3.{\bfseries deviation}({\itshape array}\mbox{[}, {\itshape accessor}\mbox{]}) \href{https://github.com/d3/d3-array/blob/master/src/deviation.js}{\tt $<$$>$}

Returns the standard deviation, defined as the square root of the \href{#variance}{\tt bias-\/corrected variance}, of the given {\itshape array} of numbers. If the array has fewer than two values, returns undefined. An optional {\itshape accessor} function may be specified, which is equivalent to calling {\itshape array}.map({\itshape accessor}) before computing the standard deviation. This method ignores undefined and NaN values; this is useful for ignoring missing data.

\subsubsection*{Search}

Methods for searching arrays for a specific element.

\label{_scan}%
\# d3.{\bfseries scan}({\itshape array}\mbox{[}, {\itshape comparator}\mbox{]}) \href{https://github.com/d3/d3-array/blob/master/src/scan.js}{\tt $<$$>$}

Performs a linear scan of the specified {\itshape array}, returning the index of the least element according to the specified {\itshape comparator}. If the given {\itshape array} contains no comparable elements ({\itshape i.\+e.}, the comparator returns NaN when comparing each element to itself), returns undefined. If {\itshape comparator} is not specified, it defaults to \href{#ascending}{\tt ascending}. For example\+:


\begin{DoxyCode}
var array = [\{foo: 42\}, \{foo: 91\}];
d3.scan(array, function(a, b) \{ return a.foo - b.foo; \}); // 0
d3.scan(array, function(a, b) \{ return b.foo - a.foo; \}); // 1
\end{DoxyCode}


This function is similar to \href{#min}{\tt min}, except it allows the use of a comparator rather than an accessor and it returns the index instead of the accessed value. See also \href{#bisect}{\tt bisect}.

\label{_bisectLeft}%
\# d3.{\bfseries bisect\+Left}({\itshape array}, {\itshape x}\mbox{[}, {\itshape lo}\mbox{[}, {\itshape hi}\mbox{]}\mbox{]}) \href{https://github.com/d3/d3-array/blob/master/src/bisect.js#L6}{\tt $<$$>$}

Returns the insertion point for {\itshape x} in {\itshape array} to maintain sorted order. The arguments {\itshape lo} and {\itshape hi} may be used to specify a subset of the array which should be considered; by default the entire array is used. If {\itshape x} is already present in {\itshape array}, the insertion point will be before (to the left of) any existing entries. The return value is suitable for use as the first argument to \href{https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/splice}{\tt splice} assuming that {\itshape array} is already sorted. The returned insertion point {\itshape i} partitions the {\itshape array} into two halves so that all {\itshape v} $<$ {\itshape x} for {\itshape v} in {\itshape array}.slice({\itshape lo}, {\itshape i}) for the left side and all {\itshape v} $>$= {\itshape x} for {\itshape v} in {\itshape array}.slice({\itshape i}, {\itshape hi}) for the right side.

\label{_bisect}%
\# d3.{\bfseries bisect}({\itshape array}, {\itshape x}\mbox{[}, {\itshape lo}\mbox{[}, {\itshape hi}\mbox{]}\mbox{]}) \href{https://github.com/d3/d3-array/blob/master/src/bisect.js}{\tt $<$$>$}~\newline
 \label{_bisectRight}%
\# d3.{\bfseries bisect\+Right}({\itshape array}, {\itshape x}\mbox{[}, {\itshape lo}\mbox{[}, {\itshape hi}\mbox{]}\mbox{]}) \href{https://github.com/d3/d3-array/blob/master/src/bisect.js#L6}{\tt $<$$>$}

Similar to \href{#bisectLeft}{\tt bisect\+Left}, but returns an insertion point which comes after (to the right of) any existing entries of {\itshape x} in {\itshape array}. The returned insertion point {\itshape i} partitions the {\itshape array} into two halves so that all {\itshape v} $<$= {\itshape x} for {\itshape v} in {\itshape array}.slice({\itshape lo}, {\itshape i}) for the left side and all {\itshape v} $>$ {\itshape x} for {\itshape v} in {\itshape array}.slice({\itshape i}, {\itshape hi}) for the right side.

\label{_bisector}%
\# d3.{\bfseries bisector}({\itshape accessor}) \href{https://github.com/d3/d3-array/blob/master/src/bisector.js}{\tt $<$$>$} ~\newline
\label{_bisector}%
\# d3.{\bfseries bisector}({\itshape comparator}) \href{https://github.com/d3/d3-array/blob/master/src/bisector.js}{\tt $<$$>$}

Returns a new bisector using the specified {\itshape accessor} or {\itshape comparator} function. This method can be used to bisect arrays of objects instead of being limited to simple arrays of primitives. For example, given the following array of objects\+:


\begin{DoxyCode}
var data = [
  \{date: new Date(2011, 1, 1), value: 0.5\},
  \{date: new Date(2011, 2, 1), value: 0.6\},
  \{date: new Date(2011, 3, 1), value: 0.7\},
  \{date: new Date(2011, 4, 1), value: 0.8\}
];
\end{DoxyCode}


A suitable bisect function could be constructed as\+:


\begin{DoxyCode}
var bisectDate = d3.bisector(function(d) \{ return d.date; \}).right;
\end{DoxyCode}


This is equivalent to specifying a comparator\+:


\begin{DoxyCode}
var bisectDate = d3.bisector(function(d, x) \{ return d.date - x; \}).right;
\end{DoxyCode}


And then applied as {\itshape bisect\+Date}({\itshape array}, {\itshape date}), returning an index. Note that the comparator is always passed the search value {\itshape x} as the second argument. Use a comparator rather than an accessor if you want values to be sorted in an order different than natural order, such as in descending rather than ascending order.

\label{_bisector_left}%
\# {\itshape bisector}.{\bfseries left}({\itshape array}, {\itshape x}\mbox{[}, {\itshape lo}\mbox{[}, {\itshape hi}\mbox{]}\mbox{]}) \href{https://github.com/d3/d3-array/blob/master/src/bisector.js#L6}{\tt $<$$>$}

Equivalent to \href{#bisectLeft}{\tt bisect\+Left}, but uses this bisector’s associated comparator.

\label{_bisector_right}%
\# {\itshape bisector}.{\bfseries right}({\itshape array}, {\itshape x}\mbox{[}, {\itshape lo}\mbox{[}, {\itshape hi}\mbox{]}\mbox{]}) \href{https://github.com/d3/d3-array/blob/master/src/bisector.js#L16}{\tt $<$$>$}

Equivalent to \href{#bisectRight}{\tt bisect\+Right}, but uses this bisector’s associated comparator.

\label{_ascending}%
\# d3.{\bfseries ascending}({\itshape a}, {\itshape b}) \href{https://github.com/d3/d3-array/blob/master/src/ascending.js}{\tt $<$$>$}

Returns -\/1 if {\itshape a} is less than {\itshape b}, or 1 if {\itshape a} is greater than {\itshape b}, or 0. This is the comparator function for natural order, and can be used in conjunction with the built-\/in \href{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort}{\tt {\itshape array}.sort} method to arrange elements in ascending order. It is implemented as\+:


\begin{DoxyCode}
function ascending(a, b) \{
  return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
\}
\end{DoxyCode}


Note that if no comparator function is specified to the built-\/in sort method, the default order is lexicographic (alphabetical), not natural! This can lead to surprising behavior when sorting an array of numbers.

\label{_descending}%
\# d3.{\bfseries descending}({\itshape a}, {\itshape b}) \href{https://github.com/d3/d3-array/blob/master/src/descending.js}{\tt $<$$>$}

Returns -\/1 if {\itshape a} is greater than {\itshape b}, or 1 if {\itshape a} is less than {\itshape b}, or 0. This is the comparator function for reverse natural order, and can be used in conjunction with the built-\/in array sort method to arrange elements in descending order. It is implemented as\+:


\begin{DoxyCode}
function descending(a, b) \{
  return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;
\}
\end{DoxyCode}


Note that if no comparator function is specified to the built-\/in sort method, the default order is lexicographic (alphabetical), not natural! This can lead to surprising behavior when sorting an array of numbers.

\subsubsection*{Transformations}

Methods for transforming arrays and for generating new arrays.

\label{_cross}%
\# d3.{\bfseries cross}({\itshape a}, {\itshape b}\mbox{[}, {\itshape reducer}\mbox{]}) \href{https://github.com/d3/d3-array/blob/master/src/cross.js}{\tt $<$$>$}

Returns the \href{https://en.wikipedia.org/wiki/Cartesian_product}{\tt Cartesian product} of the two arrays {\itshape a} and {\itshape b}. For each element {\itshape i} in the specified array {\itshape a} and each element {\itshape j} in the specified array {\itshape b}, in order, invokes the specified {\itshape reducer} function passing the element {\itshape i} and element {\itshape j}. If a {\itshape reducer} is not specified, it defaults to a function which creates a two-\/element array for each pair\+:


\begin{DoxyCode}
function pair(a, b) \{
  return [a, b];
\}
\end{DoxyCode}


For example\+:


\begin{DoxyCode}
d3.cross([1, 2], ["x", "y"]); // returns [[1, "x"], [1, "y"], [2, "x"], [2, "y"]]
d3.cross([1, 2], ["x", "y"], (a, b) => a + b); // returns ["1x", "1y", "2x", "2y"]
\end{DoxyCode}


\label{_merge}%
\# d3.{\bfseries merge}({\itshape arrays}) \href{https://github.com/d3/d3-array/blob/master/src/merge.js}{\tt $<$$>$}

Merges the specified {\itshape arrays} into a single array. This method is similar to the built-\/in array concat method; the only difference is that it is more convenient when you have an array of arrays.


\begin{DoxyCode}
d3.merge([[1], [2, 3]]); // returns [1, 2, 3]
\end{DoxyCode}


\label{_pairs}%
\# d3.{\bfseries pairs}({\itshape array}\mbox{[}, {\itshape reducer}\mbox{]}) \href{https://github.com/d3/d3-array/blob/master/src/pairs.js}{\tt $<$$>$}

For each adjacent pair of elements in the specified {\itshape array}, in order, invokes the specified {\itshape reducer} function passing the element {\itshape i} and element {\itshape i} -\/ 1. If a {\itshape reducer} is not specified, it defaults to a function which creates a two-\/element array for each pair\+:


\begin{DoxyCode}
function pair(a, b) \{
  return [a, b];
\}
\end{DoxyCode}


For example\+:


\begin{DoxyCode}
d3.pairs([1, 2, 3, 4]); // returns [[1, 2], [2, 3], [3, 4]]
d3.pairs([1, 2, 3, 4], (a, b) => b - a); // returns [1, 1, 1];
\end{DoxyCode}


If the specified array has fewer than two elements, returns the empty array.

\label{_permute}%
\# d3.{\bfseries permute}({\itshape array}, {\itshape indexes}) \href{https://github.com/d3/d3-array/blob/master/src/permute.js}{\tt $<$$>$}

Returns a permutation of the specified {\itshape array} using the specified array of {\itshape indexes}. The returned array contains the corresponding element in array for each index in indexes, in order. For example, permute(\mbox{[}\char`\"{}a\char`\"{}, \char`\"{}b\char`\"{}, \char`\"{}c\char`\"{}\mbox{]}, \mbox{[}1, 2, 0\mbox{]}) returns \mbox{[}\char`\"{}b\char`\"{}, \char`\"{}c\char`\"{}, \char`\"{}a\char`\"{}\mbox{]}. It is acceptable for the array of indexes to be a different length from the array of elements, and for indexes to be duplicated or omitted.

This method can also be used to extract the values from an object into an array with a stable order. Extracting keyed values in order can be useful for generating data arrays in nested selections. For example\+:


\begin{DoxyCode}
var object = \{yield: 27, variety: "Manchuria", year: 1931, site: "University Farm"\},
    fields = ["site", "variety", "yield"];

d3.permute(object, fields); // returns ["University Farm", "Manchuria", 27]
\end{DoxyCode}


\label{_shuffle}%
\# d3.{\bfseries shuffle}({\itshape array}\mbox{[}, {\itshape lo}\mbox{[}, {\itshape hi}\mbox{]}\mbox{]}) \href{https://github.com/d3/d3-array/blob/master/src/shuffle.js}{\tt $<$$>$}

Randomizes the order of the specified {\itshape array} using the \href{http://bost.ocks.org/mike/shuffle/}{\tt Fisher–\+Yates shuffle}.

\label{_ticks}%
\# d3.{\bfseries ticks}({\itshape start}, {\itshape stop}, {\itshape count}) \href{https://github.com/d3/d3-array/blob/master/src/ticks.js}{\tt $<$$>$}

Returns an array of approximately {\itshape count} + 1 uniformly-\/spaced, nicely-\/rounded values between {\itshape start} and {\itshape stop} (inclusive). Each value is a power of ten multiplied by 1, 2 or 5. See also \href{#tickIncrement}{\tt d3.\+tick\+Increment}, \href{#tickStep}{\tt d3.\+tick\+Step} and \href{https://github.com/d3/d3-scale/blob/master/README.md#linear_ticks}{\tt {\itshape linear}.ticks}.

Ticks are inclusive in the sense that they may include the specified {\itshape start} and {\itshape stop} values if (and only if) they are exact, nicely-\/rounded values consistent with the inferred \href{#tickStep}{\tt step}. More formally, each returned tick {\itshape t} satisfies {\itshape start} ≤ {\itshape t} and {\itshape t} ≤ {\itshape stop}.

\label{_tickIncrement}%
\# d3.{\bfseries tick\+Increment}({\itshape start}, {\itshape stop}, {\itshape count}) \href{https://github.com/d3/d3-array/blob/master/src/ticks.js#L16}{\tt $<$$>$}

Like \href{#tickStep}{\tt d3.\+tick\+Step}, except requires that {\itshape start} is always less than or equal to {\itshape step}, and if the tick step for the given {\itshape start}, {\itshape stop} and {\itshape count} would be less than one, returns the negative inverse tick step instead. This method is always guaranteed to return an integer, and is used by \href{#ticks}{\tt d3.\+ticks} to avoid guarantee that the returned tick values are represented as precisely as possible in I\+E\+EE 754 floating point.

\label{_tickStep}%
\# d3.{\bfseries tick\+Step}({\itshape start}, {\itshape stop}, {\itshape count}) \href{https://github.com/d3/d3-array/blob/master/src/ticks.js#L16}{\tt $<$$>$}

Returns the difference between adjacent tick values if the same arguments were passed to \href{#ticks}{\tt d3.\+ticks}\+: a nicely-\/rounded value that is a power of ten multiplied by 1, 2 or 5. Note that due to the limited precision of I\+E\+EE 754 floating point, the returned value may not be exact decimals; use \href{https://github.com/d3/d3-format}{\tt d3-\/format} to format numbers for human consumption.

\label{_range}%
\# d3.{\bfseries range}(\mbox{[}{\itshape start}, \mbox{]}{\itshape stop}\mbox{[}, {\itshape step}\mbox{]}) \href{https://github.com/d3/d3-array/blob/master/src/range.js}{\tt $<$$>$}

Returns an array containing an arithmetic progression, similar to the Python built-\/in \href{http://docs.python.org/library/functions.html#range}{\tt range}. This method is often used to iterate over a sequence of uniformly-\/spaced numeric values, such as the indexes of an array or the ticks of a linear scale. (See also \href{#ticks}{\tt d3.\+ticks} for nicely-\/rounded values.)

If {\itshape step} is omitted, it defaults to 1. If {\itshape start} is omitted, it defaults to 0. The {\itshape stop} value is exclusive; it is not included in the result. If {\itshape step} is positive, the last element is the largest {\itshape start} + {\itshape i} $\ast$ {\itshape step} less than {\itshape stop}; if {\itshape step} is negative, the last element is the smallest {\itshape start} + {\itshape i} $\ast$ {\itshape step} greater than {\itshape stop}. If the returned array would contain an infinite number of values, an empty range is returned.

The arguments are not required to be integers; however, the results are more predictable if they are. The values in the returned array are defined as {\itshape start} + {\itshape i} $\ast$ {\itshape step}, where {\itshape i} is an integer from zero to one minus the total number of elements in the returned array. For example\+:


\begin{DoxyCode}
d3.range(0, 1, 0.2) // [0, 0.2, 0.4, 0.6000000000000001, 0.8]
\end{DoxyCode}


This unexpected behavior is due to I\+E\+EE 754 double-\/precision floating point, which defines 0.\+2 $\ast$ 3 = 0.\+6000000000000001. Use \href{https://github.com/d3/d3-format}{\tt d3-\/format} to format numbers for human consumption with appropriate rounding; see also \href{https://github.com/d3/d3-scale/blob/master/README.md#linear_tickFormat}{\tt linear.\+tick\+Format} in \href{https://github.com/d3/d3-scale}{\tt d3-\/scale}.

Likewise, if the returned array should have a specific length, consider using \href{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map}{\tt array.\+map} on an integer range. For example\+:


\begin{DoxyCode}
d3.range(0, 1, 1 / 49); // BAD: returns 50 elements!
d3.range(49).map(function(d) \{ return d / 49; \}); // GOOD: returns 49 elements.
\end{DoxyCode}


\label{_transpose}%
\# d3.{\bfseries transpose}({\itshape matrix}) \href{https://github.com/d3/d3-array/blob/master/src/transpose.js}{\tt $<$$>$}

Uses the \href{#zip}{\tt zip} operator as a two-\/dimensional \href{http://en.wikipedia.org/wiki/Transpose}{\tt matrix transpose}.

\label{_zip}%
\# d3.{\bfseries zip}({\itshape arrays…}) \href{https://github.com/d3/d3-array/blob/master/src/zip.js}{\tt $<$$>$}

Returns an array of arrays, where the {\itshape i$\ast$th array contains the $\ast$i$\ast$th element from each of the argument $\ast$arrays}. The returned array is truncated in length to the shortest array in {\itshape arrays}. If {\itshape arrays} contains only a single array, the returned array contains one-\/element arrays. With no arguments, the returned array is empty.


\begin{DoxyCode}
d3.zip([1, 2], [3, 4]); // returns [[1, 3], [2, 4]]
\end{DoxyCode}


\subsubsection*{Histograms}

\href{http://bl.ocks.org/mbostock/3048450}{\tt }

Histograms bin many discrete samples into a smaller number of consecutive, non-\/overlapping intervals. They are often used to visualize the distribution of numerical data.

\label{_histogram}%
\# d3.{\bfseries histogram}() \href{https://github.com/d3/d3-array/blob/master/src/histogram.js}{\tt $<$$>$}

Constructs a new histogram generator with the default settings.

\label{__histogram}%
\# {\itshape histogram}({\itshape data}) \href{https://github.com/d3/d3-array/blob/master/src/histogram.js#L14}{\tt $<$$>$}

Computes the histogram for the given array of {\itshape data} samples. Returns an array of bins, where each bin is an array containing the associated elements from the input {\itshape data}. Thus, the {\ttfamily length} of the bin is the number of elements in that bin. Each bin has two additional attributes\+:


\begin{DoxyItemize}
\item {\ttfamily x0} -\/ the lower bound of the bin (inclusive).
\item {\ttfamily x1} -\/ the upper bound of the bin (exclusive, except for the last bin).
\end{DoxyItemize}

\label{_histogram_value}%
\# {\itshape histogram}.{\bfseries value}(\mbox{[}{\itshape value}\mbox{]}) \href{https://github.com/d3/d3-array/blob/master/src/histogram.js#L58}{\tt $<$$>$}

If {\itshape value} is specified, sets the value accessor to the specified function or constant and returns this histogram generator. If {\itshape value} is not specified, returns the current value accessor, which defaults to the identity function.

When a histogram is \href{#_histogram}{\tt generated}, the value accessor will be invoked for each element in the input data array, being passed the element {\ttfamily d}, the index {\ttfamily i}, and the array {\ttfamily data} as three arguments. The default value accessor assumes that the input data are orderable (comparable), such as numbers or dates. If your data are not, then you should specify an accessor that returns the corresponding orderable value for a given datum.

This is similar to mapping your data to values before invoking the histogram generator, but has the benefit that the input data remains associated with the returned bins, thereby making it easier to access other fields of the data.

\label{_histogram_domain}%
\# {\itshape histogram}.{\bfseries domain}(\mbox{[}{\itshape domain}\mbox{]}) \href{https://github.com/d3/d3-array/blob/master/src/histogram.js#L62}{\tt $<$$>$}

If {\itshape domain} is specified, sets the domain accessor to the specified function or array and returns this histogram generator. If {\itshape domain} is not specified, returns the current domain accessor, which defaults to \href{#extent}{\tt extent}. The histogram domain is defined as an array \mbox{[}{\itshape min}, {\itshape max}\mbox{]}, where {\itshape min} is the minimum observable value and {\itshape max} is the maximum observable value; both values are inclusive. Any value outside of this domain will be ignored when the histogram is \href{#_histogram}{\tt generated}.

For example, if you are using the the histogram in conjunction with a \href{https://github.com/d3/d3-scale/blob/master/README.md#linear-scales}{\tt linear scale} {\ttfamily x}, you might say\+:


\begin{DoxyCode}
var histogram = d3.histogram()
    .domain(x.domain())
    .thresholds(x.ticks(20));
\end{DoxyCode}


You can then compute the bins from an array of numbers like so\+:


\begin{DoxyCode}
var bins = histogram(numbers);
\end{DoxyCode}


Note that the domain accessor is invoked on the materialized array of \href{#histogram_value}{\tt values}, not on the input data array.

\label{_histogram_thresholds}%
\# {\itshape histogram}.{\bfseries thresholds}(\mbox{[}{\itshape count}\mbox{]}) \href{https://github.com/d3/d3-array/blob/master/src/histogram.js#L66}{\tt $<$$>$} ~\newline
\label{_histogram_thresholds}%
\# {\itshape histogram}.{\bfseries thresholds}(\mbox{[}{\itshape thresholds}\mbox{]}) \href{https://github.com/d3/d3-array/blob/master/src/histogram.js#L66}{\tt $<$$>$}

If {\itshape thresholds} is specified, sets the \href{#histogram-thresholds}{\tt threshold generator} to the specified function or array and returns this histogram generator. If {\itshape thresholds} is not specified, returns the current threshold generator, which by default implements \href{#thresholdSturges}{\tt Sturges’ formula}. (Thus by default, the histogram values must be numbers!) Thresholds are defined as an array of values \mbox{[}{\itshape x0}, {\itshape x1}, …\mbox{]}. Any value less than {\itshape x0} will be placed in the first bin; any value greater than or equal to {\itshape x0} but less than {\itshape x1} will be placed in the second bin; and so on. Thus, the \href{#_histogram}{\tt generated histogram} will have {\itshape thresholds}.length + 1 bins. See \href{#histogram-thresholds}{\tt histogram thresholds} for more information.

Any threshold values outside the \href{#histogram_domain}{\tt domain} are ignored. The first {\itshape bin}.x0 is always equal to the minimum domain value, and the last {\itshape bin}.x1 is always equal to the maximum domain value.

If a {\itshape count} is specified instead of an array of {\itshape thresholds}, then the \href{#histogram_domain}{\tt domain} will be uniformly divided into approximately {\itshape count} bins; see \href{#ticks}{\tt ticks}.

\subsubsection*{Histogram Thresholds}

These functions are typically not used directly; instead, pass them to \href{#histogram_thresholds}{\tt {\itshape histogram}.thresholds}. You may also implement your own threshold generator taking three arguments\+: the array of input \href{#histogram_value}{\tt {\itshape values}} derived from the data, and the \href{#histogram_domain}{\tt observable domain} represented as {\itshape min} and {\itshape max}. The generator may then return either the array of numeric thresholds or the {\itshape count} of bins; in the latter case the domain is divided uniformly into approximately {\itshape count} bins; see \href{#ticks}{\tt ticks}.

\label{_thresholdFreedmanDiaconis}%
\# d3.{\bfseries threshold\+Freedman\+Diaconis}({\itshape values}, {\itshape min}, {\itshape max}) \href{https://github.com/d3/d3-array/blob/master/src/threshold/freedmanDiaconis.js}{\tt $<$$>$}

Returns the number of bins according to the \href{https://en.wikipedia.org/wiki/Histogram#Mathematical_definition}{\tt Freedman–\+Diaconis rule}; the input {\itshape values} must be numbers.

\label{_thresholdScott}%
\# d3.{\bfseries threshold\+Scott}({\itshape values}, {\itshape min}, {\itshape max}) \href{https://github.com/d3/d3-array/blob/master/src/threshold/scott.js}{\tt $<$$>$}

Returns the number of bins according to \href{https://en.wikipedia.org/wiki/Histogram#Mathematical_definition}{\tt Scott’s normal reference rule}; the input {\itshape values} must be numbers.

\label{_thresholdSturges}%
\# d3.{\bfseries threshold\+Sturges}({\itshape values}) \href{https://github.com/d3/d3-array/blob/master/src/threshold/sturges.js}{\tt $<$$>$}

Returns the number of bins according to \href{https://en.wikipedia.org/wiki/Histogram#Mathematical_definition}{\tt Sturges’ formula}; the input {\itshape values} must be numbers. 