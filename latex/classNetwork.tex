\hypertarget{classNetwork}{}\section{Network Class Reference}
\label{classNetwork}\index{Network@{Network}}
Inheritance diagram for Network\+:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=3.000000cm]{classNetwork}
\end{center}
\end{figure}
\subsection*{Public Types}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{classNetwork_abde5619c679349a346350d7c703ef0fb}\label{classNetwork_abde5619c679349a346350d7c703ef0fb}} 
typedef std\+::map$<$ unsigned int, std\+::map$<$ unsigned int, double $>$ $>$ {\bfseries Link\+Map}
\end{DoxyCompactItemize}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{classNetwork_a3b0508eeaf582f7dd2f0b1a2a13ce450}\label{classNetwork_a3b0508eeaf582f7dd2f0b1a2a13ce450}} 
{\bfseries Network} (const \mbox{\hyperlink{structConfig}{Config}} \&config)
\item 
\mbox{\Hypertarget{classNetwork_a9c725e5f622a1720e3b3c66d93b0ad9d}\label{classNetwork_a9c725e5f622a1720e3b3c66d93b0ad9d}} 
{\bfseries Network} (const \mbox{\hyperlink{classNetwork}{Network}} \&other)
\item 
\mbox{\Hypertarget{classNetwork_ad2a7d8b707e10e925b56e3e66fda5122}\label{classNetwork_ad2a7d8b707e10e925b56e3e66fda5122}} 
\mbox{\hyperlink{classNetwork}{Network}} \& {\bfseries operator=} (const \mbox{\hyperlink{classNetwork}{Network}} \&other)
\item 
\mbox{\Hypertarget{classNetwork_a0ca91774ee60af9aa81cb5de33cc948f}\label{classNetwork_a0ca91774ee60af9aa81cb5de33cc948f}} 
void {\bfseries set\+Config} (const \mbox{\hyperlink{structConfig}{Config}} \&config)
\item 
\mbox{\Hypertarget{classNetwork_aafccd84af6d788277c2f24654d9516c3}\label{classNetwork_aafccd84af6d788277c2f24654d9516c3}} 
virtual void {\bfseries read\+Input\+Data} (std\+::string filename=\char`\"{}\char`\"{})
\item 
\mbox{\Hypertarget{classNetwork_a260ae396166c4c241494dc30924c3b9d}\label{classNetwork_a260ae396166c4c241494dc30924c3b9d}} 
unsigned int {\bfseries add\+Nodes} (const std\+::vector$<$ std\+::string $>$ \&names)
\item 
\mbox{\Hypertarget{classNetwork_a3cca2d066f46f2ddf995d813b9239d95}\label{classNetwork_a3cca2d066f46f2ddf995d813b9239d95}} 
bool {\bfseries add\+Node} (unsigned int node\+Index)
\item 
bool \mbox{\hyperlink{classNetwork_a234269b2addadc7c79f8c0cc43b0b960}{add\+Link}} (unsigned int n1, unsigned int n2, double weight=1.\+0)
\item 
\mbox{\Hypertarget{classNetwork_a548fca981d51677d90d447cdbf9468d4}\label{classNetwork_a548fca981d51677d90d447cdbf9468d4}} 
bool {\bfseries add\+Bipartite\+Link} (unsigned int n1, unsigned int n2, double weight=1.\+0)
\item 
\mbox{\Hypertarget{classNetwork_a7e22b758aa97e5031f1af043572bfd00}\label{classNetwork_a7e22b758aa97e5031f1af043572bfd00}} 
bool {\bfseries add\+Bipartite\+Link} (unsigned int feature\+Node, unsigned int \mbox{\hyperlink{structnode}{node}}, bool swap\+Order, double weight=1.\+0)
\item 
void \mbox{\hyperlink{classNetwork_a7ebe3a5e948fc60e81fb94df08ca4358}{set\+Bipartite\+Nodes\+From}} (unsigned int bipartite\+Start\+Index)
\item 
void \mbox{\hyperlink{classNetwork_ac2e5a12947f9983b6193d593ec329a5f}{finalize\+And\+Check\+Network}} (bool print\+Summary=true, unsigned int desired\+Number\+Of\+Nodes=0)
\item 
\mbox{\Hypertarget{classNetwork_abba53293f1ec45c5e701427e106a8ae4}\label{classNetwork_abba53293f1ec45c5e701427e106a8ae4}} 
void {\bfseries print\+Parsing\+Result} (bool only\+Summary=false)
\item 
\mbox{\Hypertarget{classNetwork_aa469da1457cd376313eac5e30cb16b95}\label{classNetwork_aa469da1457cd376313eac5e30cb16b95}} 
std\+::string {\bfseries get\+Parsing\+Result\+Summary} ()
\item 
\mbox{\Hypertarget{classNetwork_abf286e55a24a445669b5b08ffbc76951}\label{classNetwork_abf286e55a24a445669b5b08ffbc76951}} 
virtual void {\bfseries print\+Network\+As\+Pajek} (std\+::string filename) const
\item 
\mbox{\Hypertarget{classNetwork_a59cc353c1629bbf374db045d19ebd4f1}\label{classNetwork_a59cc353c1629bbf374db045d19ebd4f1}} 
virtual void {\bfseries print\+State\+Network} (std\+::string filename) const
\item 
\mbox{\Hypertarget{classNetwork_ab4585dd1f2500f16d729096878228942}\label{classNetwork_ab4585dd1f2500f16d729096878228942}} 
unsigned int {\bfseries num\+Nodes} () const
\item 
\mbox{\Hypertarget{classNetwork_a21976797f095a6de32ee40b6c7e39fe6}\label{classNetwork_a21976797f095a6de32ee40b6c7e39fe6}} 
const std\+::vector$<$ std\+::string $>$ \& {\bfseries node\+Names} () const
\item 
\mbox{\Hypertarget{classNetwork_a169fbca9d6d0bf7be4afcef36906d197}\label{classNetwork_a169fbca9d6d0bf7be4afcef36906d197}} 
const std\+::vector$<$ double $>$ \& {\bfseries node\+Weights} () const
\item 
\mbox{\Hypertarget{classNetwork_a70506aeb202e073077967e9090fc7c70}\label{classNetwork_a70506aeb202e073077967e9090fc7c70}} 
double {\bfseries sum\+Node\+Weights} () const
\item 
\mbox{\Hypertarget{classNetwork_a96d7528557fc09561891eeda76499063}\label{classNetwork_a96d7528557fc09561891eeda76499063}} 
const std\+::vector$<$ double $>$ \& {\bfseries out\+Degree} () const
\item 
\mbox{\Hypertarget{classNetwork_aad0c228dcbdb36d0bd14ca518bab268b}\label{classNetwork_aad0c228dcbdb36d0bd14ca518bab268b}} 
const std\+::vector$<$ double $>$ \& {\bfseries sum\+Link\+Out\+Weight} () const
\item 
\mbox{\Hypertarget{classNetwork_aed19d67bf781dc9f8d2420111c1160b6}\label{classNetwork_aed19d67bf781dc9f8d2420111c1160b6}} 
bool {\bfseries have\+Node} (unsigned int node\+Index) const
\item 
\mbox{\Hypertarget{classNetwork_a13284a11be1a37744f1c8014f940cd35}\label{classNetwork_a13284a11be1a37744f1c8014f940cd35}} 
const Link\+Map \& {\bfseries link\+Map} () const
\item 
\mbox{\Hypertarget{classNetwork_ae88d213dc2567782a7c32b2d7649f465}\label{classNetwork_ae88d213dc2567782a7c32b2d7649f465}} 
unsigned int {\bfseries num\+Links} () const
\item 
\mbox{\Hypertarget{classNetwork_a8c0e2b1a5f11881052da39e53c4dce8c}\label{classNetwork_a8c0e2b1a5f11881052da39e53c4dce8c}} 
double {\bfseries total\+Link\+Weight} () const
\item 
\mbox{\Hypertarget{classNetwork_a8e9a8b0aa41a75037868cf05af24e5c7}\label{classNetwork_a8e9a8b0aa41a75037868cf05af24e5c7}} 
double {\bfseries total\+Self\+Link\+Weight} () const
\item 
\mbox{\Hypertarget{classNetwork_ae605ef1109ddf7f13dcd94b1f03a4a68}\label{classNetwork_ae605ef1109ddf7f13dcd94b1f03a4a68}} 
bool {\bfseries is\+Bipartite} () const
\item 
\mbox{\Hypertarget{classNetwork_a99580240387afa26f4c4f8eab12d2122}\label{classNetwork_a99580240387afa26f4c4f8eab12d2122}} 
unsigned int {\bfseries num\+Bipartite\+Nodes} () const
\item 
\mbox{\Hypertarget{classNetwork_afa36b11b8e6ae0f7e123f299a5c18dd6}\label{classNetwork_afa36b11b8e6ae0f7e123f299a5c18dd6}} 
void {\bfseries init\+Node\+Names} ()
\item 
\mbox{\Hypertarget{classNetwork_a48972511b804b9f3e24e5acef580d149}\label{classNetwork_a48972511b804b9f3e24e5acef580d149}} 
void {\bfseries swap\+Node\+Names} (std\+::vector$<$ std\+::string $>$ \&target)
\item 
\mbox{\Hypertarget{classNetwork_a202d38d6cbd9f06cbd9cdddec14c7680}\label{classNetwork_a202d38d6cbd9f06cbd9cdddec14c7680}} 
void {\bfseries generate\+Opposite\+Link\+Map} (Link\+Map \&opposite\+Links)
\item 
\mbox{\Hypertarget{classNetwork_a608f4113f8e7558bcf7a7991b9c61f18}\label{classNetwork_a608f4113f8e7558bcf7a7991b9c61f18}} 
virtual void {\bfseries dispose\+Links} ()
\item 
\mbox{\Hypertarget{classNetwork_a47390453870914536a44d2404e0b9b85}\label{classNetwork_a47390453870914536a44d2404e0b9b85}} 
const \mbox{\hyperlink{structConfig}{Config}} \& {\bfseries config} ()
\item 
\mbox{\Hypertarget{classNetwork_a93b6b65d803d62bd019e830fc1d074a7}\label{classNetwork_a93b6b65d803d62bd019e830fc1d074a7}} 
bool {\bfseries is\+Finalized} ()
\end{DoxyCompactItemize}
\subsection*{Protected Member Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{classNetwork_a0ac4e9ce5d7fc30ded0b85792e3b0da5}\label{classNetwork_a0ac4e9ce5d7fc30ded0b85792e3b0da5}} 
void {\bfseries parse\+Pajek\+Network} (std\+::string filename)
\item 
\mbox{\Hypertarget{classNetwork_aa0dcaf8e7724f3f18bc163e6024faa96}\label{classNetwork_aa0dcaf8e7724f3f18bc163e6024faa96}} 
void {\bfseries parse\+Link\+List} (std\+::string filename)
\item 
\mbox{\Hypertarget{classNetwork_ae503c3447d73184ca5a29bc93be66d31}\label{classNetwork_ae503c3447d73184ca5a29bc93be66d31}} 
void {\bfseries parse\+Sparse\+Link\+List} (std\+::string filename)
\item 
\mbox{\Hypertarget{classNetwork_a4eb401b096fb37813afb56c150301be2}\label{classNetwork_a4eb401b096fb37813afb56c150301be2}} 
void {\bfseries parse\+Pajek\+Network\+Without\+I\+O\+Streams} (std\+::string filename)
\item 
\mbox{\Hypertarget{classNetwork_a56904b5b0171dc6d61be8900b2e7bcbd}\label{classNetwork_a56904b5b0171dc6d61be8900b2e7bcbd}} 
void {\bfseries parse\+Link\+List\+Without\+I\+O\+Streams} (std\+::string filename)
\item 
\mbox{\Hypertarget{classNetwork_a641c8ebdfeb4f1db5102624fb46cd6b1}\label{classNetwork_a641c8ebdfeb4f1db5102624fb46cd6b1}} 
void {\bfseries parse\+General\+Network} (std\+::string filename)
\item 
\mbox{\Hypertarget{classNetwork_a47aeb2ec640e9d27dcff357711a704ee}\label{classNetwork_a47aeb2ec640e9d27dcff357711a704ee}} 
void {\bfseries parse\+Bipartite\+Network} (std\+::string filename)
\item 
\mbox{\Hypertarget{classNetwork_aeedd55311935f1f4b7f7b0c523b46a6b}\label{classNetwork_aeedd55311935f1f4b7f7b0c523b46a6b}} 
void {\bfseries zoom} ()
\item 
\mbox{\Hypertarget{classNetwork_a8cec3dfb346c1e29a48704ec32dedf9c}\label{classNetwork_a8cec3dfb346c1e29a48704ec32dedf9c}} 
std\+::string {\bfseries parse\+Links} (std\+::ifstream \&file)
\item 
\mbox{\Hypertarget{classNetwork_a00c9f0be21dfae4626b7e0f36ae30618}\label{classNetwork_a00c9f0be21dfae4626b7e0f36ae30618}} 
std\+::string {\bfseries parse\+Bipartite\+Links} (std\+::ifstream \&file)
\item 
void \mbox{\hyperlink{classNetwork_a06e77b2e70073abda5ef39bdb2e0680a}{parse\+Link}} (const std\+::string \&line, unsigned int \&n1, unsigned int \&n2, double \&weight)
\item 
\mbox{\Hypertarget{classNetwork_a507153c3021412d7d4484b02cd5eeac2}\label{classNetwork_a507153c3021412d7d4484b02cd5eeac2}} 
void {\bfseries parse\+Link} (char line\mbox{[}$\,$\mbox{]}, unsigned int \&n1, unsigned int \&n2, double \&weight)
\item 
bool \mbox{\hyperlink{classNetwork_a73f3d0596eabc17748ce76ef276317d3}{parse\+Bipartite\+Link}} (const std\+::string \&line, unsigned int \&feature\+Node, unsigned int \&\mbox{\hyperlink{structnode}{node}}, double \&weight)
\item 
bool \mbox{\hyperlink{classNetwork_ace5fa3249715ed1b840fa733976aa57b}{insert\+Link}} (unsigned int n1, unsigned int n2, double weight)
\item 
bool \mbox{\hyperlink{classNetwork_a121d0db867b29c99e6e95ef960fcd56f}{insert\+Node}} (unsigned int node\+Index)
\item 
\mbox{\Hypertarget{classNetwork_a67a802002ffc608d226d65b9f68b651e}\label{classNetwork_a67a802002ffc608d226d65b9f68b651e}} 
virtual void {\bfseries init\+Node\+Degrees} ()
\item 
std\+::string \mbox{\hyperlink{classNetwork_afd458fbfc07fc12e8ca3d6ec4e6a7291}{skip\+Until\+Header}} (std\+::ifstream \&file)
\item 
std\+::string \mbox{\hyperlink{classNetwork_a57b99ecccedc6200838163fa3b1ad252}{parse\+Vertices}} (std\+::ifstream \&file, bool required=true)
\item 
std\+::string \mbox{\hyperlink{classNetwork_a5cec6b6daa66f112a70bc97c9c28fbc0}{parse\+Vertices}} (std\+::ifstream \&file, std\+::string heading, bool required=true)
\end{DoxyCompactItemize}
\subsection*{Protected Attributes}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{classNetwork_a4e804bbdb49f3d6b61424da9d2631668}\label{classNetwork_a4e804bbdb49f3d6b61424da9d2631668}} 
\mbox{\hyperlink{structConfig}{Config}} {\bfseries m\+\_\+config}
\item 
\mbox{\Hypertarget{classNetwork_a6b78eccd117b8dad6b09cccec682a4d8}\label{classNetwork_a6b78eccd117b8dad6b09cccec682a4d8}} 
unsigned int {\bfseries m\+\_\+num\+Nodes\+Found}
\item 
\mbox{\Hypertarget{classNetwork_ae539ca2af09a33f50a645862f3d45066}\label{classNetwork_ae539ca2af09a33f50a645862f3d45066}} 
unsigned int {\bfseries m\+\_\+num\+Nodes}
\item 
\mbox{\Hypertarget{classNetwork_a889a68a5d059237119d6fea176b56da8}\label{classNetwork_a889a68a5d059237119d6fea176b56da8}} 
std\+::vector$<$ std\+::string $>$ {\bfseries m\+\_\+node\+Names}
\item 
\mbox{\Hypertarget{classNetwork_ac00cd6865db2dce075af1e46df45cefc}\label{classNetwork_ac00cd6865db2dce075af1e46df45cefc}} 
std\+::vector$<$ double $>$ {\bfseries m\+\_\+node\+Weights}
\item 
\mbox{\Hypertarget{classNetwork_a10f2a6a98453c5e3a8aaadbfdbd7f99d}\label{classNetwork_a10f2a6a98453c5e3a8aaadbfdbd7f99d}} 
double {\bfseries m\+\_\+sum\+Node\+Weights}
\item 
\mbox{\Hypertarget{classNetwork_adbb0d2ba1256d2059c9d33b695a7656a}\label{classNetwork_adbb0d2ba1256d2059c9d33b695a7656a}} 
std\+::vector$<$ double $>$ {\bfseries m\+\_\+out\+Degree}
\item 
\mbox{\Hypertarget{classNetwork_a9b7d73fd01e7c6f99365cd4e0fe56ba0}\label{classNetwork_a9b7d73fd01e7c6f99365cd4e0fe56ba0}} 
std\+::vector$<$ double $>$ {\bfseries m\+\_\+sum\+Link\+Out\+Weight}
\item 
\mbox{\Hypertarget{classNetwork_a01a423d5d1bb3d5d76121394b54f1597}\label{classNetwork_a01a423d5d1bb3d5d76121394b54f1597}} 
unsigned int {\bfseries m\+\_\+num\+Dangling\+Nodes}
\item 
\mbox{\Hypertarget{classNetwork_aa1bcf1f8cdee488a9d081a05b5fb40ea}\label{classNetwork_aa1bcf1f8cdee488a9d081a05b5fb40ea}} 
std\+::set$<$ unsigned int $>$ {\bfseries m\+\_\+nodes}
\item 
\mbox{\Hypertarget{classNetwork_a405b5ada50d270ae69d1db7fd276406a}\label{classNetwork_a405b5ada50d270ae69d1db7fd276406a}} 
Link\+Map {\bfseries m\+\_\+links}
\item 
\mbox{\Hypertarget{classNetwork_ab7c780d54802ce7e157809aa8845b987}\label{classNetwork_ab7c780d54802ce7e157809aa8845b987}} 
unsigned int {\bfseries m\+\_\+num\+Links\+Found}
\item 
\mbox{\Hypertarget{classNetwork_a36519dd304e83f04ecb94acf4fcd5c94}\label{classNetwork_a36519dd304e83f04ecb94acf4fcd5c94}} 
unsigned int {\bfseries m\+\_\+num\+Links}
\item 
\mbox{\Hypertarget{classNetwork_a9318381e49235c2e97e4712a48558f4b}\label{classNetwork_a9318381e49235c2e97e4712a48558f4b}} 
double {\bfseries m\+\_\+total\+Link\+Weight}
\item 
\mbox{\Hypertarget{classNetwork_ae75baccb62375113dfdfbfeb4632c9d8}\label{classNetwork_ae75baccb62375113dfdfbfeb4632c9d8}} 
unsigned int {\bfseries m\+\_\+num\+Aggregated\+Links}
\item 
\mbox{\Hypertarget{classNetwork_add43682b04697124c2037a877c75569e}\label{classNetwork_add43682b04697124c2037a877c75569e}} 
unsigned int {\bfseries m\+\_\+num\+Self\+Links}
\item 
\mbox{\Hypertarget{classNetwork_a5a261b839d65cc6f451b89331b81cfe4}\label{classNetwork_a5a261b839d65cc6f451b89331b81cfe4}} 
unsigned int {\bfseries m\+\_\+num\+Self\+Links\+Found}
\item 
\mbox{\Hypertarget{classNetwork_aefa3790d78ab7b69a0bdb764d3e832ed}\label{classNetwork_aefa3790d78ab7b69a0bdb764d3e832ed}} 
double {\bfseries m\+\_\+total\+Self\+Link\+Weight}
\item 
\mbox{\Hypertarget{classNetwork_a57fbd8f3f1b0d134a978a75284a1f415}\label{classNetwork_a57fbd8f3f1b0d134a978a75284a1f415}} 
unsigned int {\bfseries m\+\_\+num\+Links\+Ignored\+By\+Weight\+Threshold}
\item 
\mbox{\Hypertarget{classNetwork_a709c9d7e3a4d27bfe4ac20ce322ef8e9}\label{classNetwork_a709c9d7e3a4d27bfe4ac20ce322ef8e9}} 
double {\bfseries m\+\_\+total\+Link\+Weight\+Ignored}
\item 
\mbox{\Hypertarget{classNetwork_ab76c0603719b376a0ea1ed7653725bc6}\label{classNetwork_ab76c0603719b376a0ea1ed7653725bc6}} 
bool {\bfseries m\+\_\+add\+Self\+Links}
\item 
\mbox{\Hypertarget{classNetwork_a56f2ad06a21236bfdbd0c97cacbfbefa}\label{classNetwork_a56f2ad06a21236bfdbd0c97cacbfbefa}} 
unsigned int {\bfseries m\+\_\+num\+Additional\+Links}
\item 
\mbox{\Hypertarget{classNetwork_a4bc3ebc1347d25d3ea6d81d858d7b670}\label{classNetwork_a4bc3ebc1347d25d3ea6d81d858d7b670}} 
unsigned int {\bfseries m\+\_\+sum\+Additional\+Link\+Weight}
\item 
\mbox{\Hypertarget{classNetwork_a5de3bef1bba7450b72a17f556aaaa1b4}\label{classNetwork_a5de3bef1bba7450b72a17f556aaaa1b4}} 
unsigned int {\bfseries m\+\_\+max\+Node\+Index}
\item 
\mbox{\Hypertarget{classNetwork_a39c79f64f435a5ee02ebd6585d7658fe}\label{classNetwork_a39c79f64f435a5ee02ebd6585d7658fe}} 
unsigned int {\bfseries m\+\_\+min\+Node\+Index}
\item 
\mbox{\Hypertarget{classNetwork_a3233fe41d3c488944b724c125549480a}\label{classNetwork_a3233fe41d3c488944b724c125549480a}} 
unsigned int {\bfseries m\+\_\+min\+Feature\+Index}
\item 
\mbox{\Hypertarget{classNetwork_a2597b393fbfad6333d51ed9f6464ea93}\label{classNetwork_a2597b393fbfad6333d51ed9f6464ea93}} 
unsigned int {\bfseries m\+\_\+bipartite\+Start\+Index}
\item 
\mbox{\Hypertarget{classNetwork_a6c09a5df251f92e45420a852ff0408a5}\label{classNetwork_a6c09a5df251f92e45420a852ff0408a5}} 
std\+::istringstream {\bfseries m\+\_\+extractor}
\item 
\mbox{\Hypertarget{classNetwork_a9576e46072b091e3a97d4e5303512e72}\label{classNetwork_a9576e46072b091e3a97d4e5303512e72}} 
unsigned int {\bfseries m\+\_\+index\+Offset}
\item 
\mbox{\Hypertarget{classNetwork_a0889972bee522f5b3a8f39fc0769f29f}\label{classNetwork_a0889972bee522f5b3a8f39fc0769f29f}} 
std\+::map$<$ \mbox{\hyperlink{structBipartiteLink}{Bipartite\+Link}}, \mbox{\hyperlink{structWeight}{Weight}} $>$ {\bfseries m\+\_\+bipartite\+Links}
\item 
\mbox{\Hypertarget{classNetwork_a088ea8185bc99389e16725dc405a483f}\label{classNetwork_a088ea8185bc99389e16725dc405a483f}} 
unsigned int {\bfseries m\+\_\+num\+Bipartite\+Nodes}
\item 
\mbox{\Hypertarget{classNetwork_a7536a6430df2349c3b3775bd4407be96}\label{classNetwork_a7536a6430df2349c3b3775bd4407be96}} 
bool {\bfseries m\+\_\+is\+Finalized}
\end{DoxyCompactItemize}


\subsection{Member Function Documentation}
\mbox{\Hypertarget{classNetwork_a234269b2addadc7c79f8c0cc43b0b960}\label{classNetwork_a234269b2addadc7c79f8c0cc43b0b960}} 
\index{Network@{Network}!add\+Link@{add\+Link}}
\index{add\+Link@{add\+Link}!Network@{Network}}
\subsubsection{\texorpdfstring{add\+Link()}{addLink()}}
{\footnotesize\ttfamily bool Network\+::add\+Link (\begin{DoxyParamCaption}\item[{unsigned int}]{n1,  }\item[{unsigned int}]{n2,  }\item[{double}]{weight = {\ttfamily 1.0} }\end{DoxyParamCaption})}

Add a weighted link between two nodes. \begin{DoxyReturn}{Returns}
true if a new link was inserted, false if skipped due to cutoff limit or aggregated to existing link 
\end{DoxyReturn}

\begin{DoxyCode}
643 \{
644     \textcolor{keywordflow}{if} (isBipartite()) \{
645         \textcolor{keywordflow}{return} addBipartiteLink(n1, n2, weight);
646     \}
647     ++m\_numLinksFound;
648 
649     \textcolor{keywordflow}{if} (m\_config.nodeLimit > 0 && (n1 >= m\_config.nodeLimit || n2 >= m\_config.nodeLimit))
650         \textcolor{keywordflow}{return} \textcolor{keyword}{false};
651     
652     \textcolor{keywordflow}{if} (weight < m\_config.weightThreshold) \{
653         ++m\_numLinksIgnoredByWeightThreshold;
654         m\_totalLinkWeightIgnored += weight;
655         \textcolor{keywordflow}{return} \textcolor{keyword}{false};
656     \}
657 
658     \textcolor{keywordflow}{if} (n2 == n1)
659     \{
660         ++m\_numSelfLinksFound;
661         \textcolor{keywordflow}{if} (!m\_config.includeSelfLinks)
662             \textcolor{keywordflow}{return} \textcolor{keyword}{false};
663         ++m\_numSelfLinks;
664         m\_totalSelfLinkWeight += weight;
665     \}
666     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (m\_config.parseAsUndirected() && n2 < n1) \textcolor{comment}{// minimize number of links}
667         std::swap(n1, n2);
668 
669     m\_maxNodeIndex = std::max(m\_maxNodeIndex, std::max(n1, n2));
670     m\_minNodeIndex = std::min(m\_minNodeIndex, std::min(n1, n2));
671 
672     \mbox{\hyperlink{classNetwork_ace5fa3249715ed1b840fa733976aa57b}{insertLink}}(n1, n2, weight);
673 
674     \textcolor{keywordflow}{return} \textcolor{keyword}{true};
675 \}
\end{DoxyCode}
\mbox{\Hypertarget{classNetwork_ac2e5a12947f9983b6193d593ec329a5f}\label{classNetwork_ac2e5a12947f9983b6193d593ec329a5f}} 
\index{Network@{Network}!finalize\+And\+Check\+Network@{finalize\+And\+Check\+Network}}
\index{finalize\+And\+Check\+Network@{finalize\+And\+Check\+Network}!Network@{Network}}
\subsubsection{\texorpdfstring{finalize\+And\+Check\+Network()}{finalizeAndCheckNetwork()}}
{\footnotesize\ttfamily void Network\+::finalize\+And\+Check\+Network (\begin{DoxyParamCaption}\item[{bool}]{print\+Summary = {\ttfamily true},  }\item[{unsigned int}]{desired\+Number\+Of\+Nodes = {\ttfamily 0} }\end{DoxyParamCaption})}

Run after adding links to check for non-\/feasible values and set the node count if not specified in the network, and out\+Degree and sum\+Link\+Out\+Weight. 
\begin{DoxyParams}{Parameters}
{\em desired\+Number\+Of\+Nodes} & Set the desired number of nodes, or leave at zero to set it automatically to match the highest node number defined on the links. \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
747 \{
748     m\_isFinalized = \textcolor{keyword}{true};
749     \textcolor{comment}{// If no nodes defined}
750     \textcolor{keywordflow}{if} (m\_numNodes == 0)
751         m\_numNodes = m\_numNodesFound = m\_maxNodeIndex + 1;
752 
753     \textcolor{keywordflow}{if} (desiredNumberOfNodes != 0)
754     \{
755         \textcolor{keywordflow}{if} (!m\_nodeNames.empty() && desiredNumberOfNodes != m\_nodeNames.size()) \{
756             \textcolor{comment}{// throw InputDomainError("Can't change the number of nodes in networks with a specified number
       of nodes.");}
757             m\_nodeNames.reserve(desiredNumberOfNodes);
758             \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} i = m\_nodeNames.size(); i < desiredNumberOfNodes; ++i) \{
759                 m\_nodeNames.push\_back(\mbox{\hyperlink{classio_1_1Str}{io::Str}}() << \textcolor{stringliteral}{"\_completion\_node\_"} << (i + 1));
760             \}
761         \}
762         m\_numNodes = desiredNumberOfNodes;
763     \}
764 
765     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} zeroMinusOne = 0;
766     --zeroMinusOne;
767     \textcolor{keywordflow}{if} (m\_maxNodeIndex == zeroMinusOne)
768         \textcolor{keywordflow}{throw} \mbox{\hyperlink{classInputDomainError}{InputDomainError}}(\mbox{\hyperlink{classio_1_1Str}{io::Str}}() << \textcolor{stringliteral}{"Integer overflow, be sure to use
       zero-based node numbering if the node numbers start from zero."});
769     \textcolor{keywordflow}{if} (m\_maxNodeIndex >= m\_numNodes)
770         \textcolor{keywordflow}{throw} \mbox{\hyperlink{classInputDomainError}{InputDomainError}}(\mbox{\hyperlink{classio_1_1Str}{io::Str}}() << \textcolor{stringliteral}{"At least one link is defined with node
       numbers that exceeds the number of nodes."});
771     \textcolor{keywordflow}{if} (m\_minNodeIndex == 1 && m\_config.zeroBasedNodeNumbers)
772         \mbox{\hyperlink{classLog}{Log}}() << \textcolor{stringliteral}{"(Warning: minimum link index is one, check that you don't use zero based numbering if
       it's not true.) "};
773 
774     \textcolor{keywordflow}{if} (!m\_bipartiteLinks.empty())
775     \{
776         \textcolor{keywordflow}{if} (m\_numLinks > 0)
777             \textcolor{keywordflow}{throw} \mbox{\hyperlink{classInputDomainError}{InputDomainError}}(\textcolor{stringliteral}{"Can't add bipartite links together with ordinary links.
      "});
778         \textcolor{keywordflow}{if} (m\_bipartiteStartIndex == std::numeric\_limits<unsigned int>::max())
779             m\_bipartiteStartIndex = m\_maxNodeIndex + 1;
780         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} featureIndexOffset = 0;
781         \textcolor{keywordflow}{if} (m\_minFeatureIndex < m\_bipartiteStartIndex) \{
782             featureIndexOffset = m\_bipartiteStartIndex;
783         \}
784         \textcolor{keywordflow}{for} (std::map<BipartiteLink, Weight>::iterator it(m\_bipartiteLinks.begin()); it != m\_bipartiteLinks
      .end(); ++it)
785         \{
786             \textcolor{keyword}{const} \mbox{\hyperlink{structBipartiteLink}{BipartiteLink}}& link = it->first;
787             \textcolor{comment}{// Offset feature nodes by the number of ordinary nodes to make them unique}
788             \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} featureNodeIndex = link.featureNode + featureIndexOffset;
789             m\_maxNodeIndex = std::max(m\_maxNodeIndex, featureNodeIndex);
790             \textcolor{keywordflow}{if} (link.swapOrder)
791                 \mbox{\hyperlink{classNetwork_ace5fa3249715ed1b840fa733976aa57b}{insertLink}}(link.node, featureNodeIndex, it->second.weight);
792             \textcolor{keywordflow}{else}
793                 \mbox{\hyperlink{classNetwork_ace5fa3249715ed1b840fa733976aa57b}{insertLink}}(featureNodeIndex, link.node, it->second.weight);
794         \}
795         m\_numBipartiteNodes = m\_maxNodeIndex + 1 - m\_numNodes;
796         m\_numNodes += m\_numBipartiteNodes;
797     \}
798 
799     \textcolor{keywordflow}{if} (m\_links.empty())
800         \textcolor{keywordflow}{throw} \mbox{\hyperlink{classInputDomainError}{InputDomainError}}(\textcolor{stringliteral}{"No links added!"});
801 
802     \textcolor{keywordflow}{if} (m\_addSelfLinks)
803         zoom();
804 
805     initNodeDegrees();
806 
807     \textcolor{keywordflow}{if} (printSummary)
808         printParsingResult();
809 \}
\end{DoxyCode}
\mbox{\Hypertarget{classNetwork_ace5fa3249715ed1b840fa733976aa57b}\label{classNetwork_ace5fa3249715ed1b840fa733976aa57b}} 
\index{Network@{Network}!insert\+Link@{insert\+Link}}
\index{insert\+Link@{insert\+Link}!Network@{Network}}
\subsubsection{\texorpdfstring{insert\+Link()}{insertLink()}}
{\footnotesize\ttfamily bool Network\+::insert\+Link (\begin{DoxyParamCaption}\item[{unsigned int}]{n1,  }\item[{unsigned int}]{n2,  }\item[{double}]{weight }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

Insert ordinary link, indexed on first node and aggregated if exist \begin{DoxyNote}{Note}
Called by add\+Link 
\end{DoxyNote}
\begin{DoxyReturn}{Returns}
true if a new link was inserted, false if aggregated 
\end{DoxyReturn}

\begin{DoxyCode}
714 \{
715     ++m\_numLinks;
716     m\_totalLinkWeight += weight;
717     \mbox{\hyperlink{classNetwork_a121d0db867b29c99e6e95ef960fcd56f}{insertNode}}(n1);
718     \mbox{\hyperlink{classNetwork_a121d0db867b29c99e6e95ef960fcd56f}{insertNode}}(n2);
719 
720     \textcolor{comment}{// Aggregate link weights if they are definied more than once}
721     LinkMap::iterator firstIt = m\_links.lower\_bound(n1);
722     \textcolor{keywordflow}{if} (firstIt != m\_links.end() && firstIt->first == n1) \textcolor{comment}{// First linkEnd already exists, check second
       linkEnd}
723     \{
724         std::pair<std::map<unsigned int, double>::iterator, \textcolor{keywordtype}{bool}> ret2 = firstIt->second.insert(
      std::make\_pair(n2, weight));
725         \textcolor{keywordflow}{if} (!ret2.second)
726         \{
727             ret2.first->second += weight;
728             ++m\_numAggregatedLinks;
729             --m\_numLinks;
730             \textcolor{keywordflow}{return} \textcolor{keyword}{false};
731         \}
732     \}
733     \textcolor{keywordflow}{else}
734     \{
735         m\_links.insert(firstIt, std::make\_pair(n1, std::map<unsigned int, double>()))->second.insert(
      std::make\_pair(n2, weight));
736     \}
737 
738     \textcolor{keywordflow}{return} \textcolor{keyword}{true};
739 \}
\end{DoxyCode}
\mbox{\Hypertarget{classNetwork_a121d0db867b29c99e6e95ef960fcd56f}\label{classNetwork_a121d0db867b29c99e6e95ef960fcd56f}} 
\index{Network@{Network}!insert\+Node@{insert\+Node}}
\index{insert\+Node@{insert\+Node}!Network@{Network}}
\subsubsection{\texorpdfstring{insert\+Node()}{insertNode()}}
{\footnotesize\ttfamily bool Network\+::insert\+Node (\begin{DoxyParamCaption}\item[{unsigned int}]{node\+Index }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

Insert node if not exist 
\begin{DoxyCode}
742 \{
743     \textcolor{keywordflow}{return} m\_nodes.insert(nodeIndex).second;
744 \}
\end{DoxyCode}
\mbox{\Hypertarget{classNetwork_a73f3d0596eabc17748ce76ef276317d3}\label{classNetwork_a73f3d0596eabc17748ce76ef276317d3}} 
\index{Network@{Network}!parse\+Bipartite\+Link@{parse\+Bipartite\+Link}}
\index{parse\+Bipartite\+Link@{parse\+Bipartite\+Link}!Network@{Network}}
\subsubsection{\texorpdfstring{parse\+Bipartite\+Link()}{parseBipartiteLink()}}
{\footnotesize\ttfamily bool Network\+::parse\+Bipartite\+Link (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{line,  }\item[{unsigned int \&}]{feature\+Node,  }\item[{unsigned int \&}]{node,  }\item[{double \&}]{weight }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

Parse a bipartite link of format \char`\"{}f1 n1 1.\+0\char`\"{} for a link between feature node 1 to ordinary node 1 with weight 1.\+0. The order of the feature nodes and ordinary nodes can be swapped. Store the numberical id (minus possible index\+Offset for non-\/zerobased indexing) on the referenced uints. \begin{DoxyReturn}{Returns}
true if the input order was swapped 
\end{DoxyReturn}

\begin{DoxyCode}
614 \{
615     \textcolor{keywordtype}{bool} swappedOrder = \textcolor{keyword}{false};
616     m\_extractor.clear();
617     m\_extractor.str(line);
618     std::string fn, n;
619     \textcolor{keywordflow}{if} (!(m\_extractor >> fn >> n))
620         \textcolor{keywordflow}{throw} \mbox{\hyperlink{classFileFormatError}{FileFormatError}}(\mbox{\hyperlink{classio_1_1Str}{io::Str}}() << \textcolor{stringliteral}{"Can't parse bipartite link data from line
       '"} << line << \textcolor{stringliteral}{"'"});
621     (m\_extractor >> weight) || (weight = 1.0);
622     \textcolor{keywordflow}{if} (fn[0] != \textcolor{charliteral}{'f'}) \{
623         std::swap(fn, n);
624         swappedOrder = \textcolor{keyword}{true};
625     \}
626     \textcolor{keywordflow}{if} (fn[0] != \textcolor{charliteral}{'f'} || fn.length() == 1 || !(std::istringstream( fn.substr(1) ) >> featureNode))
627         \textcolor{keywordflow}{throw} \mbox{\hyperlink{classFileFormatError}{FileFormatError}}(\mbox{\hyperlink{classio_1_1Str}{io::Str}}() << \textcolor{stringliteral}{"Can't parse bipartite feature node (a
       numerical id prefixed by 'f') from line '"} << line << \textcolor{stringliteral}{"'"});
628     \textcolor{keywordflow}{if} (n[0] != \textcolor{charliteral}{'n'} || n.length() == 1 || !(std::istringstream( n.substr(1) ) >> 
      \mbox{\hyperlink{structnode}{node}}))
629         \textcolor{keywordflow}{throw} \mbox{\hyperlink{classFileFormatError}{FileFormatError}}(\mbox{\hyperlink{classio_1_1Str}{io::Str}}() << \textcolor{stringliteral}{"Can't parse bipartite ordinary node (a
       numerical id prefixed by 'n') from line '"} << line << \textcolor{stringliteral}{"'"});
630 
631     featureNode -= m\_indexOffset;
632     \mbox{\hyperlink{structnode}{node}} -= m\_indexOffset;
633     \textcolor{keywordflow}{return} swappedOrder;
634 \}
\end{DoxyCode}
\mbox{\Hypertarget{classNetwork_a06e77b2e70073abda5ef39bdb2e0680a}\label{classNetwork_a06e77b2e70073abda5ef39bdb2e0680a}} 
\index{Network@{Network}!parse\+Link@{parse\+Link}}
\index{parse\+Link@{parse\+Link}!Network@{Network}}
\subsubsection{\texorpdfstring{parse\+Link()}{parseLink()}}
{\footnotesize\ttfamily void Network\+::parse\+Link (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{line,  }\item[{unsigned int \&}]{n1,  }\item[{unsigned int \&}]{n2,  }\item[{double \&}]{weight }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

Parse a string of link data. If no weight data can be extracted, the default value 1.\+0 will be used. 
\begin{DoxyExceptions}{Exceptions}
{\em an} & error if not both node numbers can be extracted. \\
\hline
\end{DoxyExceptions}

\begin{DoxyCode}
583 \{
584     m\_extractor.clear();
585     m\_extractor.str(line);
586     \textcolor{keywordflow}{if} (!(m\_extractor >> n1 >> n2))
587         \textcolor{keywordflow}{throw} \mbox{\hyperlink{classFileFormatError}{FileFormatError}}(\mbox{\hyperlink{classio_1_1Str}{io::Str}}() << \textcolor{stringliteral}{"Can't parse link data from line '"} << 
      line << \textcolor{stringliteral}{"'"});
588     (m\_extractor >> weight) || (weight = 1.0);
589     n1 -= m\_indexOffset;
590     n2 -= m\_indexOffset;
591 \}
\end{DoxyCode}
\mbox{\Hypertarget{classNetwork_a57b99ecccedc6200838163fa3b1ad252}\label{classNetwork_a57b99ecccedc6200838163fa3b1ad252}} 
\index{Network@{Network}!parse\+Vertices@{parse\+Vertices}}
\index{parse\+Vertices@{parse\+Vertices}!Network@{Network}}
\subsubsection{\texorpdfstring{parse\+Vertices()}{parseVertices()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily std\+::string Network\+::parse\+Vertices (\begin{DoxyParamCaption}\item[{std\+::ifstream \&}]{file,  }\item[{bool}]{required = {\ttfamily true} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

Parse vertices \begin{DoxyReturn}{Returns}
The line after the vertices 
\end{DoxyReturn}

\begin{DoxyCode}
407 \{
408     std::string line;
409 
410     \textcolor{comment}{// First skip lines until header}
411     \textcolor{keywordflow}{while}(!std::getline(file, line).fail())
412     \{
413         \textcolor{keywordflow}{if} (line.length() == 0 || line[0] == \textcolor{charliteral}{'#'})
414             \textcolor{keywordflow}{continue};
415         \textcolor{keywordflow}{if} (line[0] == \textcolor{charliteral}{'*'})
416             \textcolor{keywordflow}{break};
417     \}
418 
419     \textcolor{keywordflow}{if} (line.length() == 0 || line[0] != \textcolor{charliteral}{'*'})
420         \textcolor{keywordflow}{throw} \mbox{\hyperlink{classFileFormatError}{FileFormatError}}(\textcolor{stringliteral}{"No matching header for vertices found."});
421 
422     \textcolor{keywordflow}{return} \mbox{\hyperlink{classNetwork_a57b99ecccedc6200838163fa3b1ad252}{parseVertices}}(file, line, required);
423 \}
\end{DoxyCode}
\mbox{\Hypertarget{classNetwork_a5cec6b6daa66f112a70bc97c9c28fbc0}\label{classNetwork_a5cec6b6daa66f112a70bc97c9c28fbc0}} 
\index{Network@{Network}!parse\+Vertices@{parse\+Vertices}}
\index{parse\+Vertices@{parse\+Vertices}!Network@{Network}}
\subsubsection{\texorpdfstring{parse\+Vertices()}{parseVertices()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily std\+::string Network\+::parse\+Vertices (\begin{DoxyParamCaption}\item[{std\+::ifstream \&}]{file,  }\item[{std\+::string}]{heading,  }\item[{bool}]{required = {\ttfamily true} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

Parse vertices under the heading \begin{DoxyReturn}{Returns}
The line after the vertices 
\end{DoxyReturn}

\begin{DoxyCode}
426 \{
427     std::istringstream ss;
428     std::string buf;
429     ss.str(header);
430     ss >> buf;
431     \textcolor{keywordflow}{if}(buf == \textcolor{stringliteral}{"*Vertices"} || buf == \textcolor{stringliteral}{"*vertices"} || buf == \textcolor{stringliteral}{"*VERTICES"}) \{
432         \textcolor{keywordflow}{if} (!(ss >> m\_numNodesFound))
433             \textcolor{keywordflow}{throw} \mbox{\hyperlink{classBadConversionError}{BadConversionError}}(\mbox{\hyperlink{classio_1_1Str}{io::Str}}() << \textcolor{stringliteral}{"Can't parse an integer after '"}
       << buf <<
434                     \textcolor{stringliteral}{"' as the number of nodes."});
435     \}
436     \textcolor{keywordflow}{else} \{
437         \textcolor{keywordflow}{if} (!required)
438             \textcolor{keywordflow}{return} header;
439         \textcolor{keywordflow}{throw} \mbox{\hyperlink{classFileFormatError}{FileFormatError}}(\mbox{\hyperlink{classio_1_1Str}{io::Str}}() << \textcolor{stringliteral}{"The header '"} << header << \textcolor{stringliteral}{"' doesn't
       match *Vertices (case insensitive)."});
440     \}
441 
442     \textcolor{keywordflow}{if} (m\_numNodesFound == 0)
443         \textcolor{keywordflow}{throw} \mbox{\hyperlink{classFileFormatError}{FileFormatError}}(\textcolor{stringliteral}{"The number of vertices cannot be zero."});
444 
445     \textcolor{keywordtype}{bool} checkNodeLimit = m\_config.nodeLimit > 0;
446     m\_numNodes = checkNodeLimit ? m\_config.nodeLimit : m\_numNodesFound;
447 
448     m\_nodeNames.resize(m\_numNodes);
449     m\_nodeWeights.assign(m\_numNodes, 1.0);
450     m\_sumNodeWeights = 0.0;
451 
452     std::string line;
453     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} numNodesParsed = 0;
454     \textcolor{keywordtype}{bool} didEarlyBreak = \textcolor{keyword}{false};
455 
456     \textcolor{comment}{// Read node names and optional weight, assuming id 1, 2, 3, ... (or 0, 1, 2, ... if zero-based node
       numbering)}
457     \textcolor{keywordflow}{while}(!std::getline(file, line).fail())
458     \{
459         \textcolor{keywordflow}{if} (line.length() == 0 || line[0] == \textcolor{charliteral}{'#'})
460             \textcolor{keywordflow}{continue};
461 
462         \textcolor{keywordflow}{if} (line[0] == \textcolor{charliteral}{'*'})
463             \textcolor{keywordflow}{break};
464 
465         \textcolor{keywordflow}{if} (m\_config.nodeLimit > 0 && numNodesParsed == m\_config.nodeLimit) \{
466             didEarlyBreak = \textcolor{keyword}{true};
467             \textcolor{keywordflow}{break};
468         \}
469 
470         \textcolor{comment}{// parseVertice(line, id, name, weight);}
471         ss.clear();
472         ss.str(line);
473 
474         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} \textcolor{keywordtype}{id} = 0;
475         \textcolor{keywordflow}{if} (!(ss >> \textcolor{keywordtype}{id}))
476             \textcolor{keywordflow}{throw} \mbox{\hyperlink{classFileFormatError}{FileFormatError}}(\mbox{\hyperlink{classio_1_1Str}{io::Str}}() << \textcolor{stringliteral}{"Can't parse node id from line '"} << 
      line << \textcolor{stringliteral}{"'"});
477 
478         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} nameStart = line.find\_first\_of(\textcolor{stringliteral}{"\(\backslash\)""});
479         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} nameEnd = line.find\_last\_of(\textcolor{stringliteral}{"\(\backslash\)""});
480         std::string name(\textcolor{stringliteral}{""});
481         \textcolor{keywordflow}{if}(nameStart < nameEnd) \{
482             name = std::string(line.begin() + nameStart + 1, line.begin() + nameEnd);
483             line = line.substr(nameEnd + 1);
484             ss.clear();
485             ss.str(line);
486         \}
487         \textcolor{keywordflow}{else} \{
488             \textcolor{keywordflow}{if} (!(ss >> name))
489                 \textcolor{keywordflow}{throw} \mbox{\hyperlink{classFileFormatError}{FileFormatError}}(\mbox{\hyperlink{classio_1_1Str}{io::Str}}() << \textcolor{stringliteral}{"Can't parse node name from line '
      "} << line << \textcolor{stringliteral}{"'"});
490         \}
491         \textcolor{keywordtype}{double} weight = 1.0;
492         \textcolor{keywordflow}{if} ((ss >> weight)) \{
493             \textcolor{comment}{// TODO: Check valid weight here?}
494             \textcolor{keywordflow}{if} (weight < 0.0) \{
495                 \textcolor{keywordflow}{throw} \mbox{\hyperlink{classFileFormatError}{FileFormatError}}(\mbox{\hyperlink{classio_1_1Str}{io::Str}}() << \textcolor{stringliteral}{"Parsed a negative value ("} <<
496                 weight << \textcolor{stringliteral}{") as weight to node "} << \textcolor{keywordtype}{id} << \textcolor{stringliteral}{" from line '"} <<
497                 line << \textcolor{stringliteral}{"'."});
498             \}
499         \}
500         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} nodeIndex = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}\textcolor{keyword}{>}(\textcolor{keywordtype}{id} - m\_indexOffset);
501         \textcolor{keywordflow}{if} (nodeIndex != numNodesParsed)
502         \{
503             \textcolor{keywordflow}{throw} \mbox{\hyperlink{classBadConversionError}{BadConversionError}}(\mbox{\hyperlink{classio_1_1Str}{io::Str}}() << \textcolor{stringliteral}{"The node id from line '"} << 
      line <<
504                 \textcolor{stringliteral}{"' doesn't follow a consequitive order"} <<
505                 ((m\_indexOffset == 1 && \textcolor{keywordtype}{id} == 0)? \textcolor{stringliteral}{".\(\backslash\)nBe sure to use zero-based node numbering if the node
       numbers start from zero."} : \textcolor{stringliteral}{"."}));
506         \}
507 
508         m\_sumNodeWeights += weight;
509         m\_nodeWeights[nodeIndex] = weight;
510         m\_nodeNames[nodeIndex] = name;
511         ++numNodesParsed;
512     \}
513 
514     \textcolor{keywordflow}{if} (line[0] == \textcolor{charliteral}{'*'} && numNodesParsed == 0)
515     \{
516         \textcolor{comment}{// Short pajek version (no nodes defined), set node number as name}
517         \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} i = 0; i < m\_numNodes; ++i)
518         \{
519             m\_nodeWeights[i] = 1.0;
520             m\_nodeNames[i] = io::stringify(i+1);
521         \}
522         m\_sumNodeWeights = m\_numNodes * 1.0;
523     \}
524     
525     \textcolor{keywordflow}{if} (m\_sumNodeWeights < 1e-10) \{
526         \mbox{\hyperlink{classLog}{Log}}() << \textcolor{stringliteral}{" (Warning: All node weights zero, changing to one) "};
527         \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} i = 0; i < m\_numNodes; ++i)
528         \{
529             m\_nodeWeights[i] = 1.0;
530         \}
531         m\_sumNodeWeights = m\_numNodes * 1.0;
532     \}
533 
534     \textcolor{keywordflow}{if} (didEarlyBreak)
535     \{
536         line = \mbox{\hyperlink{classNetwork_afd458fbfc07fc12e8ca3d6ec4e6a7291}{skipUntilHeader}}(file);
537     \}
538 
539     \textcolor{keywordflow}{return} line;
540 \}
\end{DoxyCode}
\mbox{\Hypertarget{classNetwork_a7ebe3a5e948fc60e81fb94df08ca4358}\label{classNetwork_a7ebe3a5e948fc60e81fb94df08ca4358}} 
\index{Network@{Network}!set\+Bipartite\+Nodes\+From@{set\+Bipartite\+Nodes\+From}}
\index{set\+Bipartite\+Nodes\+From@{set\+Bipartite\+Nodes\+From}!Network@{Network}}
\subsubsection{\texorpdfstring{set\+Bipartite\+Nodes\+From()}{setBipartiteNodesFrom()}}
{\footnotesize\ttfamily void Network\+::set\+Bipartite\+Nodes\+From (\begin{DoxyParamCaption}\item[{unsigned int}]{bipartite\+Start\+Index }\end{DoxyParamCaption})}

Change this network to a bipartite network 
\begin{DoxyParams}{Parameters}
{\em bipartite\+Start\+Index} & Nodes equal to or above this index are treated as feature nodes \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
638 \{
639     m\_bipartiteStartIndex = bipartiteStartIndex;
640 \}
\end{DoxyCode}
\mbox{\Hypertarget{classNetwork_afd458fbfc07fc12e8ca3d6ec4e6a7291}\label{classNetwork_afd458fbfc07fc12e8ca3d6ec4e6a7291}} 
\index{Network@{Network}!skip\+Until\+Header@{skip\+Until\+Header}}
\index{skip\+Until\+Header@{skip\+Until\+Header}!Network@{Network}}
\subsubsection{\texorpdfstring{skip\+Until\+Header()}{skipUntilHeader()}}
{\footnotesize\ttfamily std\+::string Network\+::skip\+Until\+Header (\begin{DoxyParamCaption}\item[{std\+::ifstream \&}]{file }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

Read lines from file until it starts with \textquotesingle{}$\ast$\textquotesingle{} and return that line. 
\begin{DoxyCode}
391 \{
392     std::string line;
393 
394     \textcolor{comment}{// First skip lines until header}
395     \textcolor{keywordflow}{while}(!std::getline(file, line).fail())
396     \{
397         \textcolor{keywordflow}{if} (line.length() == 0 || line[0] == \textcolor{charliteral}{'#'})
398             \textcolor{keywordflow}{continue};
399         \textcolor{keywordflow}{if} (line[0] == \textcolor{charliteral}{'*'})
400             \textcolor{keywordflow}{break};
401     \}
402 
403     \textcolor{keywordflow}{return} line;
404 \}
\end{DoxyCode}


The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
dsmacc/graph/infomap/src/infomap/Network.\+h\item 
dsmacc/graph/infomap/src/infomap/Network.\+cpp\end{DoxyCompactItemize}
