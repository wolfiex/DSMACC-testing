Traverse and transform objects by visiting every node on a recursive walk.

\section*{examples }

\subsection*{transform negative numbers in-\/place }

negative.\+js


\begin{DoxyCode}
var traverse = require('traverse');
var obj = [ 5, 6, -3, [ 7, 8, -2, 1 ], \{ f : 10, g : -13 \} ];

traverse(obj).forEach(function (x) \{
    if (x < 0) this.update(x + 128);
\});

console.dir(obj);
\end{DoxyCode}


Output\+: \begin{DoxyVerb}[ 5, 6, 125, [ 7, 8, 126, 1 ], { f: 10, g: 115 } ]
\end{DoxyVerb}


\subsection*{collect leaf nodes }

leaves.\+js


\begin{DoxyCode}
var traverse = require('traverse');

var obj = \{
    a : [1,2,3],
    b : 4,
    c : [5,6],
    d : \{ e : [7,8], f : 9 \},
\};

var leaves = traverse(obj).reduce(function (acc, x) \{
    if (this.isLeaf) acc.push(x);
    return acc;
\}, []);

console.dir(leaves);
\end{DoxyCode}


Output\+: \begin{DoxyVerb}[ 1, 2, 3, 4, 5, 6, 7, 8, 9 ]
\end{DoxyVerb}


\section*{context }

Each method that takes a callback has a context (its {\ttfamily this} object) with these attributes\+:

\subsection*{this.\+node }

The present node on the recursive walk

\subsection*{this.\+path }

An array of string keys from the root to the present node

\subsection*{this.\+parent }

The context of the node\textquotesingle{}s parent. This is {\ttfamily undefined} for the root node.

\subsection*{this.\+key }

The name of the key of the present node in its parent. This is {\ttfamily undefined} for the root node.

\subsection*{this.\+is\+Root, this.\+not\+Root }

Whether the present node is the root node

\subsection*{this.\+is\+Leaf, this.\+not\+Leaf }

Whether or not the present node is a leaf node (has no children)

\subsection*{this.\+level }

Depth of the node within the traversal

\subsection*{this.\+circular }

If the node equals one of its parents, the {\ttfamily circular} attribute is set to the context of that parent and the traversal progresses no deeper.

\subsection*{this.\+update(value) }

Set a new value for the present node.

\subsection*{this.\+remove() }

Remove the current element from the output. If the node is in an Array it will be spliced off. Otherwise it will be deleted from its parent.

\subsection*{this.\+delete() }

Delete the current element from its parent in the output. Calls {\ttfamily delete} even on Arrays.

\subsection*{this.\+before(fn) }

Call this function before any of the children are traversed.

\subsection*{this.\+after(fn) }

Call this function after any of the children are traversed.

\subsection*{this.\+pre(fn) }

Call this function before each of the children are traversed.

\subsection*{this.\+post(fn) }

Call this function after each of the children are traversed.

\section*{methods }

\subsection*{.map(fn) }

Execute {\ttfamily fn} for each node in the object and return a new object with the results of the walk. To update nodes in the result use {\ttfamily this.\+update(value)}.

\subsection*{.for\+Each(fn) }

Execute {\ttfamily fn} for each node in the object but unlike {\ttfamily .map()}, when {\ttfamily this.\+update()} is called it updates the object in-\/place.

\subsection*{.reduce(fn, acc) }

For each node in the object, perform a \href{http://en.wikipedia.org/wiki/Fold_(higher-order_function)}{\tt left-\/fold} with the return value of {\ttfamily fn(acc, node)}.

If {\ttfamily acc} isn\textquotesingle{}t specified, {\ttfamily acc} is set to the root object for the first step and the root element is skipped.

\subsection*{.deep\+Equal(obj) }

Returns a boolean, whether the instance value is equal to the supplied object along a deep traversal using some opinionated choices.

Some notes\+:


\begin{DoxyItemize}
\item Reg\+Exps are equal if their .to\+String()s match, but not functions since functions can close over different variables.
\item \mbox{\hyperlink{classDate}{Date}} instances are compared using {\ttfamily .get\+Time()} just like {\ttfamily assert.\+deep\+Equal()}.
\item Circular references must refer to the same paths within the data structure for both objects. For instance, in this snippet\+:
\end{DoxyItemize}


\begin{DoxyCode}
var a = [1];
a.push(a); // a = [ 1, *a ]

var b = [1];
b.push(a); // b = [ 1, [ 1, *a ] ]
\end{DoxyCode}


{\ttfamily a} is not the same as {\ttfamily b} since even though the expansion is the same, the circular references in each refer to different paths into the data structure.

However, in\+:


\begin{DoxyCode}
var c = [1];
c.push(c); // c = [ 1, *c ];
\end{DoxyCode}


{\ttfamily c} is equal to {\ttfamily a} in a {\ttfamily deep\+Equal()} because they have the same terminal node structure.


\begin{DoxyItemize}
\item Arguments objects are not arrays and neither are they the same as regular objects.
\item Instances created with {\ttfamily new} of String, Boolean, and Number types are never equal to the native versions.
\end{DoxyItemize}

\subsection*{.paths() }

Return an {\ttfamily Array} of every possible non-\/cyclic path in the object. Paths are {\ttfamily Array}s of string keys.

\subsection*{.nodes() }

Return an {\ttfamily Array} of every node in the object.

\subsection*{.clone() }

Create a deep clone of the object.

\section*{installation }

Using npm\+: npm install traverse

Or check out the repository and link your development copy\+: git clone \href{http://github.com/substack/js-traverse.git}{\tt http\+://github.\+com/substack/js-\/traverse.\+git} cd js-\/traverse npm link .

You can test traverse with \char`\"{}expresso\char`\"{}\+:\href{http://github.com/visionmedia/expresso}{\tt http\+://github.\+com/visionmedia/expresso} ({\ttfamily npm install expresso})\+: js-\/traverse \$ expresso

100\% wahoo, your stuff is not broken!

\section*{hash transforms }

This library formerly had a hash transformation component. It has been \href{https://github.com/substack/node-hashish}{\tt moved to the hashish package}. 