Resolve the source map and/or sources for a generated file.


\begin{DoxyCode}
var sourceMapResolve = require("source-map-resolve")
var sourceMap        = require("source-map")

var code = [
  "!function()\{...\}();",
  "/*# sourceMappingURL=foo.js.map */"
].join("\(\backslash\)n")

sourceMapResolve.resolveSourceMap(code, "/js/foo.js", fs.readFile, function(error, result) \{
  if (error) \{
    return notifyFailure(error)
  \}
  result
  // \{
  //   map: \{file: "foo.js", mappings: "...", sources: ["/coffee/foo.coffee"], names: []\},
  //   url: "/js/foo.js.map",
  //   sourcesRelativeTo: "/js/foo.js.map",
  //   sourceMappingURL: "foo.js.map"
  // \}

  sourceMapResolve.resolveSources(result.map, result.sourcesRelativeTo, fs.readFile, function(error,
       result) \{
    if (error) \{
      return notifyFailure(error)
    \}
    result
    // \{
    //   sourcesResolved: ["/coffee/foo.coffee"],
    //   sourcesContent: ["<contents of /coffee/foo.coffee>"]
    // \}
  \})
\})

sourceMapResolve.resolve(code, "/js/foo.js", fs.readFile, function(error, result) \{
  if (error) \{
    return notifyFailure(error)
  \}
  result
  // \{
  //   map: \{file: "foo.js", mappings: "...", sources: ["/coffee/foo.coffee"], names: []\},
  //   url: "/js/foo.js.map",
  //   sourcesRelativeTo: "/js/foo.js.map",
  //   sourceMappingURL: "foo.js.map",
  //   sourcesResolved: ["/coffee/foo.coffee"],
  //   sourcesContent: ["<contents of /coffee/foo.coffee>"]
  // \}
  result.map.sourcesContent = result.sourcesContent
  var map = new sourceMap.sourceMapConsumer(result.map)
  map.sourceContentFor("/coffee/foo.coffee")
  // "<contents of /coffee/foo.coffee>"
\})
\end{DoxyCode}


\section*{Installation }


\begin{DoxyItemize}
\item {\ttfamily npm install source-\/map-\/resolve}
\item {\ttfamily bower install source-\/map-\/resolve}
\item {\ttfamily component install lydell/source-\/map-\/resolve}
\end{DoxyItemize}

Works with Common\+JS, A\+MD and browser globals, through U\+MD.

Note\+: This module requires {\ttfamily set\+Immediate} and {\ttfamily atob}. Use polyfills if needed, such as\+:


\begin{DoxyItemize}
\item \href{https://github.com/NobleJS/setImmediate}{\tt https\+://github.\+com/\+Noble\+J\+S/set\+Immediate}
\item \href{https://github.com/davidchambers/Base64.js}{\tt https\+://github.\+com/davidchambers/\+Base64.\+js}
\end{DoxyItemize}

\section*{Usage }

\subsubsection*{{\ttfamily source\+Map\+Resolve.\+resolve\+Source\+Map(code, code\+Url, read, callback)}}


\begin{DoxyItemize}
\item {\ttfamily code} is a string of code that may or may not contain a source\+Mapping\+U\+RL comment. Such a comment is used to resolve the source map.
\item {\ttfamily code\+Url} is the url to the file containing {\ttfamily code}. If the source\+Mapping\+U\+RL is relative, it is resolved against {\ttfamily code\+Url}.
\item {\ttfamily read(url, callback)} is a function that reads {\ttfamily url} and responds using {\ttfamily callback(error, content)}. In Node.\+js you might want to use {\ttfamily fs.\+read\+File}, while in the browser you might want to use an asynchronus {\ttfamily X\+M\+L\+Http\+Request}.
\item {\ttfamily callback(error, result)} is a function that is invoked with either an error or {\ttfamily null} and the result.
\end{DoxyItemize}

The result is an object with the following properties\+:


\begin{DoxyItemize}
\item {\ttfamily map}\+: The source map for {\ttfamily code}, as an object (not a string).
\item {\ttfamily url}\+: The url to the source map. If the source map came from a data uri, this property is {\ttfamily null}, since then there is no url to it.
\item {\ttfamily sources\+Relative\+To}\+: The url that the sources of the source map are relative to. Since the sources are relative to the source map, and the url to the source map is provided as the {\ttfamily url} property, this property might seem superfluos. However, remember that the {\ttfamily url} property can be {\ttfamily null} if the source map came from a data uri. If so, the sources are relative to the file containing the data uri—{\ttfamily code\+Url}. This property will be identical to the {\ttfamily url} property or {\ttfamily code\+Url}, whichever is appropriate. This way you can conveniently resolve the sources without having to think about where the source map came from.
\item {\ttfamily source\+Mapping\+U\+RL}\+: The url of the source\+Mapping\+U\+RL comment in {\ttfamily code}.
\end{DoxyItemize}

If {\ttfamily code} contains no source\+Mapping\+U\+RL, the result is {\ttfamily null}.

\subsubsection*{{\ttfamily source\+Map\+Resolve.\+resolve\+Sources(map, map\+Url, read, \mbox{[}options\mbox{]}, callback)}}


\begin{DoxyItemize}
\item {\ttfamily map} is a source map, as an object (not a string).
\item {\ttfamily map\+Url} is the url to the file containing {\ttfamily map}. Relative sources in the source map, if any, are resolved against {\ttfamily map\+Url}.
\item {\ttfamily read(url, callback)} is a function that reads {\ttfamily url} and responds using {\ttfamily callback(error, content)}. In Node.\+js you might want to use {\ttfamily fs.\+read\+File}, while in the browser you might want to use an asynchronus {\ttfamily X\+M\+L\+Http\+Request}.
\item {\ttfamily options} is an optional object with any of the following properties\+:
\begin{DoxyItemize}
\item {\ttfamily source\+Root}\+: Override the {\ttfamily source\+Root} property of the source map, which might only be relevant when resolving sources in the browser. This lets you bypass it when using the module outside of a browser, if needed. Pass a string to replace the {\ttfamily source\+Root} property with, or {\ttfamily false} to ignore it. Defaults to {\ttfamily undefined}.
\end{DoxyItemize}
\item {\ttfamily callback(error, result)} is a function that is invoked with either an error or {\ttfamily null} and the result.
\end{DoxyItemize}

The result is an object with the following properties\+:


\begin{DoxyItemize}
\item {\ttfamily sources\+Resolved}\+: The same as {\ttfamily map.\+sources}, except all the sources are fully resolved.
\item {\ttfamily sources\+Content}\+: An array with the contents of all sources in {\ttfamily map.\+sources}, in the same order as {\ttfamily map.\+sources}. If getting the contents of a source fails, an error object is put into the array instead.
\end{DoxyItemize}

\subsubsection*{{\ttfamily source\+Map\+Resolve.\+resolve(code, code\+Url, read, \mbox{[}options\mbox{]}, callback)}}

The arguments are identical to {\ttfamily source\+Map\+Resolve.\+resolve\+Source\+Map}, except that you may also provide the same {\ttfamily options} as in {\ttfamily source\+Map\+Resolve.\+resolve\+Sources}.

This is a convenience method that first resolves the source map and then its sources. You could also do this by first calling {\ttfamily source\+Map\+Resolve.\+resolve\+Source\+Map} and then {\ttfamily source\+Map\+Resolve.\+resolve\+Sources}.

The result is identical to {\ttfamily source\+Map\+Resolve.\+resolve\+Source\+Map}, with the properties from {\ttfamily source\+Map\+Resolve.\+resolve\+Sources} merged into it.

There is one extra feature available, though. If {\ttfamily code} is {\ttfamily null}, {\ttfamily code\+Url} is treated as a url to the source map instead of to {\ttfamily code}, and will be read. This is handy if you {\itshape sometimes} get the source map url from the {\ttfamily Source\+Map\+: $<$url$>$} header (see the \href{#notes}{\tt Notes} section). In this case, the {\ttfamily source\+Mapping\+U\+RL} property of the result is {\ttfamily null}.

\subsubsection*{{\ttfamily source\+Map\+Resolve.$\ast$\+Sync()}}

There are also sync versions of the three previous functions. They are identical to the async versions, except\+:


\begin{DoxyItemize}
\item They expect a sync reading function. In Node.\+js you might want to use {\ttfamily fs.\+read\+File\+Sync}, while in the browser you might want to use a synchronus {\ttfamily X\+M\+L\+Http\+Request}.
\item They throw errors and return the result instead of using a callback.
\end{DoxyItemize}

{\ttfamily source\+Map\+Resolve.\+resolve\+Sources\+Sync} also accepts {\ttfamily null} as the {\ttfamily read} parameter. The result is the same as when passing a function as the {\ttfamily read parameter}, except that the {\ttfamily sources\+Content} property of the result will be an empty array. In other words, the sources aren’t read. You only get the {\ttfamily sources\+Resolved} property. (This only supported in the synchronus version, since there is no point doing it asynchronusly.)

\subsubsection*{{\ttfamily source\+Map\+Resolve.\+parse\+Map\+To\+J\+S\+O\+N(string, \mbox{[}data\mbox{]})}}

The spec says that if a source map (as a string) starts with `)\mbox{]}\}'\`{}, it should be stripped off. This is to prevent X\+S\+SI attacks. This function does that and returns the result of {\ttfamily J\+S\+O\+N.\+parse}ing what’s left.

If this function throws {\ttfamily error}, {\ttfamily error.\+source\+Map\+Data === data}.

\subsubsection*{Errors}

All errors passed to callbacks or thrown by this module have a {\ttfamily source\+Map\+Data} property that contain as much as possible of the intended result of the function up until the error occurred.

Note that while the {\ttfamily map} property of result objects always is an object, {\ttfamily error.\+source\+Map\+Data.\+map} will be a string if parsing that string fails.

\section*{Note }

This module resolves the source map for a given generated file by looking for a source\+Mapping\+U\+RL comment. The spec defines yet a way to provide the U\+RL to the source map\+: By sending the {\ttfamily Source\+Map\+: $<$url$>$} header along with the generated file. Since this module doesn’t retrive the generated code for you (instead {\itshape you} give the generated code to the module), it’s up to you to look for such a header when you retrieve the file (should the need arise).

\section*{Development }

\subsection*{Tests }

First off, run {\ttfamily npm install} to install testing modules and browser polyfills.

{\ttfamily npm test} lints the code and runs the test suite in Node.\+js.

\subsection*{x-\/package.\+json5 }

package.\+json, component.\+json and bower.\+json are all generated from x-\/package.\+json5 by using \href{https://github.com/kof/node-xpkg}{\tt {\ttfamily xpkg}}. Only edit x-\/package.\+json5, and remember to run {\ttfamily xpkg} before commiting!

\subsection*{Generating the browser version }

source-\/map-\/resolve.\+js is generated from source-\/map-\/resolve-\/node.\+js and source-\/map-\/resolve-\/template.\+js. Only edit the two latter files, {\itshape not} source-\/map-\/resolve.\+js! To generate it, run {\ttfamily npm run build}.

\section*{License }

\mbox{[}The X11 (“\+M\+I\+T”) License\mbox{]}(L\+I\+C\+E\+N\+SE). 