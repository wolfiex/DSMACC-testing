streaming pipeline with a mutable configuration

This module is similar to \href{https://npmjs.org/package/stream-combiner}{\tt stream-\/combiner}, but with a pipeline configuration that can be changed at runtime.

\href{http://travis-ci.org/browserify/stream-splicer}{\tt }

\section*{example}

This example begins with an H\+T\+TP header parser that waits for an empty line to signify the end of the header. At that point, it switches to a streaming json parser to operate on the H\+T\+TP body.


\begin{DoxyCode}
var splicer = require('stream-splicer');
var through = require('through2');
var jsonStream = require('jsonstream2');
var split = require('split2');

var headerData = \{\};
var headers = through.obj(function (buf, enc, next) \{
    var line = buf.toString('utf8');
    if (line === '') \{
        this.push(headerData);
        pipeline.splice(1, 1, jsonStream.parse([ 'rows', true ]));
    \}
    else \{
        var m = /^(\(\backslash\)S+):(.+)/.exec(line);
        var key = m && m[1].trim();
        var value = m && m[2].trim();
        if (m) headerData[key] = value;
    \}
    next();
\});
var pipeline = splicer([ split(), headers, jsonStream.stringify() ]);
process.stdin.pipe(pipeline).pipe(process.stdout);
\end{DoxyCode}


intput\+:


\begin{DoxyCode}
GET / HTTP/1.1
Host: substack.net
User-Agent: echo

\{"rows":["beep","boop"]\}
\end{DoxyCode}


output\+:


\begin{DoxyCode}
$ echo -ne 'GET / HTTP/1.1\(\backslash\)nHost: substack.net\(\backslash\)nUser-Agent: echo\(\backslash\)n\(\backslash\)n\{"rows":["beep","boop"]\}\(\backslash\)n' | node
       example/header.js
[
\{"Host":"substack.net","User-Agent":"echo"\}
,
"beep"
,
"boop"
]
\end{DoxyCode}


\section*{methods}


\begin{DoxyCode}
var splicer = require('stream-splicer')
\end{DoxyCode}


\subsection*{var pipeline = splicer(streams, opts)}

Create a {\ttfamily pipeline} duplex stream given an array of {\ttfamily streams}. Each {\ttfamily stream} will be piped to the next. Writes to {\ttfamily pipeline} get written to the first stream and data for reads from {\ttfamily pipeline} come from the last stream.

For example, for streams {\ttfamily \mbox{[} a, b, c, d \mbox{]}}, this pipeline is constructed internally\+:


\begin{DoxyCode}
a.pipe(b).pipe(c).pipe(d)
\end{DoxyCode}


Input will get written into {\ttfamily a}. Output will be read from {\ttfamily d}.

If any of the elements in {\ttfamily streams} are arrays, they will be converted into nested pipelines. This is useful if you want to expose a hookable pipeline with grouped insertion points.

\subsection*{var pipeline = splicer.\+obj(streams, opts)}

Create a {\ttfamily pipeline} with {\ttfamily opts.\+object\+Mode} set to true for convenience.

\subsection*{var removed = pipeline.\+splice(index, how\+Many, stream, ...)}

Splice the pipeline starting at {\ttfamily index}, removing {\ttfamily how\+Many} streams and replacing them with each additional {\ttfamily stream} argument provided.

The streams that were removed from the splice and returned.

\subsection*{pipeline.\+push(stream, ...)}

Push one or more streams to the end of the pipeline.

\subsection*{var stream = pipeline.\+pop()}

Pop a stream from the end of the pipeline.

\subsection*{pipeline.\+unshift(stream, ...)}

Unshift one or more streams to the begining of the pipeline.

\subsection*{var stream = pipeline.\+shift()}

Shift a stream from the begining of the pipeline.

\subsection*{var stream = pipeline.\+get(index, ...)}

Return the stream at index {\ttfamily index, ...}. Indexes can be negative.

Multiple indexes will traverse into nested pipelines.

\section*{attributes}

\subsection*{pipeline.\+length}

The number of streams in the pipeline

\section*{install}

With \href{https://npmjs.org}{\tt npm} do\+:


\begin{DoxyCode}
npm install stream-splicer
\end{DoxyCode}


\section*{license}

M\+IT 