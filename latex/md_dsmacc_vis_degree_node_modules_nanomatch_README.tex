{\bfseries Details}

\begin{quote}
Fast, minimal glob matcher for node.\+js. Similar to micromatch, minimatch and multimatch, but complete Bash 4.\+3 wildcard support only (no support for exglobs, posix brackets or braces) \end{quote}


Please consider following this project\textquotesingle{}s author, \href{https://github.com/jonschlinkert}{\tt Jon Schlinkert}, and consider starring the project to show your \+:heart\+: and support.

\subsection*{Table of Contents}

$<$details$>$


\begin{DoxyItemize}
\item \href{#install}{\tt Install}
\item \href{#what-is-nanomatch}{\tt What is nanomatch?}
\item \href{#getting-started}{\tt Getting started}
\begin{DoxyItemize}
\item \href{#installing-nanomatch}{\tt Installing nanomatch}
\item \href{#usage}{\tt Usage}
\end{DoxyItemize}
\item \href{#documentation}{\tt Documentation}
\begin{DoxyItemize}
\item \href{#escaping}{\tt Escaping}
\end{DoxyItemize}
\item \href{#api}{\tt A\+PI}
\item \href{#options}{\tt Options}
\begin{DoxyItemize}
\item \href{#optionsbasename}{\tt options.\+basename}
\item \href{#optionsbash}{\tt options.\+bash}
\item \href{#optionscache}{\tt options.\+cache}
\item \href{#optionsdot}{\tt options.\+dot}
\item \href{#optionsfailglob}{\tt options.\+failglob}
\item \href{#optionsignore}{\tt options.\+ignore}
\item \href{#optionsmatchbase}{\tt options.\+match\+Base}
\item \href{#optionsnocase}{\tt options.\+nocase}
\item \href{#optionsnodupes}{\tt options.\+nodupes}
\item \href{#optionsnoglobstar}{\tt options.\+noglobstar}
\item \href{#optionsnonegate}{\tt options.\+nonegate}
\item \href{#optionsnonull}{\tt options.\+nonull}
\item \href{#optionsnullglob}{\tt options.\+nullglob}
\item \href{#optionsslash}{\tt options.\+slash}
\item \href{#optionsstar}{\tt options.\+star}
\item \href{#optionssnapdragon}{\tt options.\+snapdragon}
\item \href{#optionssourcemap}{\tt options.\+sourcemap}
\item \href{#optionsunescape}{\tt options.\+unescape}
\item \href{#optionsunixify}{\tt options.\+unixify}
\end{DoxyItemize}
\item \href{#features}{\tt Features}
\item \href{#bash-expansion-libs}{\tt Bash expansion libs}
\item \href{#benchmarks}{\tt Benchmarks}
\begin{DoxyItemize}
\item \href{#running-benchmarks}{\tt Running benchmarks}
\item \href{#nanomatch-vs-minimatch-vs-multimatch}{\tt Nanomatch vs. Minimatch vs. Multimatch}
\end{DoxyItemize}
\item \href{#about}{\tt About}
\end{DoxyItemize}

$<$/details$>$

\subsection*{Install}

Install with \href{https://www.npmjs.com/}{\tt npm}\+:


\begin{DoxyCode}
$ npm install --save nanomatch
\end{DoxyCode}


$<$details$>$ 

{\bfseries Release history}

\subsection*{History}

\subsubsection*{key}

Changelog entries are classified using the following labels \+\_\+(from \href{https://github.com/olivierlacan/keep-a-changelog}{\tt keep-\/a-\/changelog}\+\_\+)\+:


\begin{DoxyItemize}
\item {\ttfamily added}\+: for new features
\item {\ttfamily changed}\+: for changes in existing functionality
\item {\ttfamily deprecated}\+: for once-\/stable features removed in upcoming releases
\item {\ttfamily removed}\+: for deprecated features removed in this release
\item {\ttfamily fixed}\+: for any bug fixes
\item {\ttfamily bumped}\+: updated dependencies, only minor or higher will be listed.
\end{DoxyItemize}

\subsubsection*{\href{https://github.com/micromatch/nanomatch/compare/1.0.4...1.1.0}{\tt 1.\+1.\+0} -\/ 2017-\/04-\/11}

{\bfseries Fixed}


\begin{DoxyItemize}
\item adds support for unclosed quotes
\end{DoxyItemize}

{\bfseries Added}


\begin{DoxyItemize}
\item adds support for {\ttfamily options.\+noglobstar}
\end{DoxyItemize}

\subsubsection*{\href{https://github.com/micromatch/nanomatch/compare/1.0.3...1.0.4}{\tt 1.\+0.\+4} -\/ 2017-\/04-\/06}

Housekeeping updates. Adds documentation section about escaping, cleans up utils.

\subsubsection*{\href{https://github.com/micromatch/nanomatch/compare/1.0.1...1.0.3}{\tt 1.\+0.\+3} -\/ 2017-\/04-\/06}

This release includes fixes for windows path edge cases and other improvements for stricter adherence to bash spec.

{\bfseries Fixed}


\begin{DoxyItemize}
\item More windows path edge cases
\end{DoxyItemize}

{\bfseries Added}


\begin{DoxyItemize}
\item Support for bash-\/like quoted strings for escaping sequences of characters, such as {\ttfamily foo/\char`\"{}$\ast$$\ast$\char`\"{}/bar} where {\ttfamily $\ast$$\ast$} should be matched literally and not evaluated as special characters.
\end{DoxyItemize}

\subsubsection*{\href{https://github.com/micromatch/nanomatch/compare/1.0.0...1.0.1}{\tt 1.\+0.\+1} -\/ 2016-\/12-\/12}

{\bfseries Added}


\begin{DoxyItemize}
\item Support for windows path edge cases where backslashes are used in brackets or other unusual combinations.
\end{DoxyItemize}

\subsubsection*{\href{https://github.com/micromatch/nanomatch/compare/0.1.0...1.0.0}{\tt 1.\+0.\+0} -\/ 2016-\/12-\/12}

Stable release.

\subsubsection*{\mbox{[}0.\+1.\+0\mbox{]} -\/ 2016-\/10-\/08}

First release.

$<$/details$>$

\subsection*{What is nanomatch?}

Nanomatch is a fast and accurate glob matcher with full support for standard Bash glob features, including the following \char`\"{}metacharacters\char`\"{}\+: {\ttfamily $\ast$}, {\ttfamily $\ast$$\ast$}, {\ttfamily ?} and {\ttfamily \mbox{[}...\mbox{]}}.

{\bfseries Learn more}


\begin{DoxyItemize}
\item \href{#getting-started}{\tt Getting started}\+: learn how to install and begin using nanomatch
\item \href{#features}{\tt Features}\+: jump to info about supported patterns, and a glob matching reference
\item \href{#api}{\tt A\+PI documentation}\+: jump to available options and methods
\item \mbox{[}Unit tests\mbox{]}(test)\+: visit unit tests. there is no better way to learn a code library than spending time the unit tests. Nanomatch has 36,000 unit tests -\/ go become a glob matching ninja!
\end{DoxyItemize}

$<$details$>$ 

{\bfseries How is this different?}

{\bfseries Speed and accuracy}

Nanomatch uses \href{https://github.com/jonschlinkert/snapdragon}{\tt snapdragon} for parsing and compiling globs, which results in\+:


\begin{DoxyItemize}
\item Granular control over the entire conversion process in a way that is easy to understand, reason about, and customize.
\item Faster matching, from a combination of optimized glob patterns and (optional) caching.
\item Much greater accuracy than minimatch. In fact, nanomatch passes {\itshape all of the spec tests} from bash, including some that bash still fails. However, since there is no real specification for globs, if you encounter a pattern that yields unexpected match results \href{../../issues}{\tt after researching previous issues}, \href{../../issues/new}{\tt please let us know}.
\end{DoxyItemize}

{\bfseries Basic globbing only}

Nanomatch supports \href{#features}{\tt basic globbing only}, which is limited to {\ttfamily $\ast$}, {\ttfamily $\ast$$\ast$}, {\ttfamily ?} and regex-\/like brackets.

If you need support for the other \href{#bash-expansion-libs}{\tt bash \char`\"{}expansion\char`\"{} types} (in addition to the wildcard matching provided by nanomatch), consider using \href{https://github.com/micromatch/micromatch}{\tt micromatch} instead. \+\_\+(micromatch $>$=3.\+0.\+0 uses the nanomatch parser and compiler for basic glob matching)\+\_\+

$<$/details$>$

\subsection*{Getting started}

\subsubsection*{Installing nanomatch}

{\bfseries Install with \href{https://yarnpkg.com/}{\tt yarn}}


\begin{DoxyCode}
$ yarn add nanomatch
\end{DoxyCode}


{\bfseries Install with \href{https://npmjs.com}{\tt npm}}


\begin{DoxyCode}
$ npm install nanomatch
\end{DoxyCode}


\subsubsection*{Usage}

Add nanomatch to your project using node\textquotesingle{}s {\ttfamily require()} system\+:


\begin{DoxyCode}
var nanomatch = require('nanomatch');

// the main export is a function that takes an array of strings to match
// and a string or array of patterns to use for matching
nanomatch(list, patterns[, options]);
\end{DoxyCode}


{\bfseries Params}


\begin{DoxyItemize}
\item {\ttfamily list} $\ast$$\ast$\{String$\vert$\+Array\}$\ast$$\ast$\+: List of strings to perform matches against. This is often a list of file paths.
\item {\ttfamily patterns} $\ast$$\ast$\{String$\vert$\+Array\}$\ast$$\ast$\+: One or more \href{#features}{\tt glob paterns} to use for matching.
\item {\ttfamily options} $\ast$$\ast$\{Object\}$\ast$$\ast$\+: Any \href{#options}{\tt supported options} may be passed
\end{DoxyItemize}

{\bfseries Examples}


\begin{DoxyCode}
var nm = require('nanomatch');
console.log(nm(['a', 'b/b', 'c/c/c'], '*'));
//=> ['a']

console.log(nm(['a', 'b/b', 'c/c/c'], '*/*'));
//=> ['b/b']

console.log(nm(['a', 'b/b', 'c/c/c'], '**'));
//=> ['a', 'b/b', 'c/c/c']
\end{DoxyCode}


See the \href{#api}{\tt A\+PI documentation} for available methods and \href{https://github.com/einaros/options.js}{\tt options}.

\subsection*{Documentation}

\subsubsection*{Escaping}

{\itshape Backslashes and quotes} can be used to escape characters, forcing nanomatch to regard those characters as a literal characters.

{\bfseries Backslashes}

Use backslashes to escape single characters. For example, the following pattern would match {\ttfamily foo/$\ast$/bar} exactly\+:


\begin{DoxyCode}
'foo/\(\backslash\)*/bar'
\end{DoxyCode}


The following pattern would match {\ttfamily foo/} followed by a literal {\ttfamily $\ast$}, followed by zero or more of any characters besides {\ttfamily /}, followed by {\ttfamily /bar}.


\begin{DoxyCode}
'foo/\(\backslash\)**/bar'
\end{DoxyCode}


{\bfseries Quoted strings}

Use single or double quotes to escape sequences of characters. For example, the following patterns would match {\ttfamily foo/$\ast$$\ast$/bar} exactly\+:


\begin{DoxyCode}
'foo/"**"/bar'
'foo/\(\backslash\)'**\(\backslash\)'/bar'
"foo/'**'/bar"
\end{DoxyCode}


{\bfseries Matching literal quotes}

If you need to match quotes literally, you can escape them as well. For example, the following will match {\ttfamily foo/\char`\"{}$\ast$\char`\"{}/bar}, {\ttfamily foo/\char`\"{}a\char`\"{}/bar}, {\ttfamily foo/\char`\"{}b\char`\"{}/bar}, or {\ttfamily foo/\char`\"{}c\char`\"{}/bar}\+:


\begin{DoxyCode}
'foo/\(\backslash\)\(\backslash\)"*\(\backslash\)\(\backslash\)"/bar'
\end{DoxyCode}


And the following will match `foo/'$\ast$\textquotesingle{}/bar{\ttfamily ,}foo/\textquotesingle{}a\textquotesingle{}/bar{\ttfamily ,}foo/\textquotesingle{}b\textquotesingle{}/bar{\ttfamily , or}foo/\textquotesingle{}c\textquotesingle{}/bar\`{}\+:


\begin{DoxyCode}
'foo/\(\backslash\)\(\backslash\)\(\backslash\)'*\(\backslash\)\(\backslash\)\(\backslash\)'/bar'
\end{DoxyCode}


\subsection*{A\+PI}

\subsubsection*{\href{index.js#L40}{\tt nanomatch}}

The main function takes a list of strings and one or more glob patterns to use for matching.

{\bfseries Params}


\begin{DoxyItemize}
\item {\ttfamily list} $\ast$$\ast$\{Array\}$\ast$$\ast$\+: A list of strings to match
\item {\ttfamily patterns} $\ast$$\ast$\{String$\vert$\+Array\}$\ast$$\ast$\+: One or more glob patterns to use for matching.
\item {\ttfamily options} $\ast$$\ast$\{Object\}$\ast$$\ast$\+: See available \href{#options}{\tt options} for changing how matches are performed
\item {\ttfamily returns} $\ast$$\ast$\{Array\}$\ast$$\ast$\+: Returns an array of matches
\end{DoxyItemize}

{\bfseries Example}


\begin{DoxyCode}
var nm = require('nanomatch');
nm(list, patterns[, options]);

console.log(nm(['a.js', 'a.txt'], ['*.js']));
//=> [ 'a.js' ]
\end{DoxyCode}


\subsubsection*{\href{index.js#L106}{\tt .match}}

Similar to the main function, but {\ttfamily pattern} must be a string.

{\bfseries Params}


\begin{DoxyItemize}
\item {\ttfamily list} $\ast$$\ast$\{Array\}$\ast$$\ast$\+: Array of strings to match
\item {\ttfamily pattern} $\ast$$\ast$\{String\}$\ast$$\ast$\+: Glob pattern to use for matching.
\item {\ttfamily options} $\ast$$\ast$\{Object\}$\ast$$\ast$\+: See available \href{#options}{\tt options} for changing how matches are performed
\item {\ttfamily returns} $\ast$$\ast$\{Array\}$\ast$$\ast$\+: Returns an array of matches
\end{DoxyItemize}

{\bfseries Example}


\begin{DoxyCode}
var nm = require('nanomatch');
nm.match(list, pattern[, options]);

console.log(nm.match(['a.a', 'a.aa', 'a.b', 'a.c'], '*.a'));
//=> ['a.a', 'a.aa']
\end{DoxyCode}


\subsubsection*{\href{index.js#L167}{\tt .is\+Match}}

Returns true if the specified {\ttfamily string} matches the given glob {\ttfamily pattern}.

{\bfseries Params}


\begin{DoxyItemize}
\item {\ttfamily string} $\ast$$\ast$\{String\}$\ast$$\ast$\+: String to match
\item {\ttfamily pattern} $\ast$$\ast$\{String\}$\ast$$\ast$\+: Glob pattern to use for matching.
\item {\ttfamily options} $\ast$$\ast$\{Object\}$\ast$$\ast$\+: See available \href{#options}{\tt options} for changing how matches are performed
\item {\ttfamily returns} $\ast$$\ast$\{Boolean\}$\ast$$\ast$\+: Returns true if the string matches the glob pattern.
\end{DoxyItemize}

{\bfseries Example}


\begin{DoxyCode}
var nm = require('nanomatch');
nm.isMatch(string, pattern[, options]);

console.log(nm.isMatch('a.a', '*.a'));
//=> true
console.log(nm.isMatch('a.b', '*.a'));
//=> false
\end{DoxyCode}


\subsubsection*{\href{index.js#L205}{\tt .some}}

Returns true if some of the elements in the given {\ttfamily list} match any of the given glob {\ttfamily patterns}.

{\bfseries Params}


\begin{DoxyItemize}
\item {\ttfamily list} $\ast$$\ast$\{String$\vert$\+Array\}$\ast$$\ast$\+: The string or array of strings to test. Returns as soon as the first match is found.
\item {\ttfamily patterns} $\ast$$\ast$\{String$\vert$\+Array\}$\ast$$\ast$\+: One or more glob patterns to use for matching.
\item {\ttfamily options} $\ast$$\ast$\{Object\}$\ast$$\ast$\+: See available \href{#options}{\tt options} for changing how matches are performed
\item {\ttfamily returns} $\ast$$\ast$\{Boolean\}$\ast$$\ast$\+: Returns true if any patterns match {\ttfamily str}
\end{DoxyItemize}

{\bfseries Example}


\begin{DoxyCode}
var nm = require('nanomatch');
nm.some(list, patterns[, options]);

console.log(nm.some(['foo.js', 'bar.js'], ['*.js', '!foo.js']));
// true
console.log(nm.some(['foo.js'], ['*.js', '!foo.js']));
// false
\end{DoxyCode}


\subsubsection*{\href{index.js#L243}{\tt .every}}

Returns true if every element in the given {\ttfamily list} matches at least one of the given glob {\ttfamily patterns}.

{\bfseries Params}


\begin{DoxyItemize}
\item {\ttfamily list} $\ast$$\ast$\{String$\vert$\+Array\}$\ast$$\ast$\+: The string or array of strings to test.
\item {\ttfamily patterns} $\ast$$\ast$\{String$\vert$\+Array\}$\ast$$\ast$\+: One or more glob patterns to use for matching.
\item {\ttfamily options} $\ast$$\ast$\{Object\}$\ast$$\ast$\+: See available \href{#options}{\tt options} for changing how matches are performed
\item {\ttfamily returns} $\ast$$\ast$\{Boolean\}$\ast$$\ast$\+: Returns true if any patterns match {\ttfamily str}
\end{DoxyItemize}

{\bfseries Example}


\begin{DoxyCode}
var nm = require('nanomatch');
nm.every(list, patterns[, options]);

console.log(nm.every('foo.js', ['foo.js']));
// true
console.log(nm.every(['foo.js', 'bar.js'], ['*.js']));
// true
console.log(nm.every(['foo.js', 'bar.js'], ['*.js', '!foo.js']));
// false
console.log(nm.every(['foo.js'], ['*.js', '!foo.js']));
// false
\end{DoxyCode}


\subsubsection*{\href{index.js#L277}{\tt .any}}

Returns true if {\bfseries any} of the given glob {\ttfamily patterns} match the specified {\ttfamily string}.

{\bfseries Params}


\begin{DoxyItemize}
\item {\ttfamily str} $\ast$$\ast$\{String$\vert$\+Array\}$\ast$$\ast$\+: The string to test.
\item {\ttfamily patterns} $\ast$$\ast$\{String$\vert$\+Array\}$\ast$$\ast$\+: One or more glob patterns to use for matching.
\item {\ttfamily options} $\ast$$\ast$\{Object\}$\ast$$\ast$\+: See available \href{#options}{\tt options} for changing how matches are performed
\item {\ttfamily returns} $\ast$$\ast$\{Boolean\}$\ast$$\ast$\+: Returns true if any patterns match {\ttfamily str}
\end{DoxyItemize}

{\bfseries Example}


\begin{DoxyCode}
var nm = require('nanomatch');
nm.any(string, patterns[, options]);

console.log(nm.any('a.a', ['b.*', '*.a']));
//=> true
console.log(nm.any('a.a', 'b.*'));
//=> false
\end{DoxyCode}


\subsubsection*{\href{index.js#L325}{\tt .all}}

Returns true if {\bfseries all} of the given {\ttfamily patterns} match the specified string.

{\bfseries Params}


\begin{DoxyItemize}
\item {\ttfamily str} $\ast$$\ast$\{String$\vert$\+Array\}$\ast$$\ast$\+: The string to test.
\item {\ttfamily patterns} $\ast$$\ast$\{String$\vert$\+Array\}$\ast$$\ast$\+: One or more glob patterns to use for matching.
\item {\ttfamily options} $\ast$$\ast$\{Object\}$\ast$$\ast$\+: See available \href{#options}{\tt options} for changing how matches are performed
\item {\ttfamily returns} $\ast$$\ast$\{Boolean\}$\ast$$\ast$\+: Returns true if any patterns match {\ttfamily str}
\end{DoxyItemize}

{\bfseries Example}


\begin{DoxyCode}
var nm = require('nanomatch');
nm.all(string, patterns[, options]);

console.log(nm.all('foo.js', ['foo.js']));
// true

console.log(nm.all('foo.js', ['*.js', '!foo.js']));
// false

console.log(nm.all('foo.js', ['*.js', 'foo.js']));
// true

console.log(nm.all('foo.js', ['*.js', 'f*', '*o*', '*o.js']));
// true
\end{DoxyCode}


\subsubsection*{\href{index.js#L359}{\tt .not}}

Returns a list of strings that {\itshape {\bfseries do not match any}} of the given {\ttfamily patterns}.

{\bfseries Params}


\begin{DoxyItemize}
\item {\ttfamily list} $\ast$$\ast$\{Array\}$\ast$$\ast$\+: Array of strings to match.
\item {\ttfamily patterns} $\ast$$\ast$\{String$\vert$\+Array\}$\ast$$\ast$\+: One or more glob pattern to use for matching.
\item {\ttfamily options} $\ast$$\ast$\{Object\}$\ast$$\ast$\+: See available \href{#options}{\tt options} for changing how matches are performed
\item {\ttfamily returns} $\ast$$\ast$\{Array\}$\ast$$\ast$\+: Returns an array of strings that {\bfseries do not match} the given patterns.
\end{DoxyItemize}

{\bfseries Example}


\begin{DoxyCode}
var nm = require('nanomatch');
nm.not(list, patterns[, options]);

console.log(nm.not(['a.a', 'b.b', 'c.c'], '*.a'));
//=> ['b.b', 'c.c']
\end{DoxyCode}


\subsubsection*{\href{index.js#L394}{\tt .contains}}

Returns true if the given {\ttfamily string} contains the given pattern. Similar to \href{#isMatch}{\tt .is\+Match} but the pattern can match any part of the string.

{\bfseries Params}


\begin{DoxyItemize}
\item {\ttfamily str} $\ast$$\ast$\{String\}$\ast$$\ast$\+: The string to match.
\item {\ttfamily patterns} $\ast$$\ast$\{String$\vert$\+Array\}$\ast$$\ast$\+: Glob pattern to use for matching.
\item {\ttfamily options} $\ast$$\ast$\{Object\}$\ast$$\ast$\+: See available \href{#options}{\tt options} for changing how matches are performed
\item {\ttfamily returns} $\ast$$\ast$\{Boolean\}$\ast$$\ast$\+: Returns true if the patter matches any part of {\ttfamily str}.
\end{DoxyItemize}

{\bfseries Example}


\begin{DoxyCode}
var nm = require('nanomatch');
nm.contains(string, pattern[, options]);

console.log(nm.contains('aa/bb/cc', '*b'));
//=> true
console.log(nm.contains('aa/bb/cc', '*d'));
//=> false
\end{DoxyCode}


\subsubsection*{\href{index.js#L450}{\tt .match\+Keys}}

Filter the keys of the given object with the given {\ttfamily glob} pattern and {\ttfamily options}. Does not attempt to match nested keys. If you need this feature, use \href{https://github.com/jonschlinkert/glob-object}{\tt glob-\/object} instead.

{\bfseries Params}


\begin{DoxyItemize}
\item {\ttfamily object} $\ast$$\ast$\{Object\}$\ast$$\ast$\+: The object with keys to filter.
\item {\ttfamily patterns} $\ast$$\ast$\{String$\vert$\+Array\}$\ast$$\ast$\+: One or more glob patterns to use for matching.
\item {\ttfamily options} $\ast$$\ast$\{Object\}$\ast$$\ast$\+: See available \href{#options}{\tt options} for changing how matches are performed
\item {\ttfamily returns} $\ast$$\ast$\{Object\}$\ast$$\ast$\+: Returns an object with only keys that match the given patterns.
\end{DoxyItemize}

{\bfseries Example}


\begin{DoxyCode}
var nm = require('nanomatch');
nm.matchKeys(object, patterns[, options]);

var obj = \{ aa: 'a', ab: 'b', ac: 'c' \};
console.log(nm.matchKeys(obj, '*b'));
//=> \{ ab: 'b' \}
\end{DoxyCode}


\subsubsection*{\href{index.js#L479}{\tt .matcher}}

Returns a memoized matcher function from the given glob {\ttfamily pattern} and {\ttfamily options}. The returned function takes a string to match as its only argument and returns true if the string is a match.

{\bfseries Params}


\begin{DoxyItemize}
\item {\ttfamily pattern} $\ast$$\ast$\{String\}$\ast$$\ast$\+: Glob pattern
\item {\ttfamily options} $\ast$$\ast$\{Object\}$\ast$$\ast$\+: See available \href{#options}{\tt options} for changing how matches are performed.
\item {\ttfamily returns} $\ast$$\ast$\{Function\}$\ast$$\ast$\+: Returns a matcher function.
\end{DoxyItemize}

{\bfseries Example}


\begin{DoxyCode}
var nm = require('nanomatch');
nm.matcher(pattern[, options]);

var isMatch = nm.matcher('*.!(*a)');
console.log(isMatch('a.a'));
//=> false
console.log(isMatch('a.b'));
//=> true
\end{DoxyCode}


\subsubsection*{\href{index.js#L560}{\tt .capture}}

Returns an array of matches captured by {\ttfamily pattern} in {\ttfamily string, or}null\`{} if the pattern did not match.

{\bfseries Params}


\begin{DoxyItemize}
\item {\ttfamily pattern} $\ast$$\ast$\{String\}$\ast$$\ast$\+: Glob pattern to use for matching.
\item {\ttfamily string} $\ast$$\ast$\{String\}$\ast$$\ast$\+: String to match
\item {\ttfamily options} $\ast$$\ast$\{Object\}$\ast$$\ast$\+: See available \href{#options}{\tt options} for changing how matches are performed
\item {\ttfamily returns} $\ast$$\ast$\{Boolean\}$\ast$$\ast$\+: Returns an array of captures if the string matches the glob pattern, otherwise {\ttfamily null}.
\end{DoxyItemize}

{\bfseries Example}


\begin{DoxyCode}
var nm = require('nanomatch');
nm.capture(pattern, string[, options]);

console.log(nm.capture('test/*.js', 'test/foo.js'));
//=> ['foo']
console.log(nm.capture('test/*.js', 'foo/bar.css'));
//=> null
\end{DoxyCode}


\subsubsection*{\href{index.js#L595}{\tt .make\+Re}}

Create a regular expression from the given glob {\ttfamily pattern}.

{\bfseries Params}


\begin{DoxyItemize}
\item {\ttfamily pattern} $\ast$$\ast$\{String\}$\ast$$\ast$\+: A glob pattern to convert to regex.
\item {\ttfamily options} $\ast$$\ast$\{Object\}$\ast$$\ast$\+: See available \href{#options}{\tt options} for changing how matches are performed.
\item {\ttfamily returns} $\ast$$\ast$\{Reg\+Exp\}$\ast$$\ast$\+: Returns a regex created from the given pattern.
\end{DoxyItemize}

{\bfseries Example}


\begin{DoxyCode}
var nm = require('nanomatch');
nm.makeRe(pattern[, options]);

console.log(nm.makeRe('*.js'));
//=> /^(?:(\(\backslash\).[\(\backslash\)\(\backslash\)\(\backslash\)/])?(?!\(\backslash\).)(?=.)[^\(\backslash\)/]*?\(\backslash\).js)$/
\end{DoxyCode}


\subsubsection*{\href{index.js#L658}{\tt .create}}

Parses the given glob {\ttfamily pattern} and returns an object with the compiled {\ttfamily output} and optional source {\ttfamily map}.

{\bfseries Params}


\begin{DoxyItemize}
\item {\ttfamily pattern} $\ast$$\ast$\{String\}$\ast$$\ast$\+: Glob pattern to parse and compile.
\item {\ttfamily options} $\ast$$\ast$\{Object\}$\ast$$\ast$\+: Any \href{#options}{\tt options} to change how parsing and compiling is performed.
\item {\ttfamily returns} $\ast$$\ast$\{Object\}$\ast$$\ast$\+: Returns an object with the parsed A\+ST, compiled string and optional source map.
\end{DoxyItemize}

{\bfseries Example}


\begin{DoxyCode}
var nm = require('nanomatch');
nm.create(pattern[, options]);

console.log(nm.create('abc/*.js'));
// \{ options: \{ source: 'string', sourcemap: true \},
//   state: \{\},
//   compilers:
//    \{ ... \},
//   output: '(\(\backslash\)\(\backslash\).[\(\backslash\)\(\backslash\)\(\backslash\)\(\backslash\)\(\backslash\)\(\backslash\)/])?abc\(\backslash\)\(\backslash\)/(?!\(\backslash\)\(\backslash\).)(?=.)[^\(\backslash\)\(\backslash\)/]*?\(\backslash\)\(\backslash\).js',
//   ast:
//    \{ type: 'root',
//      errors: [],
//      nodes:
//       [ ... ],
//      dot: false,
//      input: 'abc/*.js' \},
//   parsingErrors: [],
//   map:
//    \{ version: 3,
//      sources: [ 'string' ],
//      names: [],
//      mappings: 'AAAA,GAAG,EAAC,kBAAC,EAAC,EAAE',
//      sourcesContent: [ 'abc/*.js' ] \},
//   position: \{ line: 1, column: 28 \},
//   content: \{\},
//   files: \{\},
//   idx: 6 \}
\end{DoxyCode}


\subsubsection*{\href{index.js#L697}{\tt .parse}}

Parse the given {\ttfamily str} with the given {\ttfamily options}.

{\bfseries Params}


\begin{DoxyItemize}
\item {\ttfamily str} $\ast$$\ast$\{String\}$\ast$$\ast$
\item {\ttfamily options} $\ast$$\ast$\{Object\}$\ast$$\ast$
\item {\ttfamily returns} $\ast$$\ast$\{Object\}$\ast$$\ast$\+: Returns an A\+ST
\end{DoxyItemize}

{\bfseries Example}


\begin{DoxyCode}
var nm = require('nanomatch');
nm.parse(pattern[, options]);

var ast = nm.parse('a/\{b,c\}/d');
console.log(ast);
// \{ type: 'root',
//   errors: [],
//   input: 'a/\{b,c\}/d',
//   nodes:
//    [ \{ type: 'bos', val: '' \},
//      \{ type: 'text', val: 'a/' \},
//      \{ type: 'brace',
//        nodes:
//         [ \{ type: 'brace.open', val: '\{' \},
//           \{ type: 'text', val: 'b,c' \},
//           \{ type: 'brace.close', val: '\}' \} ] \},
//      \{ type: 'text', val: '/d' \},
//      \{ type: 'eos', val: '' \} ] \}
\end{DoxyCode}


\subsubsection*{\href{index.js#L745}{\tt .compile}}

Compile the given {\ttfamily ast} or string with the given {\ttfamily options}.

{\bfseries Params}


\begin{DoxyItemize}
\item {\ttfamily ast} $\ast$$\ast$\{Object$\vert$\+String\}$\ast$$\ast$
\item {\ttfamily options} $\ast$$\ast$\{Object\}$\ast$$\ast$
\item {\ttfamily returns} $\ast$$\ast$\{Object\}$\ast$$\ast$\+: Returns an object that has an {\ttfamily output} property with the compiled string.
\end{DoxyItemize}

{\bfseries Example}


\begin{DoxyCode}
var nm = require('nanomatch');
nm.compile(ast[, options]);

var ast = nm.parse('a/\{b,c\}/d');
console.log(nm.compile(ast));
// \{ options: \{ source: 'string' \},
//   state: \{\},
//   compilers:
//    \{ eos: [Function],
//      noop: [Function],
//      bos: [Function],
//      brace: [Function],
//      'brace.open': [Function],
//      text: [Function],
//      'brace.close': [Function] \},
//   output: [ 'a/(b|c)/d' ],
//   ast:
//    \{ ... \},
//   parsingErrors: [] \}
\end{DoxyCode}


\subsubsection*{\href{index.js#L768}{\tt .clear\+Cache}}

Clear the regex cache.

{\bfseries Example}


\begin{DoxyCode}
nm.clearCache();
\end{DoxyCode}


\subsection*{Options}

$<$details$>$ 

{\bfseries basename}

\subsubsection*{options.\+basename}

Allow glob patterns without slashes to match a file path based on its basename. Same behavior as \href{https://github.com/isaacs/minimatch}{\tt minimatch} option {\ttfamily match\+Base}.

Type\+: {\ttfamily boolean}

Default\+: {\ttfamily false}

{\bfseries Example}


\begin{DoxyCode}
nm(['a/b.js', 'a/c.md'], '*.js');
//=> []

nm(['a/b.js', 'a/c.md'], '*.js', \{matchBase: true\});
//=> ['a/b.js']
\end{DoxyCode}


$<$/details$>$

$<$details$>$ 

{\bfseries bash}

\subsubsection*{options.\+bash}

Enabled by default, this option enforces bash-\/like behavior with stars immediately following a bracket expression. Bash bracket expressions are similar to regex character classes, but unlike regex, a star following a bracket expression {\bfseries does not repeat the bracketed characters}. Instead, the star is treated the same as an other star.

Type\+: {\ttfamily boolean}

Default\+: {\ttfamily true}

{\bfseries Example}


\begin{DoxyCode}
var files = ['abc', 'ajz'];
console.log(nm(files, '[a-c]*'));
//=> ['abc', 'ajz']

console.log(nm(files, '[a-c]*', \{bash: false\}));
\end{DoxyCode}


$<$/details$>$

$<$details$>$ 

{\bfseries cache}

\subsubsection*{options.\+cache}

Disable regex and function memoization.

Type\+: {\ttfamily boolean}

Default\+: {\ttfamily undefined}

$<$/details$>$

$<$details$>$ 

{\bfseries dot}

\subsubsection*{options.\+dot}

Match dotfiles. Same behavior as \href{https://github.com/isaacs/minimatch}{\tt minimatch} option {\ttfamily dot}.

Type\+: {\ttfamily boolean}

Default\+: {\ttfamily false}

$<$/details$>$

$<$details$>$ 

{\bfseries failglob}

\subsubsection*{options.\+failglob}

Similar to the {\ttfamily -\/-\/failglob} behavior in Bash, throws an error when no matches are found.

Type\+: {\ttfamily boolean}

Default\+: {\ttfamily undefined}

$<$/details$>$

$<$details$>$ 

{\bfseries ignore}

\subsubsection*{options.\+ignore}

String or array of glob patterns to match files to ignore.

Type\+: {\ttfamily String$\vert$\+Array}

Default\+: {\ttfamily undefined}

$<$/details$>$

$<$details$>$ 

{\bfseries match\+Base}

\subsubsection*{options.\+match\+Base}

Alias for \href{#options-basename}{\tt options.\+basename}.

$<$/details$>$

$<$details$>$ 

{\bfseries nocase}

\subsubsection*{options.\+nocase}

Use a case-\/insensitive regex for matching files. Same behavior as \href{https://github.com/isaacs/minimatch}{\tt minimatch}.

Type\+: {\ttfamily boolean}

Default\+: {\ttfamily undefined}

$<$/details$>$

$<$details$>$ 

{\bfseries nodupes}

\subsubsection*{options.\+nodupes}

Remove duplicate elements from the result array.

Type\+: {\ttfamily boolean}

Default\+: {\ttfamily true} (enabled by default)

{\bfseries Example}

Example of using the {\ttfamily unescape} and {\ttfamily nodupes} options together\+:


\begin{DoxyCode}
nm.match(['a/b/c', 'a/b/c'], '**');
//=> ['abc']

nm.match(['a/b/c', 'a/b/c'], '**', \{nodupes: false\});
//=> ['a/b/c', 'a/b/c']
\end{DoxyCode}


$<$/details$>$

$<$details$>$ 

{\bfseries nonegate}

\subsubsection*{options.\+noglobstar}

Disable matching with globstars ({\ttfamily $\ast$$\ast$}).

Type\+: {\ttfamily boolean}

Default\+: {\ttfamily undefined}


\begin{DoxyCode}
nm(['a/b', 'a/b/c', 'a/b/c/d'], 'a/**');
//=> ['a/b', 'a/b/c', 'a/b/c/d']

nm(['a/b', 'a/b/c', 'a/b/c/d'], 'a/**', \{noglobstar: true\});
//=> ['a/b']
\end{DoxyCode}


$<$/details$>$

$<$details$>$ 

{\bfseries nonegate}

\subsubsection*{options.\+nonegate}

Disallow negation ({\ttfamily !}) patterns, and treat leading {\ttfamily !} as a literal character to match.

Type\+: {\ttfamily boolean}

Default\+: {\ttfamily undefined}

$<$/details$>$

$<$details$>$ 

{\bfseries nonull}

\subsubsection*{options.\+nonull}

Alias for \href{#options-nullglob}{\tt options.\+nullglob}.

$<$/details$>$

$<$details$>$ 

{\bfseries nullglob}

\subsubsection*{options.\+nullglob}

If {\ttfamily true}, when no matches are found the actual (arrayified) glob pattern is returned instead of an empty array. Same behavior as \href{https://github.com/isaacs/minimatch}{\tt minimatch} option {\ttfamily nonull}.

Type\+: {\ttfamily boolean}

Default\+: {\ttfamily undefined}

$<$/details$>$

$<$details$>$ 

{\bfseries \label{_slash}%
slash}

\subsubsection*{options.\+slash}

Customize the slash character(s) to use for matching.

Type\+: {\ttfamily string$\vert$function}

Default\+: {\ttfamily \mbox{[}/\textbackslash{}\textbackslash{}\mbox{]}} (forward slash and backslash)

$<$/details$>$

$<$details$>$ 

{\bfseries \label{_star}%
star}

\subsubsection*{options.\+star}

Customize the star character(s) to use for matching. It\textquotesingle{}s not recommended that you modify this unless you have advanced knowledge of the compiler and matching rules.

Type\+: {\ttfamily string$\vert$function}

Default\+: {\ttfamily \mbox{[}$^\wedge$/\textbackslash{}\textbackslash{}\mbox{]}$\ast$?}

$<$/details$>$

$<$details$>$ 

{\bfseries \label{_snapdragon}%
snapdragon}

\subsubsection*{options.\+snapdragon}

Pass your own instance of \href{https://github.com/jonschlinkert/snapdragon}{\tt snapdragon} to customize parsers or compilers.

Type\+: {\ttfamily object}

Default\+: {\ttfamily undefined}

$<$/details$>$

$<$details$>$ 

{\bfseries snapdragon}

\subsubsection*{options.\+sourcemap}

Generate a source map by enabling the {\ttfamily sourcemap} option with the {\ttfamily .parse}, {\ttfamily .compile}, or {\ttfamily .create} methods.

{\bfseries Examples}


\begin{DoxyCode}
var nm = require('nanomatch');

var res = nm.create('abc/*.js', \{sourcemap: true\});
console.log(res.map);
// \{ version: 3,
//   sources: [ 'string' ],
//   names: [],
//   mappings: 'AAAA,GAAG,EAAC,iBAAC,EAAC,EAAE',
//   sourcesContent: [ 'abc/*.js' ] \}

var ast = nm.parse('abc/**/*.js');
var res = nm.compile(ast, \{sourcemap: true\});
console.log(res.map);
// \{ version: 3,
//   sources: [ 'string' ],
//   names: [],
//   mappings: 'AAAA,GAAG,EAAC,2BAAE,EAAC,iBAAC,EAAC,EAAE',
//   sourcesContent: [ 'abc/**/*.js' ] \}
\end{DoxyCode}


$<$/details$>$

$<$details$>$ 

{\bfseries unescape}

\subsubsection*{options.\+unescape}

Remove backslashes from returned matches.

Type\+: {\ttfamily boolean}

Default\+: {\ttfamily undefined}

{\bfseries Example}

In this example we want to match a literal {\ttfamily $\ast$}\+:


\begin{DoxyCode}
nm.match(['abc', 'a\(\backslash\)\(\backslash\)*c'], 'a\(\backslash\)\(\backslash\)*c');
//=> ['a\(\backslash\)\(\backslash\)*c']

nm.match(['abc', 'a\(\backslash\)\(\backslash\)*c'], 'a\(\backslash\)\(\backslash\)*c', \{unescape: true\});
//=> ['a*c']
\end{DoxyCode}


$<$/details$>$

$<$details$>$ 

{\bfseries unixify}

\subsubsection*{options.\+unixify}

Convert path separators on returned files to posix/unix-\/style forward slashes.

Type\+: {\ttfamily boolean}

Default\+: {\ttfamily true}

{\bfseries Example}


\begin{DoxyCode}
nm.match(['a\(\backslash\)\(\backslash\)b\(\backslash\)\(\backslash\)c'], 'a/**');
//=> ['a/b/c']

nm.match(['a\(\backslash\)\(\backslash\)b\(\backslash\)\(\backslash\)c'], \{unixify: false\});
//=> ['a\(\backslash\)\(\backslash\)b\(\backslash\)\(\backslash\)c']
\end{DoxyCode}


$<$/details$>$

\subsection*{Features}

Nanomatch has full support for standard Bash glob features, including the following \char`\"{}metacharacters\char`\"{}\+: {\ttfamily $\ast$}, {\ttfamily $\ast$$\ast$}, {\ttfamily ?} and {\ttfamily \mbox{[}...\mbox{]}}.

Here are some examples of how they work\+:

\tabulinesep=1mm
\begin{longtabu} spread 0pt [c]{*{2}{|X[-1]}|}
\hline
\rowcolor{\tableheadbgcolor}\multicolumn{2}{|p{(\linewidth-\tabcolsep*2-\arrayrulewidth*1)*2/2}|}{\cellcolor{\tableheadbgcolor}\textbf{ $\ast$$\ast$\+Pattern$\ast$   }}\\\cline{1-2}
\endfirsthead
\hline
\endfoot
\hline
\rowcolor{\tableheadbgcolor}\multicolumn{2}{|p{(\linewidth-\tabcolsep*2-\arrayrulewidth*1)*2/2}|}{\cellcolor{\tableheadbgcolor}\textbf{ $\ast$$\ast$\+Pattern$\ast$   }}\\\cline{1-2}
\endhead
{\ttfamily $\ast$}  &Matches any string except for {\ttfamily /}, leading {\ttfamily .}, or {\ttfamily /.} inside a path   \\\cline{1-2}
\end{longtabu}
$\vert$ {\ttfamily $\ast$$\ast$} $\vert$ Matches any string including {\ttfamily /}, but not a leading {\ttfamily .} or {\ttfamily /.} inside a path. More than two stars (e.\+g. {\ttfamily $\ast$$\ast$$\ast$} is treated the same as one star, and {\ttfamily $\ast$$\ast$} loses its special meaning $\vert$ when it\textquotesingle{}s not the only thing in a path segment, per Bash specifications) $\vert$ $\vert$ {\ttfamily foo$\ast$} $\vert$ Matches any string beginning with {\ttfamily foo} $\vert$ $\vert$ {\ttfamily $\ast$bar$\ast$} $\vert$ Matches any string containing {\ttfamily bar} (beginning, middle or end) $\vert$ $\vert$ {\ttfamily $\ast$.min.\+js} $\vert$ Matches any string ending with {\ttfamily .min.\+js} $\vert$ $\vert$ {\ttfamily \mbox{[}abc\mbox{]}$\ast$.js} $\vert$ Matches any string beginning with {\ttfamily a}, {\ttfamily b}, or {\ttfamily c} and ending with {\ttfamily .js} $\vert$ $\vert$ {\ttfamily abc?} $\vert$ Matches {\ttfamily abcd} or {\ttfamily abcz} but not {\ttfamily abcde} $\vert$

The exceptions noted for {\ttfamily $\ast$} apply to all patterns that contain a {\ttfamily $\ast$}.

{\bfseries Not supported}

The following extended-\/globbing features are not supported\+:


\begin{DoxyItemize}
\item \href{https://github.com/jonschlinkert/braces}{\tt brace expansion} (e.\+g. {\ttfamily \{a,b,c\}})
\item \href{https://github.com/jonschlinkert/extglob}{\tt extglobs} (e.\+g. {\ttfamily @(a$\vert$!(c$\vert$d))})
\item \href{https://github.com/jonschlinkert/expand-brackets}{\tt P\+O\+S\+IX brackets} (e.\+g. {\ttfamily \mbox{[}\mbox{[}\+:alpha\+:\mbox{]}\mbox{[}\+:digit\+:\mbox{]}\mbox{]}})
\end{DoxyItemize}

If you need any of these features consider using \href{https://github.com/micromatch/micromatch}{\tt micromatch} instead.

\subsection*{Bash expansion libs}

Nanomatch is part of a suite of libraries aimed at bringing the power and expressiveness of \href{https://www.gnu.org/software/bash/}{\tt Bash\textquotesingle{}s} matching and expansion capabilities to Java\+Script, {\itshape and -\/ as you can see by the \href{#benchmarks}{\tt benchmarks} -\/ without sacrificing speed}.

\tabulinesep=1mm
\begin{longtabu} spread 0pt [c]{*{4}{|X[-1]}|}
\hline
\rowcolor{\tableheadbgcolor}\textbf{ {\bfseries Related library}  }&\multicolumn{3}{p{(\linewidth-\tabcolsep*4-\arrayrulewidth*2)*3/4}|}{\cellcolor{\tableheadbgcolor}\textbf{ }}\\\cline{1-4}
\endfirsthead
\hline
\endfoot
\hline
\rowcolor{\tableheadbgcolor}\textbf{ {\bfseries Related library}  }&\multicolumn{3}{p{(\linewidth-\tabcolsep*4-\arrayrulewidth*2)*3/4}|}{\cellcolor{\tableheadbgcolor}\textbf{ }}\\\cline{1-4}
\endhead
{\ttfamily nanomatch} (you are here)  &Wildcards  &{\ttfamily $\ast$}  &\href{https://www.gnu.org/software/bash/manual/html_node/Filename-Expansion.html#Filename-Expansion}{\tt Filename expansion}, also referred to as globbing and pathname expansion, allows the use of \href{#features}{\tt wildcards} for matching.   \\\cline{1-4}
\href{https://github.com/jonschlinkert/expand-tilde}{\tt expand-\/tilde}  &Tildes  &{\ttfamily $\sim$}  &\href{https://www.gnu.org/software/bash/manual/html_node/Tilde-Expansion.html#Tilde-Expansion}{\tt Tilde expansion} converts the leading tilde in a file path to the user home directory.   \\\cline{1-4}
\href{https://github.com/jonschlinkert/braces}{\tt braces}  &Braces  &{\ttfamily \{a,b,c\}}  &\href{https://www.gnu.org/software/bash/manual/html_node/Brace-Expansion.html}{\tt Brace expansion}   \\\cline{1-4}
\href{https://github.com/jonschlinkert/expand-brackets}{\tt expand-\/brackets}  &Brackets  &{\ttfamily \mbox{[}\mbox{[}\+:alpha\+:\mbox{]}\mbox{]}}  &\href{https://www.gnu.org/software/grep/manual/html_node/Character-Classes-and-Bracket-Expressions.html}{\tt P\+O\+S\+IX character classes} (also referred to as P\+O\+S\+IX brackets, or P\+O\+S\+IX character classes)   \\\cline{1-4}
\end{longtabu}
$\vert$ \href{https://github.com/jonschlinkert/extglob}{\tt extglob} $\vert$ Parens $\vert$ {\ttfamily !(a\textbackslash{} $\vert$ b)} $\vert$ \href{https://www.gnu.org/software/bash/manual/html_node/Pattern-Matching.html#Pattern-Matching}{\tt Extglobs} $\vert$ $\vert$ \href{https://github.com/micromatch/micromatch}{\tt micromatch} $\vert$ All $\vert$ all $\vert$ Micromatch is built on top of the other libraries. $\vert$

There are many resources available on the web if you want to dive deeper into how these features work in Bash.

\subsection*{Benchmarks}

\subsubsection*{Running benchmarks}

Install dev dependencies\+:


\begin{DoxyCode}
npm i -d && node benchmark
\end{DoxyCode}


\subsubsection*{Nanomatch vs. Minimatch vs. Multimatch}


\begin{DoxyCode}
# globstar-basic (182 bytes)
  minimatch x 69,512 ops/sec ±1.92% (88 runs sampled)
  multimatch x 63,376 ops/sec ±1.41% (89 runs sampled)
  nanomatch x 432,451 ops/sec ±0.92% (88 runs sampled)

  fastest is nanomatch (by 651% avg)

# large-list-globstar (485686 bytes)
  minimatch x 34.02 ops/sec ±1.42% (59 runs sampled)
  multimatch x 33.58 ops/sec ±1.97% (58 runs sampled)
  nanomatch x 483 ops/sec ±1.06% (86 runs sampled)

  fastest is nanomatch (by 1429% avg)

# long-list-globstar (194085 bytes)
  minimatch x 383 ops/sec ±0.74% (90 runs sampled)
  multimatch x 378 ops/sec ±0.59% (89 runs sampled)
  nanomatch x 990 ops/sec ±1.14% (85 runs sampled)

  fastest is nanomatch (by 260% avg)

# negation-basic (132 bytes)
  minimatch x 242,145 ops/sec ±1.17% (89 runs sampled)
  multimatch x 76,403 ops/sec ±0.78% (92 runs sampled)
  nanomatch x 537,253 ops/sec ±1.44% (86 runs sampled)

  fastest is nanomatch (by 337% avg)

# not-glob-basic (93 bytes)
  minimatch x 252,402 ops/sec ±1.33% (89 runs sampled)
  multimatch x 209,954 ops/sec ±1.30% (90 runs sampled)
  nanomatch x 1,716,468 ops/sec ±1.13% (86 runs sampled)

  fastest is nanomatch (by 742% avg)

# star-basic (93 bytes)
  minimatch x 182,780 ops/sec ±1.41% (91 runs sampled)
  multimatch x 153,210 ops/sec ±0.72% (89 runs sampled)
  nanomatch x 599,621 ops/sec ±1.22% (90 runs sampled)

  fastest is nanomatch (by 357% avg)
\end{DoxyCode}


\subsection*{About}

$<$details$>$ 

{\bfseries Contributing}

Pull requests and stars are always welcome. For bugs and feature requests, \href{../../issues/new}{\tt please create an issue}.

Please read the .github/contributing.\+md \char`\"{}contributing guide\char`\"{} for advice on opening issues, pull requests, and coding standards.

$<$/details$>$

$<$details$>$ 

{\bfseries Running Tests}

Running and reviewing unit tests is a great way to get familiarized with a library and its A\+PI. You can install dependencies and run tests with the following command\+:


\begin{DoxyCode}
$ npm install && npm test
\end{DoxyCode}


$<$/details$>$

$<$details$>$ 

{\bfseries Building docs}

\+\_\+(This project\textquotesingle{}s readme.\+md is generated by \href{https://github.com/verbose/verb-generate-readme}{\tt verb}, please don\textquotesingle{}t edit the readme directly. Any changes to the readme must be made in the .verb.\+md \char`\"{}.\+verb.\+md\char`\"{} readme template.)\+\_\+

To generate the readme, run the following command\+:


\begin{DoxyCode}
$ npm install -g verbose/verb#dev verb-generate-readme && verb
\end{DoxyCode}


$<$/details$>$

\subsubsection*{Related projects}

You might also be interested in these projects\+:


\begin{DoxyItemize}
\item \href{https://www.npmjs.com/package/extglob}{\tt extglob}\+: Extended glob support for Java\+Script. Adds (almost) the expressive power of regular expressions to glob… \href{https://github.com/micromatch/extglob}{\tt more} $\vert$ \mbox{[}homepage\mbox{]}(\href{https://github.com/micromatch/extglob}{\tt https\+://github.\+com/micromatch/extglob} \char`\"{}\+Extended glob support for Java\+Script. Adds (almost) the expressive power of regular expressions to glob patterns.\char`\"{})
\item \href{https://www.npmjs.com/package/is-extglob}{\tt is-\/extglob}\+: Returns true if a string has an extglob. $\vert$ \href{https://github.com/jonschlinkert/is-extglob}{\tt homepage}
\item \href{https://www.npmjs.com/package/is-glob}{\tt is-\/glob}\+: Returns {\ttfamily true} if the given string looks like a glob pattern or an extglob pattern… \href{https://github.com/jonschlinkert/is-glob}{\tt more} $\vert$ \href{https://github.com/jonschlinkert/is-glob}{\tt homepage}
\item \href{https://www.npmjs.com/package/micromatch}{\tt micromatch}\+: Glob matching for javascript/node.\+js. A drop-\/in replacement and faster alternative to minimatch and multimatch. $\vert$ \href{https://github.com/micromatch/micromatch}{\tt homepage}
\end{DoxyItemize}

\subsubsection*{Contributors}

\tabulinesep=1mm
\begin{longtabu} spread 0pt [c]{*{2}{|X[-1]}|}
\hline
\rowcolor{\tableheadbgcolor}\multicolumn{2}{|p{(\linewidth-\tabcolsep*2-\arrayrulewidth*1)*2/2}|}{\cellcolor{\tableheadbgcolor}\textbf{ $\ast$$\ast$\+Commits$\ast$   }}\\\cline{1-2}
\endfirsthead
\hline
\endfoot
\hline
\rowcolor{\tableheadbgcolor}\multicolumn{2}{|p{(\linewidth-\tabcolsep*2-\arrayrulewidth*1)*2/2}|}{\cellcolor{\tableheadbgcolor}\textbf{ $\ast$$\ast$\+Commits$\ast$   }}\\\cline{1-2}
\endhead
164  &\href{https://github.com/jonschlinkert}{\tt jonschlinkert}   \\\cline{1-2}
1  &\href{https://github.com/devongovett}{\tt devongovett}   \\\cline{1-2}
\end{longtabu}


\subsubsection*{Author}

{\bfseries Jon Schlinkert}


\begin{DoxyItemize}
\item \href{https://linkedin.com/in/jonschlinkert}{\tt linkedin/in/jonschlinkert}
\item \href{https://github.com/jonschlinkert}{\tt github/jonschlinkert}
\item \href{https://twitter.com/jonschlinkert}{\tt twitter/jonschlinkert}
\end{DoxyItemize}

\subsubsection*{License}

Copyright © 2018, \href{https://github.com/jonschlinkert}{\tt Jon Schlinkert}. Released under the \mbox{[}M\+IT License\mbox{]}(L\+I\+C\+E\+N\+SE).





{\itshape This file was generated by \href{https://github.com/verbose/verb-generate-readme}{\tt verb-\/generate-\/readme}, v0.\+6.\+0, on February 18, 2018.} 