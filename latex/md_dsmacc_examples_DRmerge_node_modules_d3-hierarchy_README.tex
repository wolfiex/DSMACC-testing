Many datasets are intrinsically hierarchical. Consider \href{https://www.census.gov/geo/reference/hierarchy.html}{\tt geographic entities}, such as census blocks, census tracts, counties and states; the command structure of businesses and governments; file systems and software packages. And even non-\/hierarchical data may be arranged empirically into a hierarchy, as with \href{https://en.wikipedia.org/wiki/K-means_clustering}{\tt {\itshape k}-\/means clustering} or \href{https://bl.ocks.org/mbostock/c034d66572fd6bd6815a}{\tt phylogenetic trees}.

This module implements several popular techniques for visualizing hierarchical data\+:

{\bfseries Node-\/link diagrams} show topology using discrete marks for nodes and links, such as a circle for each node and a line connecting each parent and child. The \href{#tree}{\tt “tidy” tree} is delightfully compact, while the \href{#cluster}{\tt dendrogram} places leaves at the same level. (These have both polar and Cartesian forms.) \href{https://bl.ocks.org/mbostock/1093025}{\tt Indented trees} are useful for interactive browsing.

{\bfseries Adjacency diagrams} show topology through the relative placement of nodes. They may also encode a quantitative dimension in the area of each node, for example to show revenue or file size. The \href{#partition}{\tt “icicle” diagram} uses rectangles, while the “sunburst” uses annular segments.

{\bfseries Enclosure diagrams} also use an area encoding, but show topology through containment. A \href{#treemap}{\tt treemap} recursively subdivides area into rectangles. \href{#pack}{\tt Circle-\/packing} tightly nests circles; this is not as space-\/efficient as a treemap, but perhaps more readily shows topology.

A good hierarchical visualization facilitates rapid multiscale inference\+: micro-\/observations of individual elements and macro-\/observations of large groups.

\subsection*{Installing}

If you use N\+PM, {\ttfamily npm install d3-\/hierarchy}. Otherwise, download the \href{https://github.com/d3/d3-hierarchy/releases/latest}{\tt latest release}. You can also load directly from \href{https://d3js.org}{\tt d3js.\+org}, either as a \href{https://d3js.org/d3-hierarchy.v1.min.js}{\tt standalone library} or as part of \href{https://github.com/d3/d3}{\tt D3 4.\+0}. A\+MD, Common\+JS, and vanilla environments are supported. In vanilla, a {\ttfamily d3} global is exported\+:


\begin{DoxyCode}
<script src="https://d3js.org/d3-hierarchy.v1.min.js"></script>
<script>

var treemap = d3.treemap();

</script>
\end{DoxyCode}


\href{https://tonicdev.com/npm/d3-hierarchy}{\tt Try d3-\/hierarchy in your browser.}

\subsection*{A\+PI Reference}


\begin{DoxyItemize}
\item \href{#hierarchy}{\tt Hierarchy} (\href{#stratify}{\tt Stratify})
\item \href{#cluster}{\tt Cluster}
\item \href{#tree}{\tt Tree}
\item \href{#treemap}{\tt Treemap} (\href{#treemap-tiling}{\tt Treemap Tiling})
\item \href{#partition}{\tt Partition}
\item \href{#pack}{\tt Pack}
\end{DoxyItemize}

\subsubsection*{Hierarchy}

Before you can compute a hierarchical layout, you need a root node. If your data is already in a hierarchical format, such as J\+S\+ON, you can pass it directly to \href{#hierarchy}{\tt d3.\+hierarchy}; otherwise, you can rearrange tabular data, such as comma-\/separated values (C\+SV), into a hierarchy using \href{#stratify}{\tt d3.\+stratify}.

\label{_hierarchy}%
\# d3.{\bfseries hierarchy}({\itshape data}\mbox{[}, {\itshape children}\mbox{]}) \href{https://github.com/d3/d3-hierarchy/blob/master/src/hierarchy/index.js#L12}{\tt $<$$>$}

Constructs a root node from the specified hierarchical {\itshape data}. The specified {\itshape data} must be an object representing the root node. For example\+:


\begin{DoxyCode}
\{
  "name": "Eve",
  "children": [
    \{
      "name": "Cain"
    \},
    \{
      "name": "Seth",
      "children": [
        \{
          "name": "Enos"
        \},
        \{
          "name": "Noam"
        \}
      ]
    \},
    \{
      "name": "Abel"
    \},
    \{
      "name": "Awan",
      "children": [
        \{
          "name": "Enoch"
        \}
      ]
    \},
    \{
      "name": "Azura"
    \}
  ]
\}
\end{DoxyCode}


The specified {\itshape children} accessor function is invoked for each datum, starting with the root {\itshape data}, and must return an array of data representing the children, or null if the current datum has no children. If {\itshape children} is not specified, it defaults to\+:


\begin{DoxyCode}
function children(d) \{
  return d.children;
\}
\end{DoxyCode}


The returned node and each descendant has the following properties\+:


\begin{DoxyItemize}
\item {\itshape node}.data -\/ the associated data, as specified to the \href{#hierarchy}{\tt constructor}.
\item {\itshape node}.depth -\/ zero for the root node, and increasing by one for each descendant generation.
\item {\itshape node}.height -\/ zero for leaf nodes, and the greatest distance from any descendant leaf for internal nodes.
\item {\itshape node}.parent -\/ the parent node, or null for the root node.
\item {\itshape node}.children -\/ an array of child nodes, if any; undefined for leaf nodes.
\item {\itshape node}.value -\/ the summed value of the node and its \href{#node_descendants}{\tt descendants}; optional, see \href{#node_sum}{\tt {\itshape node}.sum} and \href{#node_count}{\tt {\itshape node}.count}.
\end{DoxyItemize}

This method can also be used to test if a node is an {\ttfamily instanceof d3.\+hierarchy} and to extend the node prototype.

\label{_node_ancestors}%
\# {\itshape node}.{\bfseries ancestors}() \href{https://github.com/d3/d3-hierarchy/blob/master/src/hierarchy/ancestors.js}{\tt $<$$>$}

Returns the array of ancestors nodes, starting with this node, then followed by each parent up to the root.

\label{_node_descendants}%
\# {\itshape node}.{\bfseries descendants}() \href{https://github.com/d3/d3-hierarchy/blob/master/src/hierarchy/descendants.js}{\tt $<$$>$}

Returns the array of descendant nodes, starting with this node, then followed by each child in topological order.

\label{_node_leaves}%
\# {\itshape node}.{\bfseries leaves}() \href{https://github.com/d3/d3-hierarchy/blob/master/src/hierarchy/leaves.js}{\tt $<$$>$}

Returns the array of leaf nodes in traversal order; leaves are nodes with no children.

\label{_node_path}%
\# {\itshape node}.{\bfseries path}({\itshape target}) \href{https://github.com/d3/d3-hierarchy/blob/master/src/hierarchy/path.js}{\tt $<$$>$}

Returns the shortest path through the hierarchy from this {\itshape node} to the specified {\itshape target} node. The path starts at this {\itshape node}, ascends to the least common ancestor of this {\itshape node} and the {\itshape target} node, and then descends to the {\itshape target} node. This is particularly useful for \href{https://bl.ocks.org/mbostock/7607999}{\tt hierarchical edge bundling}.

\label{_node_links}%
\# {\itshape node}.{\bfseries links}() \href{https://github.com/d3/d3-hierarchy/blob/master/src/hierarchy/links.js}{\tt $<$$>$}

Returns an array of links for this {\itshape node}, where each {\itshape link} is an object that defines source and target properties. The source of each link is the parent node, and the target is a child node.

\label{_node_sum}%
\# {\itshape node}.{\bfseries sum}({\itshape value}) \href{https://github.com/d3/d3-hierarchy/blob/master/src/hierarchy/sum.js}{\tt $<$$>$}

Evaluates the specified {\itshape value} function for this {\itshape node} and each descendant in \href{#node_eachAfter}{\tt post-\/order traversal}, and returns this {\itshape node}. The {\itshape node}.value property of each node is set to the numeric value returned by the specified function plus the combined value of all descendants. The function is passed the node’s data, and must return a non-\/negative number. The {\itshape value} accessor is evaluated for {\itshape node} and every descendant, including internal nodes; if you only want leaf nodes to have internal value, then return zero for any node with children. \href{http://bl.ocks.org/mbostock/b4c0f143db88a9eb01a315a1063c1d77}{\tt For example}, as an alternative to \href{#node_count}{\tt {\itshape node}.count}\+:


\begin{DoxyCode}
root.sum(function(d) \{ return d.value ? 1 : 0; \});
\end{DoxyCode}


You must call {\itshape node}.sum or \href{#node_count}{\tt {\itshape node}.count} before invoking a hierarchical layout that requires {\itshape node}.value, such as \href{#treemap}{\tt d3.\+treemap}. Since the A\+PI supports \href{https://en.wikipedia.org/wiki/Method_chaining}{\tt method chaining}, you can invoke {\itshape node}.sum and \href{#node_sort}{\tt {\itshape node}.sort} before computing the layout, and then subsequently generate an array of all \href{#node_descendants}{\tt descendant nodes} like so\+:


\begin{DoxyCode}
var treemap = d3.treemap()
    .size([width, height])
    .padding(2);

var nodes = treemap(root
    .sum(function(d) \{ return d.value; \})
    .sort(function(a, b) \{ return b.height - a.height || b.value - a.value; \}))
  .descendants();
\end{DoxyCode}


This example assumes that the node data has a value field.

\label{_node_count}%
\# {\itshape node}.{\bfseries count}() \href{https://github.com/d3/d3-hierarchy/blob/master/src/hierarchy/count.js}{\tt $<$$>$}

Computes the number of leaves under this {\itshape node} and assigns it to {\itshape node}.value, and similarly for every descendant of {\itshape node}. If this {\itshape node} is a leaf, its count is one. Returns this {\itshape node}. See also \href{#node_sum}{\tt {\itshape node}.sum}.

\label{_node_sort}%
\# {\itshape node}.{\bfseries sort}({\itshape compare}) \href{https://github.com/d3/d3-hierarchy/blob/master/src/hierarchy/sort.js}{\tt $<$$>$}

Sorts the children of this {\itshape node}, if any, and each of this {\itshape node$\ast$’s descendants’ children, in \href{#node_eachBefore}{\tt pre-\/order traversal} using the specified $\ast$compare} function, and returns this {\itshape node}. The specified function is passed two nodes {\itshape a} and {\itshape b} to compare. If {\itshape a} should be before {\itshape b}, the function must return a value less than zero; if {\itshape b} should be before {\itshape a}, the function must return a value greater than zero; otherwise, the relative order of {\itshape a} and {\itshape b} are not specified. See \href{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort}{\tt {\itshape array}.sort} for more.

Unlike \href{#node_sum}{\tt {\itshape node}.sum}, the {\itshape compare} function is passed two \href{#hierarchy}{\tt nodes} rather than two nodes’ data. For example, if the data has a value property, this sorts nodes by the descending aggregate value of the node and all its descendants, as is recommended for \href{#pack}{\tt circle-\/packing}\+:

\`{}\`{}\`{}js root .sum(function(d) \{ return d.\+value; \}) .sort(function(a, b) \{ return b.\+value -\/ a.\+value; \}); \`{}\`{}\`{}\`{}\`{}\`{}

Similarly, to sort nodes by descending height (greatest distance from any descendant leaf) and then descending value, as is recommended for \href{#treemap}{\tt treemaps} and \href{#partition}{\tt icicles}\+:


\begin{DoxyCode}
root
    .sum(function(d) \{ return d.value; \})
    .sort(function(a, b) \{ return b.height - a.height || b.value - a.value; \});
\end{DoxyCode}


To sort nodes by descending height and then ascending id, as is recommended for \href{#tree}{\tt trees} and \href{#cluster}{\tt dendrograms}\+:


\begin{DoxyCode}
root
    .sum(function(d) \{ return d.value; \})
    .sort(function(a, b) \{ return b.height - a.height || a.id.localeCompare(b.id); \});
\end{DoxyCode}


You must call {\itshape node}.sort before invoking a hierarchical layout if you want the new sort order to affect the layout; see \href{#node_sum}{\tt {\itshape node}.sum} for an example.

\label{_node_each}%
\# {\itshape node}.{\bfseries each}({\itshape function}) \href{https://github.com/d3/d3-hierarchy/blob/master/src/hierarchy/each.js}{\tt $<$$>$}

Invokes the specified {\itshape function} for {\itshape node} and each descendant in \href{https://en.wikipedia.org/wiki/Breadth-first_search}{\tt breadth-\/first order}, such that a given {\itshape node} is only visited if all nodes of lesser depth have already been visited, as well as all preceeding nodes of the same depth. The specified function is passed the current {\itshape node}.

\label{_node_eachAfter}%
\# {\itshape node}.{\bfseries each\+After}({\itshape function}) \href{https://github.com/d3/d3-hierarchy/blob/master/src/hierarchy/eachAfter.js}{\tt $<$$>$}

Invokes the specified {\itshape function} for {\itshape node} and each descendant in \href{https://en.wikipedia.org/wiki/Tree_traversal#Post-order}{\tt post-\/order traversal}, such that a given {\itshape node} is only visited after all of its descendants have already been visited. The specified function is passed the current {\itshape node}.

\label{_node_eachBefore}%
\# {\itshape node}.{\bfseries each\+Before}({\itshape function}) \href{https://github.com/d3/d3-hierarchy/blob/master/src/hierarchy/eachBefore.js}{\tt $<$$>$}

Invokes the specified {\itshape function} for {\itshape node} and each descendant in \href{https://en.wikipedia.org/wiki/Tree_traversal#Pre-order}{\tt pre-\/order traversal}, such that a given {\itshape node} is only visited after all of its ancestors have already been visited. The specified function is passed the current {\itshape node}.

\label{_node_copy}%
\# {\itshape node}.{\bfseries copy}() \href{https://github.com/d3/d3-hierarchy/blob/master/src/hierarchy/index.js#L39}{\tt $<$$>$}

Return a deep copy of the subtree starting at this {\itshape node}. (The returned deep copy shares the same data, however.) The returned node is the root of a new tree; the returned node’s parent is always null and its depth is always zero.

\paragraph*{Stratify}

Consider the following table of relationships\+:

Name $\vert$ Parent -\/-\/-\/---$\vert$-\/-\/-\/-\/-\/--- Eve $\vert$ Cain $\vert$ Eve Seth $\vert$ Eve Enos $\vert$ Seth Noam $\vert$ Seth Abel $\vert$ Eve Awan $\vert$ Eve Enoch $\vert$ Awan Azura $\vert$ Eve

These names are conveniently unique, so we can unambiguously represent the hierarchy as a C\+SV file\+:


\begin{DoxyCode}
name,parent
Eve,
Cain,Eve
Seth,Eve
Enos,Seth
Noam,Seth
Abel,Eve
Awan,Eve
Enoch,Awan
Azura,Eve
\end{DoxyCode}


To parse the C\+SV using \href{https://github.com/d3/d3-dsv#csvParse}{\tt d3.\+csv\+Parse}\+:


\begin{DoxyCode}
var table = d3.csvParse(text);
\end{DoxyCode}


This returns\+:


\begin{DoxyCode}
[
  \{"name": "Eve",   "parent": ""\},
  \{"name": "Cain",  "parent": "Eve"\},
  \{"name": "Seth",  "parent": "Eve"\},
  \{"name": "Enos",  "parent": "Seth"\},
  \{"name": "Noam",  "parent": "Seth"\},
  \{"name": "Abel",  "parent": "Eve"\},
  \{"name": "Awan",  "parent": "Eve"\},
  \{"name": "Enoch", "parent": "Awan"\},
  \{"name": "Azura", "parent": "Eve"\}
]
\end{DoxyCode}


To convert to a hierarchy\+:


\begin{DoxyCode}
var root = d3.stratify()
    .id(function(d) \{ return d.name; \})
    .parentId(function(d) \{ return d.parent; \})
    (table);
\end{DoxyCode}


This returns\+:

\href{https://tonicdev.com/mbostock/56fed33d8630b01300f72daa}{\tt }

This hierarchy can now be passed to a hierarchical layout, such as \href{#_tree}{\tt d3.\+tree}, for visualization.

\label{_stratify}%
\# d3.{\bfseries stratify}() \href{https://github.com/d3/d3-hierarchy/blob/master/src/stratify.js}{\tt $<$$>$}

Constructs a new stratify operator with the default settings.

\label{__stratify}%
\# {\itshape stratify}({\itshape data}) \href{https://github.com/d3/d3-hierarchy/blob/master/src/stratify.js#L20}{\tt $<$$>$}

Generates a new hierarchy from the specified tabular {\itshape data}. Each node in the returned object has a shallow copy of the properties from the corresponding data object, excluding the following reserved properties\+: id, parent\+Id, children.

\label{_stratify_id}%
\# {\itshape stratify}.{\bfseries id}(\mbox{[}{\itshape id}\mbox{]}) \href{https://github.com/d3/d3-hierarchy/blob/master/src/stratify.js#L64}{\tt $<$$>$}

If {\itshape id} is specified, sets the id accessor to the given function and returns this stratify operator. Otherwise, returns the current id accessor, which defaults to\+:


\begin{DoxyCode}
function id(d) \{
  return d.id;
\}
\end{DoxyCode}


The id accessor is invoked for each element in the input data passed to the \href{#_stratify}{\tt stratify operator}, being passed the current datum ({\itshape d}) and the current index ({\itshape i}). The returned string is then used to identify the node’s relationships in conjunction with the \href{#stratify_parentId}{\tt parent id}. For leaf nodes, the id may be undefined; otherwise, the id must be unique. (Null and the empty string are equivalent to undefined.)

\label{_stratify_parentId}%
\# {\itshape stratify}.{\bfseries parent\+Id}(\mbox{[}{\itshape parent\+Id}\mbox{]}) \href{https://github.com/d3/d3-hierarchy/blob/master/src/stratify.js#L68}{\tt $<$$>$}

If {\itshape parent\+Id} is specified, sets the parent id accessor to the given function and returns this stratify operator. Otherwise, returns the current parent id accessor, which defaults to\+:


\begin{DoxyCode}
function parentId(d) \{
  return d.parentId;
\}
\end{DoxyCode}


The parent id accessor is invoked for each element in the input data passed to the \href{#_stratify}{\tt stratify operator}, being passed the current datum ({\itshape d}) and the current index ({\itshape i}). The returned string is then used to identify the node’s relationships in conjunction with the \href{#stratify_id}{\tt id}. For the root node, the parent id should be undefined. (Null and the empty string are equivalent to undefined.) There must be exactly one root node in the input data, and no circular relationships.

\subsubsection*{Cluster}

\href{http://bl.ocks.org/mbostock/ff91c1558bc570b08539547ccc90050b}{\tt }

The {\bfseries cluster layout} produces \href{http://en.wikipedia.org/wiki/Dendrogram}{\tt dendrograms}\+: node-\/link diagrams that place leaf nodes of the tree at the same depth. Dendograms are typically less compact than \href{#tree}{\tt tidy trees}, but are useful when all the leaves should be at the same level, such as for hierarchical clustering or \href{http://bl.ocks.org/mbostock/c034d66572fd6bd6815a}{\tt phylogenetic tree diagrams}.

\label{_cluster}%
\# d3.{\bfseries cluster}() \href{https://github.com/d3/d3-hierarchy/blob/master/src/cluster.js}{\tt $<$$>$}

Creates a new cluster layout with default settings.

\label{__cluster}%
\# {\itshape cluster}({\itshape root}) \href{https://github.com/d3/d3-hierarchy/blob/master/src/cluster.js#L39}{\tt $<$$>$}

Lays out the specified {\itshape root} \href{#hierarchy}{\tt hierarchy}, assigning the following properties on {\itshape root} and its descendants\+:


\begin{DoxyItemize}
\item {\itshape node}.x -\/ the {\itshape x}-\/coordinate of the node
\item {\itshape node}.y -\/ the {\itshape y}-\/coordinate of the node
\end{DoxyItemize}

The coordinates {\itshape x} and {\itshape y} represent an arbitrary coordinate system; for example, you can treat {\itshape x} as an angle and {\itshape y} as a radius to produce a \href{http://bl.ocks.org/mbostock/4739610f6d96aaad2fb1e78a72b385ab}{\tt radial layout}. You may want to call \href{#node_sort}{\tt {\itshape root}.sort} before passing the hierarchy to the cluster layout.

\label{_cluster_size}%
\# {\itshape cluster}.{\bfseries size}(\mbox{[}{\itshape size}\mbox{]}) \href{https://github.com/d3/d3-hierarchy/blob/master/src/cluster.js#L75}{\tt $<$$>$}

If {\itshape size} is specified, sets this cluster layout’s size to the specified two-\/element array of numbers \mbox{[}{\itshape width}, {\itshape height}\mbox{]} and returns this cluster layout. If {\itshape size} is not specified, returns the current layout size, which defaults to \mbox{[}1, 1\mbox{]}. A layout size of null indicates that a \href{#node_size}{\tt node size} will be used instead. The coordinates {\itshape x} and {\itshape y} represent an arbitrary coordinate system; for example, to produce a \href{http://bl.ocks.org/mbostock/4739610f6d96aaad2fb1e78a72b385ab}{\tt radial layout}, a size of \mbox{[}360, {\itshape radius}\mbox{]} corresponds to a breadth of 360° and a depth of {\itshape radius}.

\label{_cluster_nodeSize}%
\# {\itshape cluster}.{\bfseries node\+Size}(\mbox{[}{\itshape size}\mbox{]}) \href{https://github.com/d3/d3-hierarchy/blob/master/src/cluster.js#L79}{\tt $<$$>$}

If {\itshape size} is specified, sets this cluster layout’s node size to the specified two-\/element array of numbers \mbox{[}{\itshape width}, {\itshape height}\mbox{]} and returns this cluster layout. If {\itshape size} is not specified, returns the current node size, which defaults to null. A node size of null indicates that a \href{#cluster_size}{\tt layout size} will be used instead. When a node size is specified, the root node is always positioned at ⟨0, 0⟩.

\label{_cluster_separation}%
\# {\itshape cluster}.{\bfseries separation}(\mbox{[}{\itshape separation}\mbox{]}) \href{https://github.com/d3/d3-hierarchy/blob/master/src/cluster.js#L71}{\tt $<$$>$}

If {\itshape separation} is specified, sets the separation accessor to the specified function and returns this cluster layout. If {\itshape separation} is not specified, returns the current separation accessor, which defaults to\+:


\begin{DoxyCode}
function separation(a, b) \{
  return a.parent == b.parent ? 1 : 2;
\}
\end{DoxyCode}


The separation accessor is used to separate neighboring leaves. The separation function is passed two leaves {\itshape a} and {\itshape b}, and must return the desired separation. The nodes are typically siblings, though the nodes may be more distantly related if the layout decides to place such nodes adjacent.

\subsubsection*{Tree}

\href{http://bl.ocks.org/mbostock/9d0899acb5d3b8d839d9d613a9e1fe04}{\tt }

The {\bfseries tree} layout produces tidy node-\/link diagrams of trees using the \href{http://emr.cs.iit.edu/~reingold/tidier-drawings.pdf}{\tt Reingold–\+Tilford “tidy” algorithm}, improved to run in linear time by \href{http://dirk.jivas.de/papers/buchheim02improving.pdf}{\tt Buchheim {\itshape et al.}} Tidy trees are typically more compact than \href{#cluster}{\tt dendograms}.

\label{_tree}%
\# d3.{\bfseries tree}() \href{https://github.com/d3/d3-hierarchy/blob/master/src/tree.js}{\tt $<$$>$}

Creates a new tree layout with default settings.

\label{__tree}%
\# {\itshape tree}({\itshape root}) \href{https://github.com/d3/d3-hierarchy/blob/master/src/tree.js#L106}{\tt $<$$>$}

Lays out the specified {\itshape root} \href{#hierarchy}{\tt hierarchy}, assigning the following properties on {\itshape root} and its descendants\+:


\begin{DoxyItemize}
\item {\itshape node}.x -\/ the {\itshape x}-\/coordinate of the node
\item {\itshape node}.y -\/ the {\itshape y}-\/coordinate of the node
\end{DoxyItemize}

The coordinates {\itshape x} and {\itshape y} represent an arbitrary coordinate system; for example, you can treat {\itshape x} as an angle and {\itshape y} as a radius to produce a \href{http://bl.ocks.org/mbostock/2e12b0bd732e7fe4000e2d11ecab0268}{\tt radial layout}. You may want to call \href{#node_sort}{\tt {\itshape root}.sort} before passing the hierarchy to the tree layout.

\label{_tree_size}%
\# {\itshape tree}.{\bfseries size}(\mbox{[}{\itshape size}\mbox{]}) \href{https://github.com/d3/d3-hierarchy/blob/master/src/tree.js#L228}{\tt $<$$>$}

If {\itshape size} is specified, sets this tree layout’s size to the specified two-\/element array of numbers \mbox{[}{\itshape width}, {\itshape height}\mbox{]} and returns this tree layout. If {\itshape size} is not specified, returns the current layout size, which defaults to \mbox{[}1, 1\mbox{]}. A layout size of null indicates that a \href{#node_size}{\tt node size} will be used instead. The coordinates {\itshape x} and {\itshape y} represent an arbitrary coordinate system; for example, to produce a \href{http://bl.ocks.org/mbostock/2e12b0bd732e7fe4000e2d11ecab0268}{\tt radial layout}, a size of \mbox{[}360, {\itshape radius}\mbox{]} corresponds to a breadth of 360° and a depth of {\itshape radius}.

\label{_tree_nodeSize}%
\# {\itshape tree}.{\bfseries node\+Size}(\mbox{[}{\itshape size}\mbox{]}) \href{https://github.com/d3/d3-hierarchy/blob/master/src/tree.js#L232}{\tt $<$$>$}

If {\itshape size} is specified, sets this tree layout’s node size to the specified two-\/element array of numbers \mbox{[}{\itshape width}, {\itshape height}\mbox{]} and returns this tree layout. If {\itshape size} is not specified, returns the current node size, which defaults to null. A node size of null indicates that a \href{#tree_size}{\tt layout size} will be used instead. When a node size is specified, the root node is always positioned at ⟨0, 0⟩.

\label{_tree_separation}%
\# {\itshape tree}.{\bfseries separation}(\mbox{[}{\itshape separation}\mbox{]}) \href{https://github.com/d3/d3-hierarchy/blob/master/src/tree.js#L224}{\tt $<$$>$}

If {\itshape separation} is specified, sets the separation accessor to the specified function and returns this tree layout. If {\itshape separation} is not specified, returns the current separation accessor, which defaults to\+:


\begin{DoxyCode}
function separation(a, b) \{
  return a.parent == b.parent ? 1 : 2;
\}
\end{DoxyCode}


A variation that is more appropriate for radial layouts reduces the separation gap proportionally to the radius\+:


\begin{DoxyCode}
function separation(a, b) \{
  return (a.parent == b.parent ? 1 : 2) / a.depth;
\}
\end{DoxyCode}


The separation accessor is used to separate neighboring nodes. The separation function is passed two nodes {\itshape a} and {\itshape b}, and must return the desired separation. The nodes are typically siblings, though the nodes may be more distantly related if the layout decides to place such nodes adjacent.

\subsubsection*{Treemap}

\href{http://bl.ocks.org/mbostock/6bbb0a7ff7686b124d80}{\tt }

Introduced by \href{http://www.cs.umd.edu/hcil/treemap-history/}{\tt Ben Shneiderman} in 1991, a {\bfseries treemap} recursively subdivides area into rectangles according to each node’s associated value. D3’s treemap implementation supports an extensible \href{#treemap_tile}{\tt tiling method}\+: the default \href{#treemapSquarify}{\tt squarified} method seeks to generate rectangles with a \href{https://en.wikipedia.org/wiki/Golden_ratio}{\tt golden} aspect ratio; this offers better readability and size estimation than \href{#treemapSliceDice}{\tt slice-\/and-\/dice}, which simply alternates between horizontal and vertical subdivision by depth.

\label{_treemap}%
\# d3.{\bfseries treemap}()

Creates a new treemap layout with default settings.

\label{__treemap}%
\# {\itshape treemap}({\itshape root}) \href{https://github.com/d3/d3-hierarchy/blob/master/src/treemap/index.js#L18}{\tt $<$$>$}

Lays out the specified {\itshape root} \href{#hierarchy}{\tt hierarchy}, assigning the following properties on {\itshape root} and its descendants\+:


\begin{DoxyItemize}
\item {\itshape node}.x0 -\/ the left edge of the rectangle
\item {\itshape node}.y0 -\/ the top edge of the rectangle
\item {\itshape node}.x1 -\/ the right edge of the rectangle
\item {\itshape node}.y1 -\/ the bottom edge of the rectangle
\end{DoxyItemize}

You must call \href{#node_sum}{\tt {\itshape root}.sum} before passing the hierarchy to the treemap layout. You probably also want to call \href{#node_sort}{\tt {\itshape root}.sort} to order the hierarchy before computing the layout.

\label{_treemap_tile}%
\# {\itshape treemap}.{\bfseries tile}(\mbox{[}{\itshape tile}\mbox{]}) \href{https://github.com/d3/d3-hierarchy/blob/master/src/treemap/index.js#L61}{\tt $<$$>$}

If {\itshape tile} is specified, sets the \href{#treemap-tiling}{\tt tiling method} to the specified function and returns this treemap layout. If {\itshape tile} is not specified, returns the current tiling method, which defaults to \href{#treemapSquarify}{\tt d3.\+treemap\+Squarify} with the golden ratio.

\label{_treemap_size}%
\# {\itshape treemap}.{\bfseries size}(\mbox{[}{\itshape size}\mbox{]}) \href{https://github.com/d3/d3-hierarchy/blob/master/src/treemap/index.js#L57}{\tt $<$$>$}

If {\itshape size} is specified, sets this treemap layout’s size to the specified two-\/element array of numbers \mbox{[}{\itshape width}, {\itshape height}\mbox{]} and returns this treemap layout. If {\itshape size} is not specified, returns the current size, which defaults to \mbox{[}1, 1\mbox{]}.

\label{_treemap_round}%
\# {\itshape treemap}.{\bfseries round}(\mbox{[}{\itshape round}\mbox{]}) \href{https://github.com/d3/d3-hierarchy/blob/master/src/treemap/index.js#L53}{\tt $<$$>$}

If {\itshape round} is specified, enables or disables rounding according to the given boolean and returns this treemap layout. If {\itshape round} is not specified, returns the current rounding state, which defaults to false.

\label{_treemap_padding}%
\# {\itshape treemap}.{\bfseries padding}(\mbox{[}{\itshape padding}\mbox{]}) \href{https://github.com/d3/d3-hierarchy/blob/master/src/treemap/index.js#L65}{\tt $<$$>$}

If {\itshape padding} is specified, sets the \href{#treemap_paddingInner}{\tt inner} and \href{#treemap_paddingOuter}{\tt outer} padding to the specified number or function and returns this treemap layout. If {\itshape padding} is not specified, returns the current inner padding function.

\label{_treemap_paddingInner}%
\# {\itshape treemap}.{\bfseries padding\+Inner}(\mbox{[}{\itshape padding}\mbox{]}) \href{https://github.com/d3/d3-hierarchy/blob/master/src/treemap/index.js#L69}{\tt $<$$>$}

If {\itshape padding} is specified, sets the inner padding to the specified number or function and returns this treemap layout. If {\itshape padding} is not specified, returns the current inner padding function, which defaults to the constant zero. If {\itshape padding} is a function, it is invoked for each node with children, being passed the current node. The inner padding is used to separate a node’s adjacent children.

\label{_treemap_paddingOuter}%
\# {\itshape treemap}.{\bfseries padding\+Outer}(\mbox{[}{\itshape padding}\mbox{]}) \href{https://github.com/d3/d3-hierarchy/blob/master/src/treemap/index.js#L73}{\tt $<$$>$}

If {\itshape padding} is specified, sets the \href{#treemap_paddingTop}{\tt top}, \href{#treemap_paddingRight}{\tt right}, \href{#treemap_paddingBottom}{\tt bottom} and \href{#treemap_paddingLeft}{\tt left} padding to the specified number or function and returns this treemap layout. If {\itshape padding} is not specified, returns the current top padding function.

\label{_treemap_paddingTop}%
\# {\itshape treemap}.{\bfseries padding\+Top}(\mbox{[}{\itshape padding}\mbox{]}) \href{https://github.com/d3/d3-hierarchy/blob/master/src/treemap/index.js#L77}{\tt $<$$>$}

If {\itshape padding} is specified, sets the top padding to the specified number or function and returns this treemap layout. If {\itshape padding} is not specified, returns the current top padding function, which defaults to the constant zero. If {\itshape padding} is a function, it is invoked for each node with children, being passed the current node. The top padding is used to separate the top edge of a node from its children.

\label{_treemap_paddingRight}%
\# {\itshape treemap}.{\bfseries padding\+Right}(\mbox{[}{\itshape padding}\mbox{]}) \href{https://github.com/d3/d3-hierarchy/blob/master/src/treemap/index.js#L81}{\tt $<$$>$}

If {\itshape padding} is specified, sets the right padding to the specified number or function and returns this treemap layout. If {\itshape padding} is not specified, returns the current right padding function, which defaults to the constant zero. If {\itshape padding} is a function, it is invoked for each node with children, being passed the current node. The right padding is used to separate the right edge of a node from its children.

\label{_treemap_paddingBottom}%
\# {\itshape treemap}.{\bfseries padding\+Bottom}(\mbox{[}{\itshape padding}\mbox{]}) \href{https://github.com/d3/d3-hierarchy/blob/master/src/treemap/index.js#L85}{\tt $<$$>$}

If {\itshape padding} is specified, sets the bottom padding to the specified number or function and returns this treemap layout. If {\itshape padding} is not specified, returns the current bottom padding function, which defaults to the constant zero. If {\itshape padding} is a function, it is invoked for each node with children, being passed the current node. The bottom padding is used to separate the bottom edge of a node from its children.

\label{_treemap_paddingLeft}%
\# {\itshape treemap}.{\bfseries padding\+Left}(\mbox{[}{\itshape padding}\mbox{]}) \href{https://github.com/d3/d3-hierarchy/blob/master/src/treemap/index.js#L89}{\tt $<$$>$}

If {\itshape padding} is specified, sets the left padding to the specified number or function and returns this treemap layout. If {\itshape padding} is not specified, returns the current left padding function, which defaults to the constant zero. If {\itshape padding} is a function, it is invoked for each node with children, being passed the current node. The left padding is used to separate the left edge of a node from its children.

\paragraph*{Treemap Tiling}

Several built-\/in tiling methods are provided for use with \href{#treemap_tile}{\tt {\itshape treemap}.tile}.

\label{_treemapBinary}%
\# d3.{\bfseries treemap\+Binary}({\itshape node}, {\itshape x0}, {\itshape y0}, {\itshape x1}, {\itshape y1}) \href{https://github.com/d3/d3-hierarchy/blob/master/src/treemap/binary.js}{\tt $<$$>$}

Recursively partitions the specified {\itshape nodes} into an approximately-\/balanced binary tree, choosing horizontal partitioning for wide rectangles and vertical partitioning for tall rectangles.

\label{_treemapDice}%
\# d3.{\bfseries treemap\+Dice}({\itshape node}, {\itshape x0}, {\itshape y0}, {\itshape x1}, {\itshape y1}) \href{https://github.com/d3/d3-hierarchy/blob/master/src/treemap/dice.js}{\tt $<$$>$}

Divides the rectangular area specified by {\itshape x0}, {\itshape y0}, {\itshape x1}, {\itshape y1} horizontally according the value of each of the specified {\itshape node$\ast$’s children. The children are positioned in order, starting with the left edge ($\ast$x0}) of the given rectangle. If the sum of the children’s values is less than the specified {\itshape node$\ast$’s value ($\ast$i.e.}, if the specified {\itshape node} has a non-\/zero internal value), the remaining empty space will be positioned on the right edge ({\itshape x1}) of the given rectangle.

\label{_treemapSlice}%
\# d3.{\bfseries treemap\+Slice}({\itshape node}, {\itshape x0}, {\itshape y0}, {\itshape x1}, {\itshape y1}) \href{https://github.com/d3/d3-hierarchy/blob/master/src/treemap/slice.js}{\tt $<$$>$}

Divides the rectangular area specified by {\itshape x0}, {\itshape y0}, {\itshape x1}, {\itshape y1} vertically according the value of each of the specified {\itshape node$\ast$’s children. The children are positioned in order, starting with the top edge ($\ast$y0}) of the given rectangle. If the sum of the children’s values is less than the specified {\itshape node$\ast$’s value ($\ast$i.e.}, if the specified {\itshape node} has a non-\/zero internal value), the remaining empty space will be positioned on the bottom edge ({\itshape y1}) of the given rectangle.

\label{_treemapSliceDice}%
\# d3.{\bfseries treemap\+Slice\+Dice}({\itshape node}, {\itshape x0}, {\itshape y0}, {\itshape x1}, {\itshape y1}) \href{https://github.com/d3/d3-hierarchy/blob/master/src/treemap/sliceDice.js}{\tt $<$$>$}

If the specified {\itshape node} has odd depth, delegates to \href{#treemapSlice}{\tt treemap\+Slice}; otherwise delegates to \href{#treemapDice}{\tt treemap\+Dice}.

\label{_treemapSquarify}%
\# d3.{\bfseries treemap\+Squarify}({\itshape node}, {\itshape x0}, {\itshape y0}, {\itshape x1}, {\itshape y1}) \href{https://github.com/d3/d3-hierarchy/blob/master/src/treemap/squarify.js}{\tt $<$$>$}

Implements the \href{https://www.win.tue.nl/~vanwijk/stm.pdf}{\tt squarified treemap} algorithm by Bruls {\itshape et al.}, which seeks to produce rectangles of a given \href{#squarify_ratio}{\tt aspect ratio}.

\label{_treemapResquarify}%
\# d3.{\bfseries treemap\+Resquarify}({\itshape node}, {\itshape x0}, {\itshape y0}, {\itshape x1}, {\itshape y1}) \href{https://github.com/d3/d3-hierarchy/blob/master/src/treemap/resquarify.js}{\tt $<$$>$}

Like \href{#treemapSquarify}{\tt d3.\+treemap\+Squarify}, except preserves the topology (node adjacencies) of the previous layout computed by d3.\+treemap\+Resquarify, if there is one and it used the same \href{#resquarify_ratio}{\tt target aspect ratio}. This tiling method is good for animating changes to treemaps because it only changes node sizes and not their relative positions, thus avoiding distracting shuffling and occlusion. The downside of a stable update, however, is a suboptimal layout for subsequent updates\+: only the first layout uses the Bruls {\itshape et al.} squarified algorithm.

\label{_squarify_ratio}%
\# {\itshape squarify}.{\bfseries ratio}({\itshape ratio}) \href{https://github.com/d3/d3-hierarchy/blob/master/src/treemap/squarify.js#L58}{\tt $<$$>$}

Specifies the desired aspect ratio of the generated rectangles. The {\itshape ratio} must be specified as a number greater than or equal to one. Note that the orientation of the generated rectangles (tall or wide) is not implied by the ratio; for example, a ratio of two will attempt to produce a mixture of rectangles whose {\itshape width}\+:{\itshape height} ratio is either 2\+:1 or 1\+:2. (However, you can approximately achieve this result by generating a square treemap at different dimensions, and then \href{http://bl.ocks.org/mbostock/5c50a377e76a1974248bd628befdec95}{\tt stretching the treemap} to the desired aspect ratio.) Furthermore, the specified {\itshape ratio} is merely a hint to the tiling algorithm; the rectangles are not guaranteed to have the specified aspect ratio. If not specified, the aspect ratio defaults to the golden ratio, φ = (1 + sqrt(5)) / 2, per \href{http://vis.stanford.edu/papers/perception-treemaps}{\tt Kong {\itshape et al.}}

\subsubsection*{Partition}

\href{http://bl.ocks.org/mbostock/2e73ec84221cb9773f4c}{\tt }

The {\bfseries partition layout} produces adjacency diagrams\+: a space-\/filling variant of a node-\/link tree diagram. Rather than drawing a link between parent and child in the hierarchy, nodes are drawn as solid areas (either arcs or rectangles), and their placement relative to other nodes reveals their position in the hierarchy. The size of the nodes encodes a quantitative dimension that would be difficult to show in a node-\/link diagram.

\label{_partition}%
\# d3.{\bfseries partition}()

Creates a new partition layout with the default settings.

\label{__partition}%
\# {\itshape partition}({\itshape root}) \href{https://github.com/d3/d3-hierarchy/blob/master/src/partition.js#L10}{\tt $<$$>$}

Lays out the specified {\itshape root} \href{#hierarchy}{\tt hierarchy}, assigning the following properties on {\itshape root} and its descendants\+:


\begin{DoxyItemize}
\item {\itshape node}.x0 -\/ the left edge of the rectangle
\item {\itshape node}.y0 -\/ the top edge of the rectangle
\item {\itshape node}.x1 -\/ the right edge of the rectangle
\item {\itshape node}.y1 -\/ the bottom edge of the rectangle
\end{DoxyItemize}

You must call \href{#node_sum}{\tt {\itshape root}.sum} before passing the hierarchy to the partition layout. You probably also want to call \href{#node_sort}{\tt {\itshape root}.sort} to order the hierarchy before computing the layout.

\label{_partition_size}%
\# {\itshape partition}.{\bfseries size}(\mbox{[}{\itshape size}\mbox{]}) \href{https://github.com/d3/d3-hierarchy/blob/master/src/partition.js#L43}{\tt $<$$>$}

If {\itshape size} is specified, sets this partition layout’s size to the specified two-\/element array of numbers \mbox{[}{\itshape width}, {\itshape height}\mbox{]} and returns this partition layout. If {\itshape size} is not specified, returns the current size, which defaults to \mbox{[}1, 1\mbox{]}.

\label{_partition_round}%
\# {\itshape partition}.{\bfseries round}(\mbox{[}{\itshape round}\mbox{]}) \href{https://github.com/d3/d3-hierarchy/blob/master/src/partition.js#L39}{\tt $<$$>$}

If {\itshape round} is specified, enables or disables rounding according to the given boolean and returns this partition layout. If {\itshape round} is not specified, returns the current rounding state, which defaults to false.

\label{_partition_padding}%
\# {\itshape partition}.{\bfseries padding}(\mbox{[}{\itshape padding}\mbox{]}) \href{https://github.com/d3/d3-hierarchy/blob/master/src/partition.js#L47}{\tt $<$$>$}

If {\itshape padding} is specified, sets the padding to the specified number and returns this partition layout. If {\itshape padding} is not specified, returns the current padding, which defaults to zero. The padding is used to separate a node’s adjacent children.

\subsubsection*{Pack}

\href{http://bl.ocks.org/mbostock/ca5b03a33affa4160321}{\tt }

Enclosure diagrams use containment (nesting) to represent a hierarchy. The size of the leaf circles encodes a quantitative dimension of the data. The enclosing circles show the approximate cumulative size of each subtree, but due to wasted space there is some distortion; only the leaf nodes can be compared accurately. Although \href{http://en.wikipedia.org/wiki/Circle_packing}{\tt circle packing} does not use space as efficiently as a \href{#treemap}{\tt treemap}, the “wasted” space more prominently reveals the hierarchical structure.

\label{_pack}%
\# d3.{\bfseries pack}()

Creates a new pack layout with the default settings.

\label{__pack}%
\# {\itshape pack}({\itshape root}) \href{https://github.com/d3/d3-hierarchy/blob/master/src/pack/index.js#L15}{\tt $<$$>$}

Lays out the specified {\itshape root} \href{#hierarchy}{\tt hierarchy}, assigning the following properties on {\itshape root} and its descendants\+:


\begin{DoxyItemize}
\item {\itshape node}.x -\/ the {\itshape x}-\/coordinate of the circle’s center
\item {\itshape node}.y -\/ the {\itshape y}-\/coordinate of the circle’s center
\item {\itshape node}.r -\/ the radius of the circle
\end{DoxyItemize}

You must call \href{#node_sum}{\tt {\itshape root}.sum} before passing the hierarchy to the pack layout. You probably also want to call \href{#node_sort}{\tt {\itshape root}.sort} to order the hierarchy before computing the layout.

\label{_pack_radius}%
\# {\itshape pack}.{\bfseries radius}(\mbox{[}{\itshape radius}\mbox{]}) \href{https://github.com/d3/d3-hierarchy/blob/master/src/pack/index.js#L30}{\tt $<$$>$}

If {\itshape radius} is specified, sets the pack layout’s radius accessor to the specified function and returns this pack layout. If {\itshape radius} is not specified, returns the current radius accessor, which defaults to null. If the radius accessor is null, the radius of each leaf circle is derived from the leaf {\itshape node}.value (computed by \href{#node_sum}{\tt {\itshape node}.sum}); the radii are then scaled proportionally to fit the \href{#pack_size}{\tt layout size}. If the radius accessor is not null, the radius of each leaf circle is specified exactly by the function.

\label{_pack_size}%
\# {\itshape pack}.{\bfseries size}(\mbox{[}{\itshape size}\mbox{]}) \href{https://github.com/d3/d3-hierarchy/blob/master/src/pack/index.js#L34}{\tt $<$$>$}

If {\itshape size} is specified, sets this pack layout’s size to the specified two-\/element array of numbers \mbox{[}{\itshape width}, {\itshape height}\mbox{]} and returns this pack layout. If {\itshape size} is not specified, returns the current size, which defaults to \mbox{[}1, 1\mbox{]}.

\label{_pack_padding}%
\# {\itshape pack}.{\bfseries padding}(\mbox{[}{\itshape padding}\mbox{]}) \href{https://github.com/d3/d3-hierarchy/blob/master/src/pack/index.js#L38}{\tt $<$$>$}

If {\itshape padding} is specified, sets this pack layout’s padding accessor to the specified number or function or returns this pack layout. If {\itshape padding} is not specified, returns the current padding accessor, which defaults to the constant zero. When siblings are packed, tangent siblings will be separated by approximately the specified padding; the enclosing parent circle will also be separated from its children by approximately the specified padding. If an \href{#pack_radius}{\tt explicit radius} is not specified, the padding is approximate because a two-\/pass algorithm is needed to fit within the \href{#pack_size}{\tt layout size}\+: the circles are first packed without padding; a scaling factor is computed and applied to the specified padding; and lastly the circles are re-\/packed with padding.

\label{_packSiblings}%
\# d3.{\bfseries pack\+Siblings}({\itshape circles}) \href{https://github.com/d3/d3-hierarchy/blob/master/src/pack/siblings.js}{\tt $<$$>$}

Packs the specified array of {\itshape circles}, each of which must have a {\itshape circle}.r property specifying the circle’s radius. Assigns the following properties to each circle\+:


\begin{DoxyItemize}
\item {\itshape circle}.x -\/ the {\itshape x}-\/coordinate of the circle’s center
\item {\itshape circle}.y -\/ the {\itshape y}-\/coordinate of the circle’s center
\end{DoxyItemize}

The circles are positioned according to the front-\/chain packing algorithm by \href{https://dl.acm.org/citation.cfm?id=1124851}{\tt Wang {\itshape et al.}}

\label{_packEnclose}%
\# d3.{\bfseries pack\+Enclose}({\itshape circles}) \href{https://github.com/d3/d3-hierarchy/blob/master/src/pack/enclose.js}{\tt $<$$>$}

Computes the \href{https://en.wikipedia.org/wiki/Smallest-circle_problem}{\tt smallest circle} that encloses the specified array of {\itshape circles}, each of which must have a {\itshape circle}.r property specifying the circle’s radius, and {\itshape circle}.x and {\itshape circle}.y properties specifying the circle’s center. The enclosing circle is computed using the \href{http://www.inf.ethz.ch/personal/emo/PublFiles/SubexLinProg_ALG16_96.pdf}{\tt Matoušek-\/\+Sharir-\/\+Welzl algorithm}. (See also \href{https://bl.ocks.org/mbostock/751fdd637f4bc2e3f08b}{\tt Apollonius’ Problem}.) 