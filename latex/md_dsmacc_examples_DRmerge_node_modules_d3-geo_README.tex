Map projections are sometimes implemented as point transformations. For instance, spherical Mercator\+:


\begin{DoxyCode}
function mercator(x, y) \{
  return [x, Math.log(Math.tan(Math.PI / 4 + y / 2))];
\}
\end{DoxyCode}


This is a reasonable {\itshape mathematical} approach if your geometry consists of continuous, infinite point sets. Yet computers do not have infinite memory, so we must instead work with discrete geometry such as polygons and polylines!

Discrete geometry makes the challenge of projecting from the sphere to the plane much harder. The edges of a spherical polygon are \href{https://en.wikipedia.org/wiki/Geodesic}{\tt geodesics} (segments of great circles), not straight lines. Projected to the plane, geodesics are curves in all map projections except \href{#geoGnomonic}{\tt gnomonic}, and thus accurate projection requires interpolation along each arc. D3 uses \href{https://bl.ocks.org/mbostock/3795544}{\tt adaptive sampling} inspired by a popular \href{https://bost.ocks.org/mike/simplify/}{\tt line simplification method} to balance accuracy and performance.

The projection of polygons and polylines must also deal with the topological differences between the sphere and the plane. Some projections require cutting geometry that \href{https://bl.ocks.org/mbostock/3788999}{\tt crosses the antimeridian}, while others require \href{https://bl.ocks.org/mbostock/3021474}{\tt clipping geometry to a great circle}.

Spherical polygons also require a \href{https://bl.ocks.org/mbostock/a7bdfeb041e850799a8d3dce4d8c50c8}{\tt winding order convention} to determine which side of the polygon is the inside\+: the exterior ring for polygons smaller than a hemisphere must be clockwise, while the exterior ring for polygons \href{https://bl.ocks.org/mbostock/6713736}{\tt larger than a hemisphere} must be anticlockwise. Interior rings representing holes must use the opposite winding order of their exterior ring. This winding order convention is also used by \href{https://github.com/topojson}{\tt Topo\+J\+S\+ON} and \href{https://github.com/mbostock/shapefile}{\tt E\+S\+RI shapefiles}; however, it is the {\bfseries opposite} convention of Geo\+J\+S\+O\+N’s \href{https://tools.ietf.org/html/rfc7946#section-3.1.6}{\tt R\+FC 7946}. (Also note that standard Geo\+J\+S\+ON W\+G\+S84 uses planar equirectangular coordinates, not spherical coordinates, and thus may require \href{https://github.com/d3/d3-geo-projection/blob/master/README.md#geostitch}{\tt stitching} to remove antimeridian cuts.)

D3’s approach affords great expressiveness\+: you can choose the right projection, and the right aspect, for your data. D3 supports a wide variety of common and \href{https://github.com/d3/d3-geo-projection}{\tt unusual map projections}. For more, see Part 2 of \href{https://vimeo.com/106198518#t=20m0s}{\tt The Toolmaker’s Guide}.

D3 uses \href{http://geojson.org/geojson-spec.html}{\tt Geo\+J\+S\+ON} to represent geographic features in Java\+Script. (See also \href{https://github.com/mbostock/topojson}{\tt Topo\+J\+S\+ON}, an extension of Geo\+J\+S\+ON that is significantly more compact and encodes topology.) To convert shapefiles to Geo\+J\+S\+ON, use \href{https://github.com/mbostock/shapefile/blob/master/README.md#shp2geo}{\tt shp2geo}, part of the \href{https://github.com/mbostock/shapefile}{\tt shapefile package}. See \href{https://medium.com/@mbostock/command-line-cartography-part-1-897aa8f8ca2c}{\tt Command-\/\+Line Cartography} for an introduction to d3-\/geo and related tools.

\subsection*{Installing}

If you use N\+PM, {\ttfamily npm install d3-\/geo}. Otherwise, download the \href{https://github.com/d3/d3-geo/releases/latest}{\tt latest release}. You can also load directly from \href{https://d3js.org}{\tt d3js.\+org}, either as a \href{https://d3js.org/d3-geo.v1.min.js}{\tt standalone library} or as part of \href{https://github.com/d3/d3}{\tt D3 4.\+0}. A\+MD, Common\+JS, and vanilla environments are supported. In vanilla, a {\ttfamily d3} global is exported\+:


\begin{DoxyCode}
<script src="https://d3js.org/d3-array.v1.min.js"></script>
<script src="https://d3js.org/d3-geo.v1.min.js"></script>
<script>

var projection = d3.geoNaturalEarth1(),
    path = d3.geoPath(projection);

</script>
\end{DoxyCode}


\href{https://tonicdev.com/npm/d3-geo}{\tt Try d3-\/geo in your browser.}

\subsection*{A\+PI Reference}


\begin{DoxyItemize}
\item \href{#paths}{\tt Paths}
\item \href{#projections}{\tt Projections} (\href{#azimuthal-projections}{\tt Azimuthal}, \href{#composite-projections}{\tt Composite}, \href{#conic-projections}{\tt Conic}, \href{#cylindrical-projections}{\tt Cylindrical})
\item \href{#raw-projections}{\tt Raw Projections}
\item \href{#spherical-math}{\tt Spherical Math}
\item \href{#spherical-shapes}{\tt Spherical Shapes}
\item \href{#streams}{\tt Streams}
\item \href{#transforms}{\tt Transforms}
\item \href{#clipping}{\tt Clipping}
\end{DoxyItemize}

\subsubsection*{Paths}

The geographic path generator, \href{#geoPath}{\tt d3.\+geo\+Path}, is similar to the shape generators in \href{https://github.com/d3/d3-shape}{\tt d3-\/shape}\+: given a Geo\+J\+S\+ON geometry or feature object, it generates an S\+VG path data string or \href{https://bl.ocks.org/mbostock/3783604}{\tt renders the path to a Canvas}. Canvas is recommended for dynamic or interactive projections to improve performance. Paths can be used with \href{#projections}{\tt projections} or \href{#transforms}{\tt transforms}, or they can be used to render planar geometry directly to Canvas or S\+VG.

\href{#geoPath}{\tt \#} d3.{\bfseries geo\+Path}(\mbox{[}{\itshape projection}\mbox{[}, {\itshape context}\mbox{]}\mbox{]}) \href{https://github.com/d3/d3-geo/blob/master/src/path/index.js}{\tt $<$$>$}

Creates a new geographic path generator with the default settings. If {\itshape projection} is specified, sets the \href{#path_projection}{\tt current projection}. If {\itshape context} is specified, sets the \href{#path_context}{\tt current context}.

\href{#_path}{\tt \#} {\itshape path}({\itshape object}\mbox{[}, {\itshape arguments…}\mbox{]}) \href{https://github.com/d3/d3-geo/blob/master/src/path/index.js#L15}{\tt $<$$>$}

Renders the given {\itshape object}, which may be any Geo\+J\+S\+ON feature or geometry object\+:


\begin{DoxyItemize}
\item Point -\/ a single position.
\item Multi\+Point -\/ an array of positions.
\item Line\+String -\/ an array of positions forming a continuous line.
\item Multi\+Line\+String -\/ an array of arrays of positions forming several lines.
\item Polygon -\/ an array of arrays of positions forming a polygon (possibly with holes).
\item Multi\+Polygon -\/ a multidimensional array of positions forming multiple polygons.
\item Geometry\+Collection -\/ an array of geometry objects.
\item Feature -\/ a feature containing one of the above geometry objects.
\item Feature\+Collection -\/ an array of feature objects.
\end{DoxyItemize}

The type {\itshape Sphere} is also supported, which is useful for rendering the outline of the globe; a sphere has no coordinates. Any additional {\itshape arguments} are passed along to the \href{#path_pointRadius}{\tt point\+Radius} accessor.

To display multiple features, combine them into a feature collection\+:


\begin{DoxyCode}
svg.append("path")
    .datum(\{type: "FeatureCollection", features: features\})
    .attr("d", d3.geoPath());
\end{DoxyCode}


Or use multiple path elements\+:


\begin{DoxyCode}
svg.selectAll("path")
  .data(features)
  .enter().append("path")
    .attr("d", d3.geoPath());
\end{DoxyCode}


Separate path elements are typically slower than a single path element. However, distinct path elements are useful for styling and interaction (e.\+g., click or mouseover). Canvas rendering (see \href{#path_context}{\tt {\itshape path}.context}) is typically faster than S\+VG, but requires more effort to implement styling and interaction.

\href{#path_area}{\tt \#} {\itshape path}.{\bfseries area}({\itshape object}) \href{https://github.com/d3/d3-geo/blob/master/src/path/area.js}{\tt $<$$>$}

Returns the projected planar area (typically in square pixels) for the specified Geo\+J\+S\+ON {\itshape object}. Point, Multi\+Point, Line\+String and Multi\+Line\+String geometries have zero area. For Polygon and Multi\+Polygon geometries, this method first computes the area of the exterior ring, and then subtracts the area of any interior holes. This method observes any clipping performed by the \href{#path_projection}{\tt projection}; see \href{#projection_clipAngle}{\tt {\itshape projection}.clip\+Angle} and \href{#projection_clipExtent}{\tt {\itshape projection}.clip\+Extent}. This is the planar equivalent of \href{#geoArea}{\tt d3.\+geo\+Area}.

\href{#path_bounds}{\tt \#} {\itshape path}.{\bfseries bounds}({\itshape object}) \href{https://github.com/d3/d3-geo/blob/master/src/path/bounds.js}{\tt $<$$>$}

Returns the projected planar bounding box (typically in pixels) for the specified Geo\+J\+S\+ON {\itshape object}. The bounding box is represented by a two-\/dimensional array\+: \mbox{[}\mbox{[}{\itshape x₀}, {\itshape y₀}\mbox{]}, \mbox{[}{\itshape x₁}, {\itshape y₁}\mbox{]}\mbox{]}, where {\itshape x₀} is the minimum {\itshape x}-\/coordinate, {\itshape y₀} is the minimum {\itshape y}-\/coordinate, {\itshape x₁} is maximum {\itshape x}-\/coordinate, and {\itshape y₁} is the maximum {\itshape y}-\/coordinate. This is handy for, say, zooming in to a particular feature. (Note that in projected planar coordinates, the minimum latitude is typically the maximum {\itshape y}-\/value, and the maximum latitude is typically the minimum {\itshape y}-\/value.) This method observes any clipping performed by the \href{#path_projection}{\tt projection}; see \href{#projection_clipAngle}{\tt {\itshape projection}.clip\+Angle} and \href{#projection_clipExtent}{\tt {\itshape projection}.clip\+Extent}. This is the planar equivalent of \href{#geoBounds}{\tt d3.\+geo\+Bounds}.

\href{#path_centroid}{\tt \#} {\itshape path}.{\bfseries centroid}({\itshape object}) \href{https://github.com/d3/d3-geo/blob/master/src/path/centroid.js}{\tt $<$$>$}

Returns the projected planar centroid (typically in pixels) for the specified Geo\+J\+S\+ON {\itshape object}. This is handy for, say, labeling state or county boundaries, or displaying a symbol map. For example, a \href{https://bl.ocks.org/mbostock/4055908}{\tt noncontiguous cartogram} might scale each state around its centroid. This method observes any clipping performed by the \href{#path_projection}{\tt projection}; see \href{#projection_clipAngle}{\tt {\itshape projection}.clip\+Angle} and \href{#projection_clipExtent}{\tt {\itshape projection}.clip\+Extent}. This is the planar equivalent of \href{#geoCentroid}{\tt d3.\+geo\+Centroid}.

\href{#path_measure}{\tt \#} {\itshape path}.{\bfseries measure}({\itshape object}) \href{https://github.com/d3/d3-geo/blob/master/src/path/measure.js}{\tt $<$$>$}

Returns the projected planar length (typically in pixels) for the specified Geo\+J\+S\+ON {\itshape object}. Point and Multi\+Point geometries have zero length. For Polygon and Multi\+Polygon geometries, this method computes the summed length of all rings. This method observes any clipping performed by the \href{#path_projection}{\tt projection}; see \href{#projection_clipAngle}{\tt {\itshape projection}.clip\+Angle} and \href{#projection_clipExtent}{\tt {\itshape projection}.clip\+Extent}. This is the planar equivalent of \href{#geoLength}{\tt d3.\+geo\+Length}.

\href{#path_projection}{\tt \#} {\itshape path}.{\bfseries projection}(\mbox{[}{\itshape projection}\mbox{]}) \href{https://github.com/d3/d3-geo/blob/master/src/path/index.js#L48}{\tt $<$$>$}

If a {\itshape projection} is specified, sets the current projection to the specified projection. If {\itshape projection} is not specified, returns the current projection, which defaults to null. The null projection represents the identity transformation\+: the input geometry is not projected and is instead rendered directly in raw coordinates. This can be useful for fast rendering of \href{https://bl.ocks.org/mbostock/5557726}{\tt pre-\/projected geometry}, or for fast rendering of the equirectangular projection.

The given {\itshape projection} is typically one of D3’s built-\/in \href{#projections}{\tt geographic projections}; however, any object that exposes a \href{#projection_stream}{\tt {\itshape projection}.stream} function can be used, enabling the use of \href{https://bl.ocks.org/mbostock/5663666}{\tt custom projections}. See D3’s \href{#transforms}{\tt transforms} for more examples of arbitrary geometric transformations.

\href{#path_context}{\tt \#} {\itshape path}.{\bfseries context}(\mbox{[}{\itshape context}\mbox{]}) \href{https://github.com/d3/d3-geo/blob/master/src/path/index.js#L52}{\tt $<$$>$}

If {\itshape context} is specified, sets the current render context and returns the path generator. If the {\itshape context} is null, then the \href{#_path}{\tt path generator} will return an S\+VG path string; if the context is non-\/null, the path generator will instead call methods on the specified context to render geometry. The context must implement the following subset of the \href{https://www.w3.org/TR/2dcontext/#canvasrenderingcontext2d}{\tt Canvas\+Rendering\+Context2D A\+PI}\+:


\begin{DoxyItemize}
\item {\itshape context}.begin\+Path()
\item {\itshape context}.move\+To({\itshape x}, {\itshape y})
\item {\itshape context}.line\+To({\itshape x}, {\itshape y})
\item {\itshape context}.arc({\itshape x}, {\itshape y}, {\itshape radius}, {\itshape start\+Angle}, {\itshape end\+Angle})
\item {\itshape context}.close\+Path()
\end{DoxyItemize}

If a {\itshape context} is not specified, returns the current render context which defaults to null.

\href{#path_pointRadius}{\tt \#} {\itshape path}.{\bfseries point\+Radius}(\mbox{[}{\itshape radius}\mbox{]}) \href{https://github.com/d3/d3-geo/blob/master/src/path/index.js#L59}{\tt $<$$>$}

If {\itshape radius} is specified, sets the radius used to display Point and Multi\+Point geometries to the specified number. If {\itshape radius} is not specified, returns the current radius accessor, which defaults to 4.\+5. While the radius is commonly specified as a number constant, it may also be specified as a function which is computed per feature, being passed the any arguments passed to the \href{#_path}{\tt path generator}. For example, if your Geo\+J\+S\+ON data has additional properties, you might access those properties inside the radius function to vary the point size; alternatively, you could \href{https://github.com/d3/d3-shape#symbols}{\tt d3.\+symbol} and a \href{#geoProjection}{\tt projection} for greater flexibility.

\subsubsection*{Projections}

Projections transform spherical polygonal geometry to planar polygonal geometry. D3 provides implementations of several classes of standard projections\+:


\begin{DoxyItemize}
\item \href{#azimuthal-projections}{\tt Azimuthal}
\item \href{#composite-projections}{\tt Composite}
\item \href{#conic-projections}{\tt Conic}
\item \href{#cylindrical-projections}{\tt Cylindrical}
\end{DoxyItemize}

For many more projections, see \href{https://github.com/d3/d3-geo-projection}{\tt d3-\/geo-\/projection}. You can implement \href{#raw-projections}{\tt custom projections} using \href{#geoProjection}{\tt d3.\+geo\+Projection} or \href{#geoProjectionMutator}{\tt d3.\+geo\+Projection\+Mutator}.

\href{#_projection}{\tt \#} {\itshape projection}({\itshape point}) \href{https://github.com/d3/d3-geo/blob/master/src/projection/index.js#L34}{\tt $<$$>$}

Returns a new array \mbox{[}{\itshape x}, {\itshape y}\mbox{]} (typically in pixels) representing the projected point of the given {\itshape point}. The point must be specified as a two-\/element array \mbox{[}{\itshape longitude}, {\itshape latitude}\mbox{]} in degrees. May return null if the specified {\itshape point} has no defined projected position, such as when the point is outside the clipping bounds of the projection.

\href{#projection_invert}{\tt \#} {\itshape projection}.{\bfseries invert}({\itshape point}) \href{https://github.com/d3/d3-geo/blob/master/src/projection/index.js#L39}{\tt $<$$>$}

Returns a new array \mbox{[}{\itshape longitude}, {\itshape latitude}\mbox{]} in degrees representing the unprojected point of the given projected {\itshape point}. The point must be specified as a two-\/element array \mbox{[}{\itshape x}, {\itshape y}\mbox{]} (typically in pixels). May return null if the specified {\itshape point} has no defined projected position, such as when the point is outside the clipping bounds of the projection.

This method is only defined on invertible projections.

\href{#projection_stream}{\tt \#} {\itshape projection}.{\bfseries stream}({\itshape stream}) \href{https://github.com/d3/d3-geo/blob/master/src/projection/index.js#L48}{\tt $<$$>$}

Returns a \href{#streams}{\tt projection stream} for the specified output {\itshape stream}. Any input geometry is projected before being streamed to the output stream. A typical projection involves several geometry transformations\+: the input geometry is first converted to radians, rotated on three axes, clipped to the small circle or cut along the antimeridian, and lastly projected to the plane with adaptive resampling, scale and translation.

\href{#projection_preclip}{\tt \#} {\itshape projection}.{\bfseries preclip}(\mbox{[}{\itshape preclip}\mbox{]})

If {\itshape preclip} is specified, sets the projection’s spherical clipping to the specified function and returns the projection. If {\itshape preclip} is not specified, returns the current spherical clipping function (see \href{#preclip}{\tt preclip}).

\href{#projection_postclip}{\tt \#} {\itshape projection}.{\bfseries postclip}(\mbox{[}{\itshape postclip}\mbox{]})

If {\itshape postclip} is specified, sets the projection’s cartesian clipping to the specified function and returns the projection. If {\itshape postclip} is not specified, returns the current cartesian clipping function (see \href{#postclip}{\tt postclip}).

\href{#projection_clipAngle}{\tt \#} {\itshape projection}.{\bfseries clip\+Angle}(\mbox{[}{\itshape angle}\mbox{]}) \href{https://github.com/d3/d3-geo/blob/master/src/projection/index.js#L52}{\tt $<$$>$}

If {\itshape angle} is specified, sets the projection’s clipping circle radius to the specified angle in degrees and returns the projection. If {\itshape angle} is null, switches to \href{https://bl.ocks.org/mbostock/3788999}{\tt antimeridian cutting} rather than small-\/circle clipping. If {\itshape angle} is not specified, returns the current clip angle which defaults to null. Small-\/circle clipping is independent of viewport clipping via \href{#projection_clipExtent}{\tt {\itshape projection}.clip\+Extent}.

See also \href{#projection_preclip}{\tt {\itshape projection}.preclip}, \href{#geoClipAntimeridian}{\tt d3.\+geo\+Clip\+Antimeridian}, \href{#geoClipCircle}{\tt d3.\+geo\+Clip\+Circle}.

\href{#projection_clipExtent}{\tt \#} {\itshape projection}.{\bfseries clip\+Extent}(\mbox{[}{\itshape extent}\mbox{]}) \href{https://github.com/d3/d3-geo/blob/master/src/projection/index.js#L56}{\tt $<$$>$}

If {\itshape extent} is specified, sets the projection’s viewport clip extent to the specified bounds in pixels and returns the projection. The {\itshape extent} bounds are specified as an array \mbox{[}\mbox{[}{\itshape x₀}, {\itshape y₀}\mbox{]}, \mbox{[}{\itshape x₁}, {\itshape y₁}\mbox{]}\mbox{]}, where {\itshape x₀} is the left-\/side of the viewport, {\itshape y₀} is the top, {\itshape x₁} is the right and {\itshape y₁} is the bottom. If {\itshape extent} is null, no viewport clipping is performed. If {\itshape extent} is not specified, returns the current viewport clip extent which defaults to null. Viewport clipping is independent of small-\/circle clipping via \href{#projection_clipAngle}{\tt {\itshape projection}.clip\+Angle}.

See also \href{#projection_postclip}{\tt {\itshape projection}.postclip}, \href{#geoClipRectangle}{\tt d3.\+geo\+Clip\+Rectangle}.

\href{#projection_scale}{\tt \#} {\itshape projection}.{\bfseries scale}(\mbox{[}{\itshape scale}\mbox{]}) \href{https://github.com/d3/d3-geo/blob/master/src/projection/index.js#L60}{\tt $<$$>$}

If {\itshape scale} is specified, sets the projection’s scale factor to the specified value and returns the projection. If {\itshape scale} is not specified, returns the current scale factor; the default scale is projection-\/specific. The scale factor corresponds linearly to the distance between projected points; however, absolute scale factors are not equivalent across projections.

\href{#projection_translate}{\tt \#} {\itshape projection}.{\bfseries translate}(\mbox{[}{\itshape translate}\mbox{]}) \href{https://github.com/d3/d3-geo/blob/master/src/projection/index.js#L64v}{\tt $<$$>$}

If {\itshape translate} is specified, sets the projection’s translation offset to the specified two-\/element array \mbox{[}{\itshape t\textsubscript{x}}, {\itshape t\textsubscript{y}}\mbox{]} and returns the projection. If {\itshape translate} is not specified, returns the current translation offset which defaults to \mbox{[}480, 250\mbox{]}. The translation offset determines the pixel coordinates of the projection’s \href{#projection_center}{\tt center}. The default translation offset places ⟨0°,0°⟩ at the center of a 960×500 area.

\href{#projection_center}{\tt \#} {\itshape projection}.{\bfseries center}(\mbox{[}{\itshape center}\mbox{]}) \href{https://github.com/d3/d3-geo/blob/master/src/projection/index.js#L68}{\tt $<$$>$}

If {\itshape center} is specified, sets the projection’s center to the specified {\itshape center}, a two-\/element array of longitude and latitude in degrees and returns the projection. If {\itshape center} is not specified, returns the current center, which defaults to ⟨0°,0°⟩.

\href{#projection_rotate}{\tt \#} {\itshape projection}.{\bfseries rotate}(\mbox{[}{\itshape angles}\mbox{]}) \href{https://github.com/d3/d3-geo/blob/master/src/projection/index.js#L72}{\tt $<$$>$}

If {\itshape rotation} is specified, sets the projection’s \href{https://bl.ocks.org/mbostock/4282586}{\tt three-\/axis rotation} to the specified {\itshape angles}, which must be a two-\/ or three-\/element array of numbers \mbox{[}{\itshape lambda}, {\itshape phi}, {\itshape gamma}\mbox{]} specifying the rotation angles in degrees about \href{https://bl.ocks.org/mbostock/4282586}{\tt each spherical axis}. (These correspond to \href{http://en.wikipedia.org/wiki/Aircraft_principal_axes}{\tt yaw, pitch and roll}.) If the rotation angle {\itshape gamma} is omitted, it defaults to 0. See also \href{#geoRotation}{\tt d3.\+geo\+Rotation}. If {\itshape rotation} is not specified, returns the current rotation which defaults \mbox{[}0, 0, 0\mbox{]}.

\href{#projection_precision}{\tt \#} {\itshape projection}.{\bfseries precision}(\mbox{[}{\itshape precision}\mbox{]}) \href{https://github.com/d3/d3-geo/blob/master/src/projection/index.js#L76}{\tt $<$$>$}

If {\itshape precision} is specified, sets the threshold for the projection’s \href{https://bl.ocks.org/mbostock/3795544}{\tt adaptive resampling} to the specified value in pixels and returns the projection. This value corresponds to the \href{http://en.wikipedia.org/wiki/Ramer–Douglas–Peucker_algorithm}{\tt Douglas–\+Peucker} distance. If {\itshape precision} is not specified, returns the projection’s current resampling precision which defaults to √0.5 ≅ 0.\+70710…

\href{#projection_fitExtent}{\tt \#} {\itshape projection}.{\bfseries fit\+Extent}({\itshape extent}, {\itshape object}) \href{https://github.com/d3/d3-geo/blob/master/src/projection/index.js#L80}{\tt $<$$>$}

Sets the projection’s \href{#projection_scale}{\tt scale} and \href{#projection_translate}{\tt translate} to fit the specified Geo\+J\+S\+ON {\itshape object} in the center of the given {\itshape extent}. The extent is specified as an array \mbox{[}\mbox{[}x₀, y₀\mbox{]}, \mbox{[}x₁, y₁\mbox{]}\mbox{]}, where x₀ is the left side of the bounding box, y₀ is the top, x₁ is the right and y₁ is the bottom. Returns the projection.

For example, to scale and translate the \href{https://bl.ocks.org/mbostock/5126418}{\tt New Jersey State Plane projection} to fit a Geo\+J\+S\+ON object {\itshape nj} in the center of a 960×500 bounding box with 20 pixels of padding on each side\+:


\begin{DoxyCode}
var projection = d3.geoTransverseMercator()
    .rotate([74 + 30 / 60, -38 - 50 / 60])
    .fitExtent([[20, 20], [940, 480]], nj);
\end{DoxyCode}


Any \href{#projection_clipExtent}{\tt clip extent} is ignored when determining the new scale and translate. The \href{#projection_precision}{\tt precision} used to compute the bounding box of the given {\itshape object} is computed at an effective scale of 150.

\href{#projection_fitSize}{\tt \#} {\itshape projection}.{\bfseries fit\+Size}({\itshape size}, {\itshape object}) \href{https://github.com/d3/d3-geo/blob/master/src/projection/index.js#L82}{\tt $<$$>$}

A convenience method for \href{#projection_fitExtent}{\tt {\itshape projection}.fit\+Extent} where the top-\/left corner of the extent is \mbox{[}0, 0\mbox{]}. The following two statements are equivalent\+:


\begin{DoxyCode}
projection.fitExtent([[0, 0], [width, height]], object);
projection.fitSize([width, height], object);
\end{DoxyCode}


\href{#projection_fitWidth}{\tt \#} {\itshape projection}.{\bfseries fit\+Width}({\itshape width}, {\itshape object}) \href{https://github.com/d3/d3-geo/blob/master/src/projection/index.js#L105}{\tt $<$$>$}

A convenience method for \href{#projection_fitSize}{\tt {\itshape projection}.fit\+Size} where the height is automatically chosen from the aspect ratio of {\itshape object} and the given constraint on {\itshape width}.

\href{#projection_fitHeight}{\tt \#} {\itshape projection}.{\bfseries fit\+Height}({\itshape height}, {\itshape object}) \href{https://github.com/d3/d3-geo/blob/master/src/projection/index.js#L109}{\tt $<$$>$}

A convenience method for \href{#projection_fitSize}{\tt {\itshape projection}.fit\+Size} where the width is automatically chosen from the aspect ratio of {\itshape object} and the given contraint on {\itshape height}.

\paragraph*{Azimuthal Projections}

Azimuthal projections project the sphere directly onto a plane.

\href{#geoAzimuthalEqualArea}{\tt \#} d3.{\bfseries geo\+Azimuthal\+Equal\+Area}() \href{https://github.com/d3/d3-geo/blob/master/src/projection/azimuthalEqualArea.js}{\tt $<$$>$} ~\newline
\href{#geoAzimuthalEqualAreaRaw}{\tt \#} d3.{\bfseries geo\+Azimuthal\+Equal\+Area\+Raw}

\href{https://bl.ocks.org/mbostock/3757101}{\tt }

The azimuthal equal-\/area projection.

\href{#geoAzimuthalEquidistant}{\tt \#} d3.{\bfseries geo\+Azimuthal\+Equidistant}() \href{https://github.com/d3/d3-geo/blob/master/src/projection/azimuthalEquidistant.js}{\tt $<$$>$} ~\newline
\href{#geoAzimuthalEquidistantRaw}{\tt \#} d3.{\bfseries geo\+Azimuthal\+Equidistant\+Raw}

\href{https://bl.ocks.org/mbostock/3757110}{\tt }

The azimuthal equidistant projection.

\href{#geoGnomonic}{\tt \#} d3.{\bfseries geo\+Gnomonic}() \href{https://github.com/d3/d3-geo/blob/master/src/projection/gnomonic.js}{\tt $<$$>$} ~\newline
\href{#geoGnomonicRaw}{\tt \#} d3.{\bfseries geo\+Gnomonic\+Raw}

\href{https://bl.ocks.org/mbostock/3757349}{\tt }

The gnomonic projection.

\href{#geoOrthographic}{\tt \#} d3.{\bfseries geo\+Orthographic}() \href{https://github.com/d3/d3-geo/blob/master/src/projection/orthographic.js}{\tt $<$$>$} ~\newline
\href{#geoOrthographicRaw}{\tt \#} d3.{\bfseries geo\+Orthographic\+Raw}

\href{https://bl.ocks.org/mbostock/3757125}{\tt }

The orthographic projection.

\href{#geoStereographic}{\tt \#} d3.{\bfseries geo\+Stereographic}() \href{https://github.com/d3/d3-geo/blob/master/src/projection/stereographic.js}{\tt $<$$>$} ~\newline
\href{#geoStereographicRaw}{\tt \#} d3.{\bfseries geo\+Stereographic\+Raw}

\href{https://bl.ocks.org/mbostock/3757137}{\tt }

The stereographic projection.

\paragraph*{Composite Projections}

Composite consist of several projections that are composed into a single display. The constituent projections have fixed clip, center and rotation, and thus composite projections do not support \href{#projection_center}{\tt {\itshape projection}.center}, \href{#projection_rotate}{\tt {\itshape projection}.rotate}, \href{#projection_clipAngle}{\tt {\itshape projection}.clip\+Angle}, or \href{#projection_clipExtent}{\tt {\itshape projection}.clip\+Extent}.

\href{#geoAlbersUsa}{\tt \#} d3.{\bfseries geo\+Albers\+Usa}() \href{https://github.com/d3/d3-geo/blob/master/src/projection/albersUsa.js}{\tt $<$$>$}

\href{https://bl.ocks.org/mbostock/4090848}{\tt }

This is a U.\+S.-\/centric composite projection of three \href{#geoConicEqualArea}{\tt d3.\+geo\+Conic\+Equal\+Area} projections\+: \href{#geoAlbers}{\tt d3.\+geo\+Albers} is used for the lower forty-\/eight states, and separate conic equal-\/area projections are used for Alaska and Hawaii. Note that the scale for Alaska is diminished\+: it is projected at 0.\+35× its true relative area. This diagram by Philippe Rivière illustrates how this projection uses two rectangular insets for Alaska and Hawaii\+:

\href{https://bl.ocks.org/Fil/7723167596af40d9159be34ffbf8d36b}{\tt }

See \href{http://geoexamples.com/d3-composite-projections/}{\tt d3-\/composite-\/projections} for more examples.

\paragraph*{Conic Projections}

Conic projections project the sphere onto a cone, and then unroll the cone onto the plane. Conic projections have \href{#conic_parallels}{\tt two standard parallels}.

\href{#conic_parallels}{\tt \#} {\itshape conic}.{\bfseries parallels}(\mbox{[}{\itshape parallels}\mbox{]}) \href{https://github.com/d3/d3-geo/blob/master/src/projection/conic.js#L10}{\tt $<$$>$}

The \href{https://en.wikipedia.org/wiki/Map_projection#Conic}{\tt two standard parallels} that define the map layout in conic projections.

\href{#geoAlbers}{\tt \#} d3.{\bfseries geo\+Albers}() \href{https://github.com/d3/d3-geo/blob/master/src/projection/albers.js}{\tt $<$$>$}

\href{https://bl.ocks.org/mbostock/3734308}{\tt }

The Albers’ equal area-\/conic projection. This is a U.\+S.-\/centric configuration of \href{#geoConicEqualArea}{\tt d3.\+geo\+Conic\+Equal\+Area}.

\href{#geoConicConformal}{\tt \#} d3.{\bfseries geo\+Conic\+Conformal}() \href{https://github.com/d3/d3-geo/blob/master/src/projection/conicConformal.js}{\tt $<$$>$} ~\newline
\href{#geoConicConformalRaw}{\tt \#} d3.{\bfseries geo\+Conic\+Conformal\+Raw}({\itshape phi0}, {\itshape phi1}) \href{https://github.com/d3/d3-geo/blob/master/src/projection/conicConformal.js}{\tt $<$$>$}

\href{https://bl.ocks.org/mbostock/3734321}{\tt }

The conic conformal projection. The parallels default to \mbox{[}30°, 30°\mbox{]} resulting in flat top. See also \href{#conic_parallels}{\tt {\itshape conic}.parallels}.

\href{#geoConicEqualArea}{\tt \#} d3.{\bfseries geo\+Conic\+Equal\+Area}() \href{https://github.com/d3/d3-geo/blob/master/src/projection/conicEqualArea.js}{\tt $<$$>$} ~\newline
\href{#geoConicEqualAreaRaw}{\tt \#} d3.{\bfseries geo\+Conic\+Equal\+Area\+Raw}({\itshape phi0}, {\itshape phi1}) \href{https://github.com/d3/d3-geo/blob/master/src/projection/conicEqualArea.js}{\tt $<$$>$}

\href{https://bl.ocks.org/mbostock/3734308}{\tt }

The Albers’ equal-\/area conic projection. See also \href{#conic_parallels}{\tt {\itshape conic}.parallels}.

\href{#geoConicEquidistant}{\tt \#} d3.{\bfseries geo\+Conic\+Equidistant}() \href{https://github.com/d3/d3-geo/blob/master/src/projection/conicEquidistant.js}{\tt $<$$>$} ~\newline
\href{#geoConicEquidistantRaw}{\tt \#} d3.{\bfseries geo\+Conic\+Equidistant\+Raw}({\itshape phi0}, {\itshape phi1}) \href{https://github.com/d3/d3-geo/blob/master/src/projection/conicEquidistant.js}{\tt $<$$>$}

\href{https://bl.ocks.org/mbostock/3734317}{\tt }

The conic equidistant projection. See also \href{#conic_parallels}{\tt {\itshape conic}.parallels}.

\paragraph*{Cylindrical Projections}

Cylindrical projections project the sphere onto a containing cylinder, and then unroll the cylinder onto the plane. \href{http://www.progonos.com/furuti/MapProj/Normal/ProjPCyl/projPCyl.html}{\tt Pseudocylindrical projections} are a generalization of cylindrical projections.

\href{#geoEquirectangular}{\tt \#} d3.{\bfseries geo\+Equirectangular}() \href{https://github.com/d3/d3-geo/blob/master/src/projection/equirectangular.js}{\tt $<$$>$} ~\newline
\href{#geoEquirectangularRaw}{\tt \#} d3.{\bfseries geo\+Equirectangular\+Raw}

\href{https://bl.ocks.org/mbostock/3757119}{\tt }

The equirectangular (plate carrée) projection.

\href{#geoMercator}{\tt \#} d3.{\bfseries geo\+Mercator}() \href{https://github.com/d3/d3-geo/blob/master/src/projection/mercator.js}{\tt $<$$>$} ~\newline
\href{#geoMercatorRaw}{\tt \#} d3.{\bfseries geo\+Mercator\+Raw}

\href{https://bl.ocks.org/mbostock/3757132}{\tt }

The spherical Mercator projection. Defines a default \href{#projection_clipExtent}{\tt {\itshape projection}.clip\+Extent} such that the world is projected to a square, clipped to approximately ±85° latitude.

\href{#geoTransverseMercator}{\tt \#} d3.{\bfseries geo\+Transverse\+Mercator}() \href{https://github.com/d3/d3-geo/blob/master/src/projection/transverseMercator.js}{\tt $<$$>$} ~\newline
\href{#geoTransverseMercatorRaw}{\tt \#} d3.{\bfseries geo\+Transverse\+Mercator\+Raw}

\href{https://bl.ocks.org/mbostock/4695821}{\tt }

The transverse spherical Mercator projection. Defines a default \href{#projection_clipExtent}{\tt {\itshape projection}.clip\+Extent} such that the world is projected to a square, clipped to approximately ±85° latitude.

\href{#geoNaturalEarth1}{\tt \#} d3.{\bfseries geo\+Natural\+Earth1}() \href{https://github.com/d3/d3-geo/blob/master/src/projection/naturalEarth1.js}{\tt $<$$>$} ~\newline
\href{#geoNaturalEarth1Raw}{\tt \#} d3.{\bfseries geo\+Natural\+Earth1\+Raw}

\href{https://bl.ocks.org/mbostock/4479477}{\tt }

The \href{http://www.shadedrelief.com/NE_proj/}{\tt Natural Earth projection} is a pseudocylindrical projection designed by Tom Patterson. It is neither conformal nor equal-\/area, but appealing to the eye for small-\/scale maps of the whole world.

\subsubsection*{Raw Projections}

Raw projections are point transformation functions that are used to implement custom projections; they typically passed to \href{#geoProjection}{\tt d3.\+geo\+Projection} or \href{#geoProjectionMutator}{\tt d3.\+geo\+Projection\+Mutator}. They are exposed here to facilitate the derivation of related projections. Raw projections take spherical coordinates \mbox{[}{\itshape lambda}, {\itshape phi}\mbox{]} in radians (not degrees!) and return a point \mbox{[}{\itshape x}, {\itshape y}\mbox{]}, typically in the unit square centered around the origin.

\href{#_project}{\tt \#} {\itshape project}({\itshape lambda}, {\itshape phi})

Projects the specified point \mbox{[}{\itshape lambda}, {\itshape phi}\mbox{]} in radians, returning a new point \mbox{[}{\itshape x}, {\itshape y}\mbox{]} in unitless coordinates.

\href{#project_invert}{\tt \#} {\itshape project}.{\bfseries invert}({\itshape x}, {\itshape y})

The inverse of \href{#_project}{\tt {\itshape project}}.

\href{#geoProjection}{\tt \#} d3.{\bfseries geo\+Projection}({\itshape project}) \href{https://github.com/d3/d3-geo/blob/master/src/projection/index.js#L18}{\tt $<$$>$}

Constructs a new projection from the specified \href{#_project}{\tt raw projection}, {\itshape project}. The {\itshape project} function takes the {\itshape longitude} and {\itshape latitude} of a given point in \href{http://mathworld.wolfram.com/Radian.html}{\tt radians}, often referred to as {\itshape lambda} (λ) and {\itshape phi} (φ), and returns a two-\/element array \mbox{[}{\itshape x}, {\itshape y}\mbox{]} representing its unit projection. The {\itshape project} function does not need to scale or translate the point, as these are applied automatically by \href{#projection_scale}{\tt {\itshape projection}.scale}, \href{#projection_translate}{\tt {\itshape projection}.translate}, and \href{#projection_center}{\tt {\itshape projection}.center}. Likewise, the {\itshape project} function does not need to perform any spherical rotation, as \href{#projection_rotate}{\tt {\itshape projection}.rotate} is applied prior to projection.

For example, a spherical Mercator projection can be implemented as\+:


\begin{DoxyCode}
var mercator = d3.geoProjection(function(x, y) \{
  return [x, Math.log(Math.tan(Math.PI / 4 + y / 2))];
\});
\end{DoxyCode}


If the {\itshape project} function exposes an {\itshape invert} method, the returned projection will also expose \href{#projection_invert}{\tt {\itshape projection}.invert}.

\href{#geoProjectionMutator}{\tt \#} d3.{\bfseries geo\+Projection\+Mutator}({\itshape factory}) \href{https://github.com/d3/d3-geo/blob/master/src/projection/index.js#L22}{\tt $<$$>$}

Constructs a new projection from the specified \href{#_project}{\tt raw projection} {\itshape factory} and returns a {\itshape mutate} function to call whenever the raw projection changes. The {\itshape factory} must return a raw projection. The returned {\itshape mutate} function returns the wrapped projection. For example, a conic projection typically has two configurable parallels. A suitable {\itshape factory} function, such as \href{#geoConicEqualAreaRaw}{\tt d3.\+geo\+Conic\+Equal\+Area\+Raw}, would have the form\+:


\begin{DoxyCode}
// y0 and y1 represent two parallels
function conicFactory(phi0, phi1) \{
  return function conicRaw(lambda, phi) \{
    return […, …];
  \};
\}
\end{DoxyCode}


Using d3.\+geo\+Projection\+Mutator, you can implement a standard projection that allows the parallels to be changed, reassigning the raw projection used internally by \href{#geoProjection}{\tt d3.\+geo\+Projection}\+:


\begin{DoxyCode}
function conicCustom() \{
  var phi0 = 29.5,
      phi1 = 45.5,
      mutate = d3.geoProjectionMutator(conicFactory),
      projection = mutate(phi0, phi1);

  projection.parallels = function(\_) \{
    return arguments.length ? mutate(phi0 = +\_[0], phi1 = +\_[1]) : [phi0, phi1];
  \};

  return projection;
\}
\end{DoxyCode}


When creating a mutable projection, the {\itshape mutate} function is typically not exposed.

\subsubsection*{Spherical Math}

\label{_geoArea}%
\# d3.{\bfseries geo\+Area}({\itshape object}) \href{https://github.com/d3/d3-geo/blob/master/src/area.js}{\tt $<$$>$}

Returns the spherical area of the specified Geo\+J\+S\+ON {\itshape object} in \href{http://mathworld.wolfram.com/Steradian.html}{\tt steradians}. This is the spherical equivalent of \href{#path_area}{\tt {\itshape path}.area}.

\label{_geoBounds}%
\# d3.{\bfseries geo\+Bounds}({\itshape object}) \href{https://github.com/d3/d3-geo/blob/master/src/bounds.js}{\tt $<$$>$}

Returns the \href{https://www.jasondavies.com/maps/bounds/}{\tt spherical bounding box} for the specified Geo\+J\+S\+ON {\itshape object}. The bounding box is represented by a two-\/dimensional array\+: \mbox{[}\mbox{[}{\itshape left}, {\itshape bottom}\mbox{]}, \mbox{[}{\itshape right}, {\itshape top}\mbox{]}\mbox{]}, where {\itshape left} is the minimum longitude, {\itshape bottom} is the minimum latitude, {\itshape right} is maximum longitude, and {\itshape top} is the maximum latitude. All coordinates are given in degrees. (Note that in projected planar coordinates, the minimum latitude is typically the maximum {\itshape y}-\/value, and the maximum latitude is typically the minimum {\itshape y}-\/value.) This is the spherical equivalent of \href{#path_bounds}{\tt {\itshape path}.bounds}.

\label{_geoCentroid}%
\# d3.{\bfseries geo\+Centroid}({\itshape object}) \href{https://github.com/d3/d3-geo/blob/master/src/centroid.js}{\tt $<$$>$}

Returns the spherical centroid of the specified Geo\+J\+S\+ON {\itshape object}. This is the spherical equivalent of \href{#path_centroid}{\tt {\itshape path}.centroid}.

\label{_geoDistance}%
\# d3.{\bfseries geo\+Distance}({\itshape a}, {\itshape b}) \href{https://github.com/d3/d3-geo/blob/master/src/distance.js}{\tt $<$$>$}

Returns the great-\/arc distance in \href{http://mathworld.wolfram.com/Radian.html}{\tt radians} between the two points {\itshape a} and {\itshape b}. Each point must be specified as a two-\/element array \mbox{[}{\itshape longitude}, {\itshape latitude}\mbox{]} in degrees. This is the spherical equivalent of \href{#path_measure}{\tt {\itshape path}.measure} given a Line\+String of two points.

\label{_geoLength}%
\# d3.{\bfseries geo\+Length}({\itshape object}) \href{https://github.com/d3/d3-geo/blob/master/src/length.js}{\tt $<$$>$}

Returns the great-\/arc length of the specified Geo\+J\+S\+ON {\itshape object} in \href{http://mathworld.wolfram.com/Radian.html}{\tt radians}. For polygons, returns the perimeter of the exterior ring plus that of any interior rings. This is the spherical equivalent of \href{#path_measure}{\tt {\itshape path}.measure}.

\label{_geoInterpolate}%
\# d3.{\bfseries geo\+Interpolate}({\itshape a}, {\itshape b}) \href{https://github.com/d3/d3-geo/blob/master/src/interpolate.js}{\tt $<$$>$}

Returns an interpolator function given two points {\itshape a} and {\itshape b}. Each point must be specified as a two-\/element array \mbox{[}{\itshape longitude}, {\itshape latitude}\mbox{]} in degrees. The returned interpolator function takes a single argument {\itshape t}, where {\itshape t} is a number ranging from 0 to 1; a value of 0 returns the point {\itshape a}, while a value of 1 returns the point {\itshape b}. Intermediate values interpolate from {\itshape a} to {\itshape b} along the great arc that passes through both {\itshape a} and {\itshape b}. If {\itshape a} and {\itshape b} are antipodes, an arbitrary great arc is chosen.

\label{_geoContains}%
\# d3.{\bfseries geo\+Contains}({\itshape object}, {\itshape point}) \href{https://github.com/d3/d3-geo/blob/master/src/contains.js}{\tt $<$$>$}

Returns true if and only if the specified Geo\+J\+S\+ON {\itshape object} contains the specified {\itshape point}, or false if the {\itshape object} does not contain the {\itshape point}. The point must be specified as a two-\/element array \mbox{[}{\itshape longitude}, {\itshape latitude}\mbox{]} in degrees. For Point and Multi\+Point geometries, an exact test is used; for a Sphere, true is always returned; for other geometries, an epsilon threshold is applied.

\label{_geoRotation}%
\# d3.{\bfseries geo\+Rotation}({\itshape angles}) \href{https://github.com/d3/d3-geo/blob/master/src/rotation.js}{\tt $<$$>$}

Returns a \href{#_rotation}{\tt rotation function} for the given {\itshape angles}, which must be a two-\/ or three-\/element array of numbers \mbox{[}{\itshape lambda}, {\itshape phi}, {\itshape gamma}\mbox{]} specifying the rotation angles in degrees about \href{https://bl.ocks.org/mbostock/4282586}{\tt each spherical axis}. (These correspond to \href{http://en.wikipedia.org/wiki/Aircraft_principal_axes}{\tt yaw, pitch and roll}.) If the rotation angle {\itshape gamma} is omitted, it defaults to 0. See also \href{#projection_rotate}{\tt {\itshape projection}.rotate}.

\label{__rotation}%
\# {\itshape rotation}({\itshape point}) \href{https://github.com/d3/d3-geo/blob/master/src/rotation.js#L35}{\tt $<$$>$}

Returns a new array \mbox{[}{\itshape longitude}, {\itshape latitude}\mbox{]} in degrees representing the rotated point of the given {\itshape point}. The point must be specified as a two-\/element array \mbox{[}{\itshape longitude}, {\itshape latitude}\mbox{]} in degrees.

\label{_rotation_invert}%
\# {\itshape rotation}.{\bfseries invert}({\itshape point}) \href{https://github.com/d3/d3-geo/blob/master/src/rotation.js#L47}{\tt $<$$>$}

Returns a new array \mbox{[}{\itshape longitude}, {\itshape latitude}\mbox{]} in degrees representing the point of the given rotated {\itshape point}; the inverse of \href{#_rotation}{\tt {\itshape rotation}}. The point must be specified as a two-\/element array \mbox{[}{\itshape longitude}, {\itshape latitude}\mbox{]} in degrees.

\subsubsection*{Spherical Shapes}

To generate a \href{https://en.wikipedia.org/wiki/Great-circle_distance}{\tt great arc} (a segment of a great circle), simply pass a Geo\+J\+S\+ON Line\+String geometry object to a \href{#geoPath}{\tt d3.\+geo\+Path}. D3’s projections use great-\/arc interpolation for intermediate points, so there’s no need for a great arc shape generator.

\label{_geoCircle}%
\# d3.{\bfseries geo\+Circle}() \href{https://github.com/d3/d3-geo/blob/master/src/circle.js}{\tt $<$$>$}

Returns a new circle generator.

\label{__circle}%
\# {\itshape circle}({\itshape arguments…}) \href{https://github.com/d3/d3-geo/blob/master/src/circle.js#L47}{\tt $<$$>$}

Returns a new Geo\+J\+S\+ON geometry object of type “\+Polygon” approximating a circle on the surface of a sphere, with the current \href{#circle_center}{\tt center}, \href{#circle_radius}{\tt radius} and \href{#circle_precision}{\tt precision}. Any {\itshape arguments} are passed to the accessors.

\label{_circle_center}%
\# {\itshape circle}.{\bfseries center}(\mbox{[}{\itshape center}\mbox{]}) \href{https://github.com/d3/d3-geo/blob/master/src/circle.js#L59}{\tt $<$$>$}

If {\itshape center} is specified, sets the circle center to the specified point \mbox{[}{\itshape longitude}, {\itshape latitude}\mbox{]} in degrees, and returns this circle generator. The center may also be specified as a function; this function will be invoked whenever a circle is \href{#_circle}{\tt generated}, being passed any arguments passed to the circle generator. If {\itshape center} is not specified, returns the current center accessor, which defaults to\+:


\begin{DoxyCode}
function center() \{
  return [0, 0];
\}
\end{DoxyCode}


\label{_circle_radius}%
\# {\itshape circle}.{\bfseries radius}(\mbox{[}{\itshape radius}\mbox{]}) \href{https://github.com/d3/d3-geo/blob/master/src/circle.js#L63}{\tt $<$$>$}

If {\itshape radius} is specified, sets the circle radius to the specified angle in degrees, and returns this circle generator. The radius may also be specified as a function; this function will be invoked whenever a circle is \href{#_circle}{\tt generated}, being passed any arguments passed to the circle generator. If {\itshape radius} is not specified, returns the current radius accessor, which defaults to\+:


\begin{DoxyCode}
function radius() \{
  return 90;
\}
\end{DoxyCode}


\label{_circle_precision}%
\# {\itshape circle}.{\bfseries precision}(\mbox{[}{\itshape angle}\mbox{]}) \href{https://github.com/d3/d3-geo/blob/master/src/circle.js#L67}{\tt $<$$>$}

If {\itshape precision} is specified, sets the circle precision to the specified angle in degrees, and returns this circle generator. The precision may also be specified as a function; this function will be invoked whenever a circle is \href{#_circle}{\tt generated}, being passed any arguments passed to the circle generator. If {\itshape precision} is not specified, returns the current precision accessor, which defaults to\+:


\begin{DoxyCode}
function precision() \{
  return 6;
\}
\end{DoxyCode}


Small circles do not follow great arcs and thus the generated polygon is only an approximation. Specifying a smaller precision angle improves the accuracy of the approximate polygon, but also increase the cost to generate and render it.

\label{_geoGraticule}%
\# d3.{\bfseries geo\+Graticule}() \href{https://github.com/d3/d3-geo/blob/master/src/graticule.js}{\tt $<$$>$}

Constructs a geometry generator for creating graticules\+: a uniform grid of \href{https://en.wikipedia.org/wiki/Meridian_\(geography\)}{\tt meridians} and \href{https://en.wikipedia.org/wiki/Circle_of_latitude}{\tt parallels} for showing projection distortion. The default graticule has meridians and parallels every 10° between ±80° latitude; for the polar regions, there are meridians every 90°.



\label{__graticule}%
\# {\itshape graticule}() \href{https://github.com/d3/d3-geo/blob/master/src/graticule.js#L21}{\tt $<$$>$}

Returns a Geo\+J\+S\+ON Multi\+Line\+String geometry object representing all meridians and parallels for this graticule.

\label{_graticule_lines}%
\# {\itshape graticule}.{\bfseries lines}() \href{https://github.com/d3/d3-geo/blob/master/src/graticule.js#L32}{\tt $<$$>$}

Returns an array of Geo\+J\+S\+ON Line\+String geometry objects, one for each meridian or parallel for this graticule.

\label{_graticule_outline}%
\# {\itshape graticule}.{\bfseries outline}() \href{https://github.com/d3/d3-geo/blob/master/src/graticule.js#L36}{\tt $<$$>$}

Returns a Geo\+J\+S\+ON Polygon geometry object representing the outline of this graticule, i.\+e. along the meridians and parallels defining its extent.

\label{_graticule_extent}%
\# {\itshape graticule}.{\bfseries extent}(\mbox{[}{\itshape extent}\mbox{]}) \href{https://github.com/d3/d3-geo/blob/master/src/graticule.js#L48}{\tt $<$$>$}

If {\itshape extent} is specified, sets the major and minor extents of this graticule. If {\itshape extent} is not specified, returns the current minor extent, which defaults to ⟨⟨-\/180°, -\/80° -\/ ε⟩, ⟨180°, 80° + ε⟩⟩.

\label{_graticule_extentMajor}%
\# {\itshape graticule}.{\bfseries extent\+Major}(\mbox{[}{\itshape extent}\mbox{]}) \href{https://github.com/d3/d3-geo/blob/master/src/graticule.js#L53}{\tt $<$$>$}

If {\itshape extent} is specified, sets the major extent of this graticule. If {\itshape extent} is not specified, returns the current major extent, which defaults to ⟨⟨-\/180°, -\/90° + ε⟩, ⟨180°, 90° -\/ ε⟩⟩.

\label{_graticule_extentMinor}%
\# {\itshape graticule}.{\bfseries extent\+Minor}(\mbox{[}{\itshape extent}\mbox{]}) \href{https://github.com/d3/d3-geo/blob/master/src/graticule.js#L62}{\tt $<$$>$}

If {\itshape extent} is specified, sets the minor extent of this graticule. If {\itshape extent} is not specified, returns the current minor extent, which defaults to ⟨⟨-\/180°, -\/80° -\/ ε⟩, ⟨180°, 80° + ε⟩⟩.

\label{_graticule_step}%
\# {\itshape graticule}.{\bfseries step}(\mbox{[}{\itshape step}\mbox{]}) \href{https://github.com/d3/d3-geo/blob/master/src/graticule.js#L71}{\tt $<$$>$}

If {\itshape step} is specified, sets the major and minor step for this graticule. If {\itshape step} is not specified, returns the current minor step, which defaults to ⟨10°, 10°⟩.

\label{_graticule_stepMajor}%
\# {\itshape graticule}.{\bfseries step\+Major}(\mbox{[}{\itshape step}\mbox{]}) \href{https://github.com/d3/d3-geo/blob/master/src/graticule.js#L76}{\tt $<$$>$}

If {\itshape step} is specified, sets the major step for this graticule. If {\itshape step} is not specified, returns the current major step, which defaults to ⟨90°, 360°⟩.

\label{_graticule_stepMinor}%
\# {\itshape graticule}.{\bfseries step\+Minor}(\mbox{[}{\itshape step}\mbox{]}) \href{https://github.com/d3/d3-geo/blob/master/src/graticule.js#L82}{\tt $<$$>$}

If {\itshape step} is specified, sets the minor step for this graticule. If {\itshape step} is not specified, returns the current minor step, which defaults to ⟨10°, 10°⟩.

\label{_graticule_precision}%
\# {\itshape graticule}.{\bfseries precision}(\mbox{[}{\itshape angle}\mbox{]}) \href{https://github.com/d3/d3-geo/blob/master/src/graticule.js#L88}{\tt $<$$>$}

If {\itshape precision} is specified, sets the precision for this graticule, in degrees. If {\itshape precision} is not specified, returns the current precision, which defaults to 2.\+5°.

\label{_geoGraticule10}%
\# d3.{\bfseries geo\+Graticule10}() \href{https://github.com/d3/d3-geo/blob/master/src/graticule.js#L103}{\tt $<$$>$}

A convenience method for directly generating the default 10° global graticule as a Geo\+J\+S\+ON Multi\+Line\+String geometry object. Equivalent to\+:


\begin{DoxyCode}
function geoGraticule10() \{
  return d3.geoGraticule()();
\}
\end{DoxyCode}


\subsubsection*{Streams}

D3 transforms geometry using a sequence of function calls, rather than materializing intermediate representations, to minimize overhead. Streams must implement several methods to receive input geometry. Streams are inherently stateful; the meaning of a \href{#point}{\tt point} depends on whether the point is inside of a \href{#lineStart}{\tt line}, and likewise a line is distinguished from a ring by a \href{#polygonStart}{\tt polygon}. Despite the name “stream”, these method calls are currently synchronous.

\href{#geoStream}{\tt \#} d3.{\bfseries geo\+Stream}({\itshape object}, {\itshape stream}) \href{https://github.com/d3/d3-geo/blob/master/src/stream.js}{\tt $<$$>$}

Streams the specified \href{http://geojson.org}{\tt Geo\+J\+S\+ON} {\itshape object} to the specified \href{#projection-streams}{\tt projection {\itshape stream}}. While both features and geometry objects are supported as input, the stream interface only describes the geometry, and thus additional feature properties are not visible to streams.

\label{_stream_point}%
\# {\itshape stream}.{\bfseries point}({\itshape x}, {\itshape y}\mbox{[}, {\itshape z}\mbox{]})

Indicates a point with the specified coordinates {\itshape x} and {\itshape y} (and optionally {\itshape z}). The coordinate system is unspecified and implementation-\/dependent; for example, \href{https://github.com/d3/d3-geo-projection}{\tt projection streams} require spherical coordinates in degrees as input. Outside the context of a polygon or line, a point indicates a point geometry object (\href{http://www.geojson.org/geojson-spec.html#point}{\tt Point} or \href{http://www.geojson.org/geojson-spec.html#multipoint}{\tt Multi\+Point}). Within a line or polygon ring, the point indicates a control point.

\label{_stream_lineStart}%
\# {\itshape stream}.{\bfseries line\+Start}()

Indicates the start of a line or ring. Within a polygon, indicates the start of a ring. The first ring of a polygon is the exterior ring, and is typically clockwise. Any subsequent rings indicate holes in the polygon, and are typically counterclockwise.

\label{_stream_lineEnd}%
\# {\itshape stream}.{\bfseries line\+End}()

Indicates the end of a line or ring. Within a polygon, indicates the end of a ring. Unlike Geo\+J\+S\+ON, the redundant closing coordinate of a ring is {\itshape not} indicated via \href{#point}{\tt point}, and instead is implied via line\+End within a polygon. Thus, the given polygon input\+:


\begin{DoxyCode}
\{
  "type": "Polygon",
  "coordinates": [
    [[0, 0], [0, 1], [1, 1], [1, 0], [0, 0]]
  ]
\}
\end{DoxyCode}


Will produce the following series of method calls on the stream\+:


\begin{DoxyCode}
stream.polygonStart();
stream.lineStart();
stream.point(0, 0);
stream.point(0, 1);
stream.point(1, 1);
stream.point(1, 0);
stream.lineEnd();
stream.polygonEnd();
\end{DoxyCode}


\label{_stream_polygonStart}%
\# {\itshape stream}.{\bfseries polygon\+Start}()

Indicates the start of a polygon. The first line of a polygon indicates the exterior ring, and any subsequent lines indicate interior holes.

\label{_stream_polygonEnd}%
\# {\itshape stream}.{\bfseries polygon\+End}()

Indicates the end of a polygon.

\label{_stream_sphere}%
\# {\itshape stream}.{\bfseries sphere}()

Indicates the sphere (the globe; the unit sphere centered at ⟨0,0,0⟩).

\subsubsection*{Transforms}

Transforms are a generalization of projections. Transform implement \href{#projection_stream}{\tt {\itshape projection}.stream} and can be passed to \href{#path_projection}{\tt {\itshape path}.projection}. However, they only implement a subset of the other projection methods, and represent arbitrary geometric transformations rather than projections from spherical to planar coordinates.

\href{#geoTransform}{\tt \#} d3.{\bfseries geo\+Transform}({\itshape methods}) \href{https://github.com/d3/d3-geo/blob/master/src/transform.js#L7}{\tt $<$$>$}

Defines an arbitrary transform using the methods defined on the specified {\itshape methods} object. Any undefined methods will use pass-\/through methods that propagate inputs to the output stream. For example, to reflect the {\itshape y}-\/dimension (see also \href{#identity_reflectY}{\tt {\itshape identity}.reflectY})\+:


\begin{DoxyCode}
var reflectY = d3.geoTransform(\{
  point: function(x, y) \{
    this.stream.point(x, -y);
  \}
\});
\end{DoxyCode}


Or to define an affine matrix transformation\+:


\begin{DoxyCode}
function matrix(a, b, c, d, tx, ty) \{
  return d3.geoTransform(\{
    point: function(x, y) \{
      this.stream.point(a * x + b * y + tx, c * x + d * y + ty);
    \}
  \});
\}
\end{DoxyCode}


\href{#geoIdentity}{\tt \#} d3.{\bfseries geo\+Identity}() \href{https://github.com/d3/d3-geo/blob/master/src/projection/identity.js}{\tt $<$$>$}

The identity transform can be used to scale, translate and clip planar geometry. It implements \href{#projection_scale}{\tt {\itshape projection}.scale}, \href{#projection_translate}{\tt {\itshape projection}.translate}, \href{#projection_fitExtent}{\tt {\itshape projection}.fit\+Extent}, \href{#projection_fitSize}{\tt {\itshape projection}.fit\+Size}, \href{#projection_fitWidth}{\tt {\itshape projection}.fit\+Width}, \href{#projection_fitHeight}{\tt {\itshape projection}.fit\+Height} and \href{#projection_clipExtent}{\tt {\itshape projection}.clip\+Extent}.

\href{#identity_reflectX}{\tt \#} {\itshape identity}.{\bfseries reflectX}(\mbox{[}{\itshape reflect}\mbox{]})

If {\itshape reflect} is specified, sets whether or not the {\itshape x}-\/dimension is reflected (negated) in the output. If {\itshape reflect} is not specified, returns true if {\itshape x}-\/reflection is enabled, which defaults to false.

\href{#identity_reflectY}{\tt \#} {\itshape identity}.{\bfseries reflectY}(\mbox{[}{\itshape reflect}\mbox{]})

If {\itshape reflect} is specified, sets whether or not the {\itshape y}-\/dimension is reflected (negated) in the output. If {\itshape reflect} is not specified, returns true if {\itshape y}-\/reflection is enabled, which defaults to false. This is especially useful for transforming from standard \href{https://en.wikipedia.org/wiki/Spatial_reference_system}{\tt spatial reference systems}, which treat positive {\itshape y} as pointing up, to display coordinate systems such as Canvas and S\+VG, which treat positive {\itshape y} as pointing down.

\subsubsection*{Clipping}

Projections perform cutting or clipping of geometries in two stages.

\label{_preclip}%
\# {\itshape preclip}({\itshape stream})

Pre-\/clipping occurs in geographic coordinates. Cutting along the antimeridian line, or clipping along a small circle are the most common strategies.

See \href{#projection_preclip}{\tt {\itshape projection}.preclip}.

\label{_postclip}%
\# {\itshape postclip}({\itshape stream})

Post-\/clipping occurs on the plane, when a projection is bounded to a certain extent such as a rectangle.

See \href{#projection_postclip}{\tt {\itshape projection}.postclip}.

Clipping functions are implemented as transformations of a \href{#streams}{\tt projection stream}. Pre-\/clipping operates on spherical coordinates, in radians. Post-\/clipping operates on planar coordinates, in pixels.

\label{_geoClipAntimeridian}%
\# d3.{\bfseries geo\+Clip\+Antimeridian}

A clipping function which transforms a stream such that geometries (lines or polygons) that cross the antimeridian line are cut in two, one on each side. Typically used for pre-\/clipping.

\label{_geoClipCircle}%
\# d3.{\bfseries geo\+Clip\+Circle}({\itshape angle})

Generates a clipping function which transforms a stream such that geometries are bounded by a small circle of radius {\itshape angle} around the projection’s \href{#projection_center}{\tt center}. Typically used for pre-\/clipping.

\label{_geoClipRectangle}%
\# d3.{\bfseries geo\+Clip\+Rectangle}({\itshape x0}, {\itshape y0}, {\itshape x1}, {\itshape y1})

Generates a clipping function which transforms a stream such that geometries are bounded by a rectangle of coordinates \mbox{[}\mbox{[}{\itshape x0}, {\itshape y0}\mbox{]}, \mbox{[}{\itshape x1}, {\itshape y1}\mbox{]}\mbox{]}. Typically used for post-\/clipping. 