This module provides a variety of interpolation methods for blending between two values. Values may be numbers, colors, strings, arrays, or even deeply-\/nested objects. For example\+:


\begin{DoxyCode}
var i = d3.interpolateNumber(10, 20);
i(0.0); // 10
i(0.2); // 12
i(0.5); // 15
i(1.0); // 20
\end{DoxyCode}


The returned function {\ttfamily i} is called an {\itshape interpolator}. Given a starting value {\itshape a} and an ending value {\itshape b}, it takes a parameter {\itshape t} in the domain \mbox{[}0, 1\mbox{]} and returns the corresponding interpolated value between {\itshape a} and {\itshape b}. An interpolator typically returns a value equivalent to {\itshape a} at {\itshape t} = 0 and a value equivalent to {\itshape b} at {\itshape t} = 1.

You can interpolate more than just numbers. To find the perceptual midpoint between steelblue and brown\+:


\begin{DoxyCode}
d3.interpolateLab("steelblue", "brown")(0.5); // "rgb(142, 92, 109)"
\end{DoxyCode}


Here’s a more elaborate example demonstrating type inference used by \href{#interpolate}{\tt interpolate}\+:


\begin{DoxyCode}
var i = d3.interpolate(\{colors: ["red", "blue"]\}, \{colors: ["white", "black"]\});
i(0.0); // \{colors: ["rgb(255, 0, 0)", "rgb(0, 0, 255)"]\}
i(0.5); // \{colors: ["rgb(255, 128, 128)", "rgb(0, 0, 128)"]\}
i(1.0); // \{colors: ["rgb(255, 255, 255)", "rgb(0, 0, 0)"]\}
\end{DoxyCode}


Note that the generic value interpolator detects not only nested objects and arrays, but also color strings and numbers embedded in strings!

\subsection*{Installing}

If you use N\+PM, {\ttfamily npm install d3-\/interpolate}. Otherwise, download the \href{https://github.com/d3/d3-interpolate/releases/latest}{\tt latest release}. You can also load directly from \href{https://d3js.org}{\tt d3js.\+org}, either as a \href{https://d3js.org/d3-interpolate.v1.min.js}{\tt standalone library} or as part of \href{https://github.com/d3/d3}{\tt D3 4.\+0}. A\+MD, Common\+JS, and vanilla environments are supported. In vanilla, a {\ttfamily d3} global is exported\+:


\begin{DoxyCode}
<script src="https://d3js.org/d3-color.v1.min.js"></script>
<script src="https://d3js.org/d3-interpolate.v1.min.js"></script>
<script>

var interpolate = d3.interpolateRgb("steelblue", "brown");

</script>
\end{DoxyCode}


\href{https://tonicdev.com/npm/d3-interpolate}{\tt Try d3-\/interpolate in your browser.}

\subsection*{A\+PI Reference}

\label{_interpolate}%
\# d3.{\bfseries interpolate}({\itshape a}, {\itshape b})

Returns an interpolator between the two arbitrary values {\itshape a} and {\itshape b}. The interpolator implementation is based on the type of the end value {\itshape b}, using the following algorithm\+:


\begin{DoxyEnumerate}
\item If {\itshape b} is null, undefined or a boolean, use the constant {\itshape b}.
\item If {\itshape b} is a number, use \href{#interpolateNumber}{\tt interpolate\+Number}.
\item If {\itshape b} is a \href{https://github.com/d3/d3-color#color}{\tt color} or a string coercible to a color, use \href{#interpolateRgb}{\tt interpolate\+Rgb}.
\item If {\itshape b} is a \href{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date}{\tt date}, use \href{#interpolateDate}{\tt interpolate\+Date}.
\item If {\itshape b} is a string, use \href{#interpolateString}{\tt interpolate\+String}.
\item If {\itshape b} is an \href{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/isArray}{\tt array}, use \href{#interpolateArray}{\tt interpolate\+Array}.
\item If {\itshape b} is coercible to a number, use \href{#interpolateNumber}{\tt interpolate\+Number}.
\item Use \href{#interpolateObject}{\tt interpolate\+Object}.
\end{DoxyEnumerate}

Based on the chosen interpolator, {\itshape a} is coerced to the suitable corresponding type.

\label{_interpolateNumber}%
\# d3.{\bfseries interpolate\+Number}({\itshape a}, {\itshape b}) \href{https://github.com/d3/d3-interpolate/blob/master/src/number.js}{\tt $<$$>$}

Returns an interpolator between the two numbers {\itshape a} and {\itshape b}. The returned interpolator is equivalent to\+:


\begin{DoxyCode}
function interpolator(t) \{
  return a * (1 - t) + b * t;
\}
\end{DoxyCode}


Caution\+: avoid interpolating to or from the number zero when the interpolator is used to generate a string. When very small values are stringified, they may be converted to scientific notation, which is an invalid attribute or style property value in older browsers. For example, the number {\ttfamily 0.\+0000001} is converted to the string {\ttfamily \char`\"{}1e-\/7\char`\"{}}. This is particularly noticeable with interpolating opacity. To avoid scientific notation, start or end the transition at 1e-\/6\+: the smallest value that is not stringified in scientific notation.

\label{_interpolateRound}%
\# d3.{\bfseries interpolate\+Round}({\itshape a}, {\itshape b}) \href{https://github.com/d3/d3-interpolate/blob/master/src/round.js}{\tt $<$$>$}

Returns an interpolator between the two numbers {\itshape a} and {\itshape b}; the interpolator is similar to \href{#interpolateNumber}{\tt interpolate\+Number}, except it will round the resulting value to the nearest integer.

\label{_interpolateString}%
\# d3.{\bfseries interpolate\+String}({\itshape a}, {\itshape b}) \href{https://github.com/d3/d3-interpolate/blob/master/src/string.js}{\tt $<$$>$}

Returns an interpolator between the two strings {\itshape a} and {\itshape b}. The string interpolator finds numbers embedded in {\itshape a} and {\itshape b}, where each number is of the form understood by Java\+Script. A few examples of numbers that will be detected within a string\+: {\ttfamily -\/1}, {\ttfamily 42}, {\ttfamily 3.\+14159}, and {\ttfamily 6.\+0221413e+23}.

For each number embedded in {\itshape b}, the interpolator will attempt to find a corresponding number in {\itshape a}. If a corresponding number is found, a numeric interpolator is created using \href{#interpolateNumber}{\tt interpolate\+Number}. The remaining parts of the string {\itshape b} are used as a template\+: the static parts of the string {\itshape b} remain constant for the interpolation, with the interpolated numeric values embedded in the template.

For example, if {\itshape a} is {\ttfamily \char`\"{}300 12px sans-\/serif\char`\"{}}, and {\itshape b} is {\ttfamily \char`\"{}500 36px Comic-\/\+Sans\char`\"{}}, two embedded numbers are found. The remaining static parts of the string are a space between the two numbers ({\ttfamily \char`\"{} \char`\"{}}), and the suffix ({\ttfamily \char`\"{}px Comic-\/\+Sans\char`\"{}}). The result of the interpolator at {\itshape t} = 0.\+5 is {\ttfamily \char`\"{}400 24px Comic-\/\+Sans\char`\"{}}.

\label{_interpolateDate}%
\# d3.{\bfseries interpolate\+Date}({\itshape a}, {\itshape b}) \href{https://github.com/d3/d3-interpolate/blob/master/src/date.js}{\tt $<$$>$}

Returns an interpolator between the two \href{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date}{\tt dates} {\itshape a} and {\itshape b}.

Note\+: {\bfseries no defensive copy} of the returned date is created; the same \mbox{\hyperlink{classDate}{Date}} instance is returned for every evaluation of the interpolator. No copy is made for performance reasons; interpolators are often part of the inner loop of \href{https://github.com/d3/d3-transition}{\tt animated transitions}.

\label{_interpolateArray}%
\# d3.{\bfseries interpolate\+Array}({\itshape a}, {\itshape b}) \href{https://github.com/d3/d3-interpolate/blob/master/src/array.js}{\tt $<$$>$}

Returns an interpolator between the two arrays {\itshape a} and {\itshape b}. Internally, an array template is created that is the same length in {\itshape b}. For each element in {\itshape b}, if there exists a corresponding element in {\itshape a}, a generic interpolator is created for the two elements using \href{#interpolate}{\tt interpolate}. If there is no such element, the static value from {\itshape b} is used in the template. Then, for the given parameter {\itshape t}, the template’s embedded interpolators are evaluated. The updated array template is then returned.

For example, if {\itshape a} is the array {\ttfamily \mbox{[}0, 1\mbox{]}} and {\itshape b} is the array {\ttfamily \mbox{[}1, 10, 100\mbox{]}}, then the result of the interpolator for {\itshape t} = 0.\+5 is the array {\ttfamily \mbox{[}0.\+5, 5.\+5, 100\mbox{]}}.

Note\+: {\bfseries no defensive copy} of the template array is created; modifications of the returned array may adversely affect subsequent evaluation of the interpolator. No copy is made for performance reasons; interpolators are often part of the inner loop of \href{https://github.com/d3/d3-transition}{\tt animated transitions}.

\label{_interpolateObject}%
\# d3.{\bfseries interpolate\+Object}({\itshape a}, {\itshape b}) \href{https://github.com/d3/d3-interpolate/blob/master/src/object.js}{\tt $<$$>$}

Returns an interpolator between the two objects {\itshape a} and {\itshape b}. Internally, an object template is created that has the same properties as {\itshape b}. For each property in {\itshape b}, if there exists a corresponding property in {\itshape a}, a generic interpolator is created for the two elements using \href{#interpolate}{\tt interpolate}. If there is no such property, the static value from {\itshape b} is used in the template. Then, for the given parameter {\itshape t}, the template\textquotesingle{}s embedded interpolators are evaluated and the updated object template is then returned.

For example, if {\itshape a} is the object {\ttfamily \{x\+: 0, y\+: 1\}} and {\itshape b} is the object {\ttfamily \{x\+: 1, y\+: 10, z\+: 100\}}, the result of the interpolator for {\itshape t} = 0.\+5 is the object {\ttfamily \{x\+: 0.\+5, y\+: 5.\+5, z\+: 100\}}.

Object interpolation is particularly useful for {\itshape dataspace interpolation}, where data is interpolated rather than attribute values. For example, you can interpolate an object which describes an arc in a pie chart, and then use d3.\+svg.\+arc to compute the new S\+VG path data.

Note\+: {\bfseries no defensive copy} of the template object is created; modifications of the returned object may adversely affect subsequent evaluation of the interpolator. No copy is made for performance reasons; interpolators are often part of the inner loop of \href{https://github.com/d3/d3-transition}{\tt animated transitions}.

\label{_interpolateTransformCss}%
\# d3.{\bfseries interpolate\+Transform\+Css}({\itshape a}, {\itshape b}) \href{https://github.com/d3/d3-interpolate/blob/master/src/transform/index.js#L62}{\tt $<$$>$}

Returns an interpolator between the two 2D C\+SS transforms represented by {\itshape a} and {\itshape b}. Each transform is decomposed to a standard representation of translate, rotate, {\itshape x}-\/skew and scale; these component transformations are then interpolated. This behavior is standardized by C\+SS\+: see \href{http://www.w3.org/TR/css3-2d-transforms/#matrix-decomposition}{\tt matrix decomposition for animation}.

\label{_interpolateTransformSvg}%
\# d3.{\bfseries interpolate\+Transform\+Svg}({\itshape a}, {\itshape b}) \href{https://github.com/d3/d3-interpolate/blob/master/src/transform/index.js#L63}{\tt $<$$>$}

Returns an interpolator between the two 2D S\+VG transforms represented by {\itshape a} and {\itshape b}. Each transform is decomposed to a standard representation of translate, rotate, {\itshape x}-\/skew and scale; these component transformations are then interpolated. This behavior is standardized by C\+SS\+: see \href{http://www.w3.org/TR/css3-2d-transforms/#matrix-decomposition}{\tt matrix decomposition for animation}.

\label{_interpolateZoom}%
\# d3.{\bfseries interpolate\+Zoom}({\itshape a}, {\itshape b}) \href{https://github.com/d3/d3-interpolate/blob/master/src/zoom.js}{\tt $<$$>$}

Returns an interpolator between the two views {\itshape a} and {\itshape b} of a two-\/dimensional plane, based on \href{http://www.win.tue.nl/~vanwijk/zoompan.pdf}{\tt “\+Smooth and efficient zooming and panning”} by Jarke J. van Wijk and Wim A.\+A. Nuij. Each view is defined as an array of three numbers\+: {\itshape cx}, {\itshape cy} and {\itshape width}. The first two coordinates {\itshape cx}, {\itshape cy} represent the center of the viewport; the last coordinate {\itshape width} represents the size of the viewport.

The returned interpolator exposes a {\itshape duration} property which encodes the recommended transition duration in milliseconds. This duration is based on the path length of the curved trajectory through {\itshape x,y} space. If you want to a slower or faster transition, multiply this by an arbitrary scale factor ({\itshape V} as described in the original paper).

\subsubsection*{Sampling}

\label{_quantize}%
\# d3.{\bfseries quantize}({\itshape interpolator}, {\itshape n}) \href{https://github.com/d3/d3-interpolate/blob/master/src/quantize.js}{\tt $<$$>$}

Returns {\itshape n} uniformly-\/spaced samples from the specified {\itshape interpolator}, where {\itshape n} is an integer greater than one. The first sample is always at {\itshape t} = 0, and the last sample is always at {\itshape t} = 1. This can be useful in generating a fixed number of samples from a given interpolator, such as to derive the range of a \href{https://github.com/d3/d3-scale#quantize-scales}{\tt quantize scale} from a \href{https://github.com/d3/d3-scale#interpolateWarm}{\tt continuous interpolator}.

Caution\+: this method will not work with interpolators that do not return defensive copies of their output, such as \href{#interpolateArray}{\tt d3.\+interpolate\+Array}, \href{#interpolateDate}{\tt d3.\+interpolate\+Date} and \href{#interpolateObject}{\tt d3.\+interpolate\+Object}. For those interpolators, you must wrap the interpolator and create a copy for each returned value.

\subsubsection*{Color Spaces}

\label{_interpolateRgb}%
\# d3.{\bfseries interpolate\+Rgb}({\itshape a}, {\itshape b}) \href{https://github.com/d3/d3-interpolate/blob/master/src/rgb.js}{\tt $<$$>$}



Or, with a corrected \href{#interpolate_gamma}{\tt gamma} of 2.\+2\+:



Returns an R\+GB color space interpolator between the two colors {\itshape a} and {\itshape b} with a configurable \href{#interpolate_gamma}{\tt gamma}. If the gamma is not specified, it defaults to 1.\+0. The colors {\itshape a} and {\itshape b} need not be in R\+GB; they will be converted to R\+GB using \href{https://github.com/d3/d3-color#rgb}{\tt d3.\+rgb}. The return value of the interpolator is an R\+GB string.

\href{#interpolateRgbBasis}{\tt \#} d3.{\bfseries interpolate\+Rgb\+Basis}({\itshape colors}) \href{https://github.com/d3/d3-interpolate/blob/master/src/rgb.js#L54}{\tt $<$$>$}

Returns a uniform nonrational B-\/spline interpolator through the specified array of {\itshape colors}, which are converted to \href{https://github.com/d3/d3-color#rgb}{\tt R\+GB color space}. Implicit control points are generated such that the interpolator returns {\itshape colors}\mbox{[}0\mbox{]} at {\itshape t} = 0 and {\itshape colors}\mbox{[}{\itshape colors}.length -\/ 1\mbox{]} at {\itshape t} = 1. Opacity interpolation is not currently supported. See also \href{#interpolateBasis}{\tt d3.\+interpolate\+Basis}, and see \href{https://github.com/d3/d3-scale-chromatic}{\tt d3-\/scale-\/chromatic} for examples.

\href{#interpolateRgbBasisClosed}{\tt \#} d3.{\bfseries interpolate\+Rgb\+Basis\+Closed}({\itshape colors}) \href{https://github.com/d3/d3-interpolate/blob/master/src/rgb.js#L55}{\tt $<$$>$}

Returns a uniform nonrational B-\/spline interpolator through the specified array of {\itshape colors}, which are converted to \href{https://github.com/d3/d3-color#rgb}{\tt R\+GB color space}. The control points are implicitly repeated such that the resulting spline has cyclical C² continuity when repeated around {\itshape t} in \mbox{[}0,1\mbox{]}; this is useful, for example, to create cyclical color scales. Opacity interpolation is not currently supported. See also \href{#interpolateBasisClosed}{\tt d3.\+interpolate\+Basis\+Closed}, and see \href{https://github.com/d3/d3-scale-chromatic}{\tt d3-\/scale-\/chromatic} for examples.

\label{_interpolateHsl}%
\# d3.{\bfseries interpolate\+Hsl}({\itshape a}, {\itshape b}) \href{https://github.com/d3/d3-interpolate/blob/master/src/hsl.js}{\tt $<$$>$}



Returns an H\+SL color space interpolator between the two colors {\itshape a} and {\itshape b}. The colors {\itshape a} and {\itshape b} need not be in H\+SL; they will be converted to H\+SL using \href{https://github.com/d3/d3-color#hsl}{\tt d3.\+hsl}. If either color’s hue or saturation is NaN, the opposing color’s channel value is used. The shortest path between hues is used. The return value of the interpolator is an R\+GB string.

\label{_interpolateHslLong}%
\# d3.{\bfseries interpolate\+Hsl\+Long}({\itshape a}, {\itshape b}) \href{https://github.com/d3/d3-interpolate/blob/master/src/hsl.js#L21}{\tt $<$$>$}



Like \href{#interpolateHsl}{\tt interpolate\+Hsl}, but does not use the shortest path between hues.

\label{_interpolateLab}%
\# d3.{\bfseries interpolate\+Lab}({\itshape a}, {\itshape b}) \href{https://github.com/d3/d3-interpolate/blob/master/src/lab.js}{\tt $<$$>$}



Returns a Lab color space interpolator between the two colors {\itshape a} and {\itshape b}. The colors {\itshape a} and {\itshape b} need not be in Lab; they will be converted to Lab using \href{https://github.com/d3/d3-color#lab}{\tt d3.\+lab}. The return value of the interpolator is an R\+GB string.

\label{_interpolateHcl}%
\# d3.{\bfseries interpolate\+Hcl}({\itshape a}, {\itshape b}) \href{https://github.com/d3/d3-interpolate/blob/master/src/hcl.js}{\tt $<$$>$}



Returns an H\+CL color space interpolator between the two colors {\itshape a} and {\itshape b}. The colors {\itshape a} and {\itshape b} need not be in H\+CL; they will be converted to H\+CL using \href{https://github.com/d3/d3-color#hcl}{\tt d3.\+hcl}. If either color’s hue or chroma is NaN, the opposing color’s channel value is used. The shortest path between hues is used. The return value of the interpolator is an R\+GB string.

\label{_interpolateHclLong}%
\# d3.{\bfseries interpolate\+Hcl\+Long}({\itshape a}, {\itshape b}) \href{https://github.com/d3/d3-interpolate/blob/master/src/hcl.js#L21}{\tt $<$$>$}



Like \href{#interpolateHcl}{\tt interpolate\+Hcl}, but does not use the shortest path between hues.

\label{_interpolateCubehelix}%
\# d3.{\bfseries interpolate\+Cubehelix}({\itshape a}, {\itshape b}) \href{https://github.com/d3/d3-interpolate/blob/master/src/cubehelix.js}{\tt $<$$>$}



Or, with a \href{#interpolate_gamma}{\tt gamma} of 3.\+0 to emphasize high-\/intensity values\+:



Returns a Cubehelix color space interpolator between the two colors {\itshape a} and {\itshape b} using a configurable \href{#interpolate_gamma}{\tt gamma}. If the gamma is not specified, it defaults to 1.\+0. The colors {\itshape a} and {\itshape b} need not be in Cubehelix; they will be converted to Cubehelix using \href{https://github.com/d3/d3-color#cubehelix}{\tt d3.\+cubehelix}. If either color’s hue or saturation is NaN, the opposing color’s channel value is used. The shortest path between hues is used. The return value of the interpolator is an R\+GB string.

\label{_interpolateCubehelixLong}%
\# d3.{\bfseries interpolate\+Cubehelix\+Long}({\itshape a}, {\itshape b}) \href{https://github.com/d3/d3-interpolate/blob/master/src/cubehelix.js#L29}{\tt $<$$>$}



Or, with a \href{#interpolate_gamma}{\tt gamma} of 3.\+0 to emphasize high-\/intensity values\+:



Like \href{#interpolateCubehelix}{\tt interpolate\+Cubehelix}, but does not use the shortest path between hues.

\label{_interpolate_gamma}%
\# {\itshape interpolate}.{\bfseries gamma}({\itshape gamma})

Given that {\itshape interpolate} is one of \href{#interpolateRgb}{\tt interpolate\+Rgb}, \href{#interpolateCubehelix}{\tt interpolate\+Cubehelix} or \href{#interpolateCubehelixLong}{\tt interpolate\+Cubehelix\+Long}, returns a new interpolator factory of the same type using the specified {\itshape gamma}. For example, to interpolate from purple to orange with a gamma of 2.\+2 in R\+GB space\+:


\begin{DoxyCode}
var interpolator = d3.interpolateRgb.gamma(2.2)("purple", "orange");
\end{DoxyCode}


See Eric Brasseur’s article, \href{https://web.archive.org/web/20160112115812/http://www.4p8.com/eric.brasseur/gamma.html}{\tt Gamma error in picture scaling}, for more on gamma correction.

\subsubsection*{Splines}

Whereas standard interpolators blend from a starting value {\itshape a} at {\itshape t} = 0 to an ending value {\itshape b} at {\itshape t} = 1, spline interpolators smoothly blend multiple input values for {\itshape t} in \mbox{[}0,1\mbox{]} using piecewise polynomial functions. Only cubic uniform nonrational \href{https://en.wikipedia.org/wiki/B-spline}{\tt B-\/splines} are currently supported, also known as basis splines.

\href{#interpolateBasis}{\tt \#} d3.{\bfseries interpolate\+Basis}({\itshape values}) \href{https://github.com/d3/d3-interpolate/blob/master/src/basis.js}{\tt $<$$>$}

Returns a uniform nonrational B-\/spline interpolator through the specified array of {\itshape values}, which must be numbers. Implicit control points are generated such that the interpolator returns {\itshape values}\mbox{[}0\mbox{]} at {\itshape t} = 0 and {\itshape values}\mbox{[}{\itshape values}.length -\/ 1\mbox{]} at {\itshape t} = 1. See also \href{https://github.com/d3/d3-shape#curveBasis}{\tt d3.\+curve\+Basis}.

\href{#interpolateBasisClosed}{\tt \#} d3.{\bfseries interpolate\+Basis\+Closed}({\itshape values}) \href{https://github.com/d3/d3-interpolate/blob/master/src/basisClosed.js}{\tt $<$$>$}

Returns a uniform nonrational B-\/spline interpolator through the specified array of {\itshape values}, which must be numbers. The control points are implicitly repeated such that the resulting one-\/dimensional spline has cyclical C² continuity when repeated around {\itshape t} in \mbox{[}0,1\mbox{]}. See also \href{https://github.com/d3/d3-shape#curveBasisClosed}{\tt d3.\+curve\+Basis\+Closed}. 