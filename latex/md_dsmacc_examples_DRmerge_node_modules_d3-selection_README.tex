Selections allow powerful data-\/driven transformation of the document object model (D\+OM)\+: set \href{#selection_attr}{\tt attributes}, \href{#selection_style}{\tt styles}, \href{#selection_property}{\tt properties}, \href{#selection_html}{\tt H\+T\+ML} or \href{#selection_text}{\tt text} content, and more. Using the \href{#joining-data}{\tt data join}’s \href{#selection_enter}{\tt enter} and \href{#selection_enter}{\tt exit} selections, you can also \href{#selection_append}{\tt add} or \href{#selection_remove}{\tt remove} elements to correspond to data.

Selection methods typically return the current selection, or a new selection, allowing the concise application of multiple operations on a given selection via method chaining. For example, to set the class and color style of all paragraph elements in the current document\+:


\begin{DoxyCode}
d3.selectAll("p")
    .attr("class", "graf")
    .style("color", "red");
\end{DoxyCode}


This is equivalent to\+:


\begin{DoxyCode}
var p = d3.selectAll("p");
p.attr("class", "graf");
p.style("color", "red");
\end{DoxyCode}


By convention, selection methods that return the current selection use {\itshape four} spaces of indent, while methods that return a new selection use only {\itshape two}. This helps reveal changes of context by making them stick out of the chain\+:


\begin{DoxyCode}
d3.select("body")
  .append("svg")
    .attr("width", 960)
    .attr("height", 500)
  .append("g")
    .attr("transform", "translate(20,20)")
  .append("rect")
    .attr("width", 920)
    .attr("height", 460);
\end{DoxyCode}


Selections are immutable. All selection methods that affect which elements are selected (or their order) return a new selection rather than modifying the current selection. However, note that elements are necessarily mutable, as selections drive transformations of the document!

\subsection*{Installing}

If you use N\+PM, {\ttfamily npm install d3-\/selection}. Otherwise, download the \href{https://github.com/d3/d3-selection/releases/latest}{\tt latest release}. You can also load directly from \href{https://d3js.org}{\tt d3js.\+org}, either as a \href{https://d3js.org/d3-selection.v1.min.js}{\tt standalone library} or as part of \href{https://github.com/d3/d3}{\tt D3 4.\+0}. A\+MD, Common\+JS, and vanilla environments are supported. In vanilla, a {\ttfamily d3} global is exported\+:


\begin{DoxyCode}
<script src="https://d3js.org/d3-selection.v1.min.js"></script>
<script>

var div = d3.selectAll("div");

</script>
\end{DoxyCode}


\href{https://tonicdev.com/npm/d3-selection}{\tt Try d3-\/selection in your browser.}

\subsection*{A\+PI Reference}


\begin{DoxyItemize}
\item \href{#selecting-elements}{\tt Selecting Elements}
\item \href{#modifying-elements}{\tt Modifying Elements}
\item \href{#joining-data}{\tt Joining Data}
\item \href{#handling-events}{\tt Handling Events}
\item \href{#control-flow}{\tt Control Flow}
\item \href{#local-variables}{\tt Local Variables}
\item \href{#namespaces}{\tt Namespaces}
\end{DoxyItemize}

\subsubsection*{Selecting Elements}

Selection methods accept \href{http://www.w3.org/TR/selectors-api/}{\tt W3C selector strings} such as {\ttfamily .fancy} to select elements with the class {\itshape fancy}, or {\ttfamily div} to select D\+IV elements. Selection methods come in two forms\+: select and select\+All\+: the former selects only the first matching element, while the latter selects all matching elements in document order. The top-\/level selection methods, \href{#select}{\tt d3.\+select} and \href{#selectAll}{\tt d3.\+select\+All}, query the entire document; the subselection methods, \href{#selection_select}{\tt {\itshape selection}.select} and \href{#selection_selectAll}{\tt {\itshape selection}.select\+All}, restrict selection to descendants of the selected elements.

\label{_selection}%
\# d3.{\bfseries selection}() \href{https://github.com/d3/d3-selection/blob/master/src/selection/index.js#L38}{\tt $<$$>$}

\href{#select}{\tt Selects} the root element, {\ttfamily document.\+document\+Element}. This function can also be used to test for selections ({\ttfamily instanceof d3.\+selection}) or to extend the selection prototype. For example, to add a method to check checkboxes\+:


\begin{DoxyCode}
d3.selection.prototype.checked = function(value) \{
  return arguments.length < 1
      ? this.property("checked")
      : this.property("checked", !!value);
\};
\end{DoxyCode}


And then to use\+:


\begin{DoxyCode}
d3.selectAll("input[type=checkbox]").checked(true);
\end{DoxyCode}


\label{_select}%
\# d3.{\bfseries select}({\itshape selector}) \href{https://github.com/d3/d3-selection/blob/master/src/select.js#L3}{\tt $<$$>$}

Selects the first element that matches the specified {\itshape selector} string. If no elements match the {\itshape selector}, returns an empty selection. If multiple elements match the {\itshape selector}, only the first matching element (in document order) will be selected. For example, to select the first anchor element\+:


\begin{DoxyCode}
var anchor = d3.select("a");
\end{DoxyCode}


If the {\itshape selector} is not a string, instead selects the specified node; this is useful if you already have a reference to a node, such as {\ttfamily this} within an event listener or a global such as {\ttfamily document.\+body}. For example, to make a clicked paragraph red\+:


\begin{DoxyCode}
d3.selectAll("p").on("click", function() \{
  d3.select(this).style("color", "red");
\});
\end{DoxyCode}


\label{_selectAll}%
\# d3.{\bfseries select\+All}({\itshape selector}) \href{https://github.com/d3/d3-selection/blob/master/src/selectAll.js#L3}{\tt $<$$>$}

Selects all elements that match the specified {\itshape selector} string. The elements will be selected in document order (top-\/to-\/bottom). If no elements in the document match the {\itshape selector}, or if the {\itshape selector} is null or undefined, returns an empty selection. For example, to select all paragraphs\+:


\begin{DoxyCode}
var paragraph = d3.selectAll("p");
\end{DoxyCode}


If the {\itshape selector} is not a string, instead selects the specified array of nodes; this is useful if you already have a reference to nodes, such as {\ttfamily this.\+child\+Nodes} within an event listener or a global such as {\ttfamily document.\+links}. The nodes may instead be a pseudo-\/array such as a {\ttfamily Node\+List} or {\ttfamily arguments}. For example, to color all links red\+:


\begin{DoxyCode}
d3.selectAll(document.links).style("color", "red");
\end{DoxyCode}


\label{_selection_select}%
\# {\itshape selection}.{\bfseries select}({\itshape selector}) \href{https://github.com/d3/d3-selection/blob/master/src/selection/select.js}{\tt $<$$>$}

For each selected element, selects the first descendant element that matches the specified {\itshape selector} string. If no element matches the specified selector for the current element, the element at the current index will be null in the returned selection. (If the {\itshape selector} is null, every element in the returned selection will be null, resulting in an empty selection.) If the current element has associated data, this data is propagated to the corresponding selected element. If multiple elements match the selector, only the first matching element in document order is selected. For example, to select the first bold element in every paragraph\+:


\begin{DoxyCode}
var b = d3.selectAll("p").select("b");
\end{DoxyCode}


If the {\itshape selector} is a function, it is evaluated for each selected element, in order, being passed the current datum ({\itshape d}), the current index ({\itshape i}), and the current group ({\itshape nodes}), with {\itshape this} as the current D\+OM element ({\itshape nodes}\mbox{[}{\itshape i}\mbox{]}). It must return an element, or null if there is no matching element. For example, to select the previous sibling of each paragraph\+:


\begin{DoxyCode}
var previous = d3.selectAll("p").select(function() \{
  return this.previousElementSibling;
\});
\end{DoxyCode}


Unlike \href{#selection_selectAll}{\tt {\itshape selection}.select\+All}, {\itshape selection}.select does not affect grouping\+: it preserves the existing group structure and indexes, and propagates data (if any) to selected children. Grouping plays an important role in the \href{#joining-data}{\tt data join}. See \href{http://bost.ocks.org/mike/nest/}{\tt Nested Selections} and \href{http://bost.ocks.org/mike/selection/}{\tt How Selections Work} for more on this topic.

\label{_selection_selectAll}%
\# {\itshape selection}.{\bfseries select\+All}({\itshape selector}) \href{https://github.com/d3/d3-selection/blob/master/src/selection/selectAll.js}{\tt $<$$>$}

For each selected element, selects the descendant elements that match the specified {\itshape selector} string. The elements in the returned selection are grouped by their corresponding parent node in this selection. If no element matches the specified selector for the current element, or if the {\itshape selector} is null, the group at the current index will be empty. The selected elements do not inherit data from this selection; use \href{#selection_data}{\tt {\itshape selection}.data} to propagate data to children. For example, to select the bold elements in every paragraph\+:


\begin{DoxyCode}
var b = d3.selectAll("p").selectAll("b");
\end{DoxyCode}


If the {\itshape selector} is a function, it is evaluated for each selected element, in order, being passed the current datum ({\itshape d}), the current index ({\itshape i}), and the current group ({\itshape nodes}), with {\itshape this} as the current D\+OM element ({\itshape nodes}\mbox{[}{\itshape i}\mbox{]}). It must return an array of elements (or a pseudo-\/array, such as a Node\+List), or the empty array if there are no matching elements. For example, to select the previous and next siblings of each paragraph\+:


\begin{DoxyCode}
var sibling = d3.selectAll("p").selectAll(function() \{
  return [
    this.previousElementSibling,
    this.nextElementSibling
  ];
\});
\end{DoxyCode}


Unlike \href{#selection_select}{\tt {\itshape selection}.select}, {\itshape selection}.select\+All does affect grouping\+: each selected descendant is grouped by the parent element in the originating selection. Grouping plays an important role in the \href{#joining-data}{\tt data join}. See \href{http://bost.ocks.org/mike/nest/}{\tt Nested Selections} and \href{http://bost.ocks.org/mike/selection/}{\tt How Selections Work} for more on this topic.

\label{_selection_filter}%
\# {\itshape selection}.{\bfseries filter}({\itshape filter}) \href{https://github.com/d3/d3-selection/blob/master/src/selection/filter.js}{\tt $<$$>$}

Filters the selection, returning a new selection that contains only the elements for which the specified {\itshape filter} is true. The {\itshape filter} may be specified either as a selector string or a function. If the {\itshape filter} is a function, it is evaluated for each selected element, in order, being passed the current datum ({\itshape d}), the current index ({\itshape i}), and the current group ({\itshape nodes}), with {\itshape this} as the current D\+OM element ({\itshape nodes}\mbox{[}{\itshape i}\mbox{]}).

For example, to filter a selection of table rows to contain only even rows\+:


\begin{DoxyCode}
var even = d3.selectAll("tr").filter(":nth-child(even)");
\end{DoxyCode}


This is approximately equivalent to using \href{#selectAll}{\tt d3.\+select\+All} directly, although the indexes may be different\+:


\begin{DoxyCode}
var even = d3.selectAll("tr:nth-child(even)");
\end{DoxyCode}


Similarly, using a function\+:


\begin{DoxyCode}
var even = d3.selectAll("tr").filter(function(d, i) \{ return i & 1; \});
\end{DoxyCode}


Or using \href{#selection_select}{\tt {\itshape selection}.select}\+:


\begin{DoxyCode}
var even = d3.selectAll("tr").select(function(d, i) \{ return i & 1 ? this : null; \});
\end{DoxyCode}


Note that the {\ttfamily \+:nth-\/child} pseudo-\/class is a one-\/based index rather than a zero-\/based index. Also, the above filter functions do not have precisely the same meaning as {\ttfamily \+:nth-\/child}; they rely on the selection index rather than the number of preceding sibling elements in the D\+OM.

The returned filtered selection preserves the parents of this selection, but like \href{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter}{\tt {\itshape array}.filter}, it does not preserve indexes as some elements may be removed; use \href{#selection_select}{\tt {\itshape selection}.select} to preserve the index, if needed.

\label{_selection_merge}%
\# {\itshape selection}.{\bfseries merge}({\itshape other}) \href{https://github.com/d3/d3-selection/blob/master/src/selection/merge.js}{\tt $<$$>$}

Returns a new selection merging this selection with the specified {\itshape other} selection. The returned selection has the same number of groups and the same parents as this selection. Any missing (null) elements in this selection are filled with the corresponding element, if present (not null), from the specified {\itshape selection}. (If the {\itshape other} selection has additional groups or parents, they are ignored.)

This method is commonly used to merge the \href{#selection_enter}{\tt enter} and \href{#selection_data}{\tt update} selections after a \href{#joining-data}{\tt data-\/join}. After modifying the entering and updating elements separately, you can merge the two selections and perform operations on both without duplicate code. For example\+:


\begin{DoxyCode}
var circle = svg.selectAll("circle").data(data) // UPDATE
    .style("fill", "blue");

circle.exit().remove(); // EXIT

circle = circle.enter().append("circle") // ENTER
    .style("fill", "green")
  .merge(circle) // ENTER + UPDATE
    .style("stroke", "black");
\end{DoxyCode}


See \href{#selection_data}{\tt {\itshape selection}.data} for a more complete explanation of this code, which is known as the general update pattern.

This method is not intended for concatenating arbitrary selections, however\+: if both this selection and the specified {\itshape other} selection have (non-\/null) elements at the same index, this selection’s element is returned in the merge and the {\itshape other} selection’s element is ignored.

\label{_matcher}%
\# d3.{\bfseries matcher}({\itshape selector}) \href{https://github.com/d3/d3-selection/blob/master/src/matcher.js}{\tt $<$$>$}

Given the specified {\itshape selector}, returns a function which returns true if {\ttfamily this} element \href{https://developer.mozilla.org/en-US/docs/Web/API/Element/matches}{\tt matches} the specified selector. This method is used internally by \href{#selection_filter}{\tt {\itshape selection}.filter}. For example, this\+:


\begin{DoxyCode}
var div = selection.filter("div");
\end{DoxyCode}


Is equivalent to\+:


\begin{DoxyCode}
var div = selection.filter(d3.matcher("div"));
\end{DoxyCode}


(Although D3 is not a compatibility layer, this implementation does support vendor-\/prefixed implementations due to the recent standardization of {\itshape element}.matches.)

\label{_selector}%
\# d3.{\bfseries selector}({\itshape selector}) \href{https://github.com/d3/d3-selection/blob/master/src/selector.js}{\tt $<$$>$}

Given the specified {\itshape selector}, returns a function which returns the first descendant of {\ttfamily this} element that matches the specified selector. This method is used internally by \href{#selection_select}{\tt {\itshape selection}.select}. For example, this\+:


\begin{DoxyCode}
var div = selection.select("div");
\end{DoxyCode}


Is equivalent to\+:


\begin{DoxyCode}
var div = selection.select(d3.selector("div"));
\end{DoxyCode}


\label{_selectorAll}%
\# d3.{\bfseries selector\+All}({\itshape selector}) \href{https://github.com/d3/d3-selection/blob/master/src/selectAll.js}{\tt $<$$>$}

Given the specified {\itshape selector}, returns a function which returns all descendants of {\ttfamily this} element that match the specified selector. This method is used internally by \href{#selection_selectAll}{\tt {\itshape selection}.select\+All}. For example, this\+:


\begin{DoxyCode}
var div = selection.selectAll("div");
\end{DoxyCode}


Is equivalent to\+:


\begin{DoxyCode}
var div = selection.selectAll(d3.selectorAll("div"));
\end{DoxyCode}


\label{_window}%
\# d3.{\bfseries window}({\itshape node}) \href{https://github.com/d3/d3-selection/blob/master/src/window.js}{\tt $<$$>$}

Returns the owner window for the specified {\itshape node}. If {\itshape node} is a node, returns the owner document’s default view; if {\itshape node} is a document, returns its default view; otherwise returns the {\itshape node}.

\label{_style}%
\# d3.{\bfseries style}({\itshape node}, {\itshape name}) \href{https://github.com/d3/d3-selection/blob/master/src/selection/style.js#L32}{\tt $<$$>$}

Returns the value of the style property with the specified {\itshape name} for the specified {\itshape node}. If the {\itshape node} has an inline style with the specified {\itshape name}, its value is returned; otherwise, the \href{https://developer.mozilla.org/en-US/docs/Web/CSS/computed_value}{\tt computed property value} is returned. See also \href{#selection_style}{\tt {\itshape selection}.style}.

\subsubsection*{Modifying Elements}

After selecting elements, use the selection’s transformation methods to affect document content. For example, to set the name attribute and color style of an anchor element\+:


\begin{DoxyCode}
d3.select("a")
    .attr("name", "fred")
    .style("color", "red");
\end{DoxyCode}


To experiment with selections, visit \href{https://d3js.org}{\tt d3js.\+org} and open your browser’s developer console! (In Chrome, open the console with ⌥⌘J.) Select elements and then inspect the returned selection to see which elements are selected and how they are grouped. Call selection methods and see how the page content changes.

\label{_selection_attr}%
\# {\itshape selection}.{\bfseries attr}({\itshape name}\mbox{[}, {\itshape value}\mbox{]}) \href{https://github.com/d3/d3-selection/blob/master/src/selection/attr.js}{\tt $<$$>$}

If a {\itshape value} is specified, sets the attribute with the specified {\itshape name} to the specified value on the selected elements and returns this selection. If the {\itshape value} is a constant, all elements are given the same attribute value; otherwise, if the {\itshape value} is a function, it is evaluated for each selected element, in order, being passed the current datum ({\itshape d}), the current index ({\itshape i}), and the current group ({\itshape nodes}), with {\itshape this} as the current D\+OM element ({\itshape nodes}\mbox{[}{\itshape i}\mbox{]}). The function’s return value is then used to set each element’s attribute. A null value will remove the specified attribute.

If a {\itshape value} is not specified, returns the current value of the specified attribute for the first (non-\/null) element in the selection. This is generally useful only if you know that the selection contains exactly one element.

The specified {\itshape name} may have a namespace prefix, such as {\ttfamily xlink\+:href} to specify the {\ttfamily href} attribute in the X\+Link namespace. See \href{#namespaces}{\tt namespaces} for the map of supported namespaces; additional namespaces can be registered by adding to the map.

\label{_selection_classed}%
\# {\itshape selection}.{\bfseries classed}({\itshape names}\mbox{[}, {\itshape value}\mbox{]}) \href{https://github.com/d3/d3-selection/blob/master/src/selection/classed.js}{\tt $<$$>$}

If a {\itshape value} is specified, assigns or unassigns the specified C\+SS class {\itshape names} on the selected elements by setting the {\ttfamily class} attribute or modifying the {\ttfamily class\+List} property and returns this selection. The specified {\itshape names} is a string of space-\/separated class names. For example, to assign the classes {\ttfamily foo} and {\ttfamily bar} to the selected elements\+:


\begin{DoxyCode}
selection.classed("foo bar", true);
\end{DoxyCode}


If the {\itshape value} is truthy, then all elements are assigned the specified classes; otherwise, the classes are unassigned. If the {\itshape value} is a function, it is evaluated for each selected element, in order, being passed the current datum ({\itshape d}), the current index ({\itshape i}), and the current group ({\itshape nodes}), with {\itshape this} as the current D\+OM element ({\itshape nodes}\mbox{[}{\itshape i}\mbox{]}). The function’s return value is then used to assign or unassign classes on each element. For example, to randomly associate the class {\itshape foo} with on average half the selected elements\+:


\begin{DoxyCode}
selection.classed("foo", function() \{ return Math.random() > 0.5; \});
\end{DoxyCode}


If a {\itshape value} is not specified, returns true if and only if the first (non-\/null) selected element has the specified {\itshape classes}. This is generally useful only if you know the selection contains exactly one element.

\label{_selection_style}%
\# {\itshape selection}.{\bfseries style}({\itshape name}\mbox{[}, {\itshape value}\mbox{[}, {\itshape priority}\mbox{]}\mbox{]}) \href{https://github.com/d3/d3-selection/blob/master/src/selection/style.js}{\tt $<$$>$}

If a {\itshape value} is specified, sets the style property with the specified {\itshape name} to the specified value on the selected elements and returns this selection. If the {\itshape value} is a constant, then all elements are given the same style property value; otherwise, if the {\itshape value} is a function, it is evaluated for each selected element, in order, being passed the current datum ({\itshape d}), the current index ({\itshape i}), and the current group ({\itshape nodes}), with {\itshape this} as the current D\+OM element ({\itshape nodes}\mbox{[}{\itshape i}\mbox{]}). The function’s return value is then used to set each element’s style property. A null value will remove the style property. An optional {\itshape priority} may also be specified, either as null or the string {\ttfamily important} (without the exclamation point).

If a {\itshape value} is not specified, returns the current value of the specified style property for the first (non-\/null) element in the selection. The current value is defined as the element’s inline value, if present, and otherwise its \href{https://developer.mozilla.org/en-US/docs/Web/CSS/computed_value}{\tt computed value}. Accessing the current style value is generally useful only if you know the selection contains exactly one element.

Caution\+: unlike many S\+VG attributes, C\+SS styles typically have associated units. For example, {\ttfamily 3px} is a valid stroke-\/width property value, while {\ttfamily 3} is not. Some browsers implicitly assign the {\ttfamily px} (pixel) unit to numeric values, but not all browsers do\+: IE, for example, throws an “invalid arguments” error!

\label{_selection_property}%
\# {\itshape selection}.{\bfseries property}({\itshape name}\mbox{[}, {\itshape value}\mbox{]}) \href{https://github.com/d3/d3-selection/blob/master/src/selection/property.js}{\tt $<$$>$}

Some H\+T\+ML elements have special properties that are not addressable using attributes or styles, such as a form field’s text {\ttfamily value} and a checkbox’s {\ttfamily checked} boolean. Use this method to get or set these properties.

If a {\itshape value} is specified, sets the property with the specified {\itshape name} to the specified value on selected elements. If the {\itshape value} is a constant, then all elements are given the same property value; otherwise, if the {\itshape value} is a function, it is evaluated for each selected element, in order, being passed the current datum ({\itshape d}), the current index ({\itshape i}), and the current group ({\itshape nodes}), with {\itshape this} as the current D\+OM element ({\itshape nodes}\mbox{[}{\itshape i}\mbox{]}). The function’s return value is then used to set each element’s property. A null value will delete the specified property.

If a {\itshape value} is not specified, returns the value of the specified property for the first (non-\/null) element in the selection. This is generally useful only if you know the selection contains exactly one element.

\label{_selection_text}%
\# {\itshape selection}.{\bfseries text}(\mbox{[}{\itshape value}\mbox{]}) \href{https://github.com/d3/d3-selection/blob/master/src/selection/text.js}{\tt $<$$>$}

If a {\itshape value} is specified, sets the \href{http://www.w3.org/TR/DOM-Level-3-Core/core.html#Node3-textContent}{\tt text content} to the specified value on all selected elements, replacing any existing child elements. If the {\itshape value} is a constant, then all elements are given the same text content; otherwise, if the {\itshape value} is a function, it is evaluated for each selected element, in order, being passed the current datum ({\itshape d}), the current index ({\itshape i}), and the current group ({\itshape nodes}), with {\itshape this} as the current D\+OM element ({\itshape nodes}\mbox{[}{\itshape i}\mbox{]}). The function’s return value is then used to set each element’s text content. A null value will clear the content.

If a {\itshape value} is not specified, returns the text content for the first (non-\/null) element in the selection. This is generally useful only if you know the selection contains exactly one element.

\label{_selection_html}%
\# {\itshape selection}.{\bfseries html}(\mbox{[}{\itshape value}\mbox{]}) \href{https://github.com/d3/d3-selection/blob/master/src/selection/html.js}{\tt $<$$>$}

If a {\itshape value} is specified, sets the \href{http://dev.w3.org/html5/spec-LC/apis-in-html-documents.html#innerhtml}{\tt inner H\+T\+ML} to the specified value on all selected elements, replacing any existing child elements. If the {\itshape value} is a constant, then all elements are given the same inner H\+T\+ML; otherwise, if the {\itshape value} is a function, it is evaluated for each selected element, in order, being passed the current datum ({\itshape d}), the current index ({\itshape i}), and the current group ({\itshape nodes}), with {\itshape this} as the current D\+OM element ({\itshape nodes}\mbox{[}{\itshape i}\mbox{]}). The function’s return value is then used to set each element’s inner H\+T\+ML. A null value will clear the content.

If a {\itshape value} is not specified, returns the inner H\+T\+ML for the first (non-\/null) element in the selection. This is generally useful only if you know the selection contains exactly one element.

Use \href{#selection_append}{\tt {\itshape selection}.append} or \href{#selection_insert}{\tt {\itshape selection}.insert} instead to create data-\/driven content; this method is intended for when you want a little bit of H\+T\+ML, say for rich formatting. Also, {\itshape selection}.html is only supported on H\+T\+ML elements. S\+VG elements and other non-\/\+H\+T\+ML elements do not support the inner\+H\+T\+ML property, and thus are incompatible with {\itshape selection}.html. Consider using \href{https://developer.mozilla.org/en-US/docs/XMLSerializer}{\tt X\+M\+L\+Serializer} to convert a D\+OM subtree to text. See also the \href{https://code.google.com/p/innersvg/}{\tt innersvg polyfill}, which provides a shim to support the inner\+H\+T\+ML property on S\+VG elements.

\label{_selection_append}%
\# {\itshape selection}.{\bfseries append}({\itshape type}) \href{https://github.com/d3/d3-selection/blob/master/src/selection/append.js}{\tt $<$$>$}

If the specified {\itshape type} is a string, appends a new element of this type (tag name) as the last child of each selected element, or before the next following sibling in the update selection if this is an \href{#selection_enter}{\tt enter selection}. The latter behavior for enter selections allows you to insert elements into the D\+OM in an order consistent with the new bound data; however, note that \href{#selection_order}{\tt {\itshape selection}.order} may still be required if updating elements change order ({\itshape i.\+e.}, if the order of new data is inconsistent with old data).

If the specified {\itshape type} is a function, it is evaluated for each selected element, in order, being passed the current datum ({\itshape d}), the current index ({\itshape i}), and the current group ({\itshape nodes}), with {\itshape this} as the current D\+OM element ({\itshape nodes}\mbox{[}{\itshape i}\mbox{]}). This function should return an element to be appended. (The function typically creates a new element, but it may instead return an existing element.) For example, to append a D\+IV element to each paragraph\+:


\begin{DoxyCode}
d3.selectAll("p").append("div");
\end{DoxyCode}


This is equivalent to\+:


\begin{DoxyCode}
d3.selectAll("p").append(function() \{
  return document.createElement("div");
\});
\end{DoxyCode}


Which is equivalent to\+:


\begin{DoxyCode}
d3.selectAll("p").select(function() \{
  return this.appendChild(document.createElement("div"));
\});
\end{DoxyCode}


In both cases, this method returns a new selection containing the appended elements. Each new element inherits the data of the current elements, if any, in the same manner as \href{#selection_select}{\tt {\itshape selection}.select}.

The specified {\itshape name} may have a namespace prefix, such as {\ttfamily svg\+:text} to specify a {\ttfamily text} attribute in the S\+VG namespace. See \href{#namespaces}{\tt namespaces} for the map of supported namespaces; additional namespaces can be registered by adding to the map. If no namespace is specified, the namespace will be inherited from the parent element; or, if the name is one of the known prefixes, the corresponding namespace will be used (for example, {\ttfamily svg} implies {\ttfamily svg\+:svg}).

\label{_selection_insert}%
\# {\itshape selection}.{\bfseries insert}({\itshape type}\mbox{[}, {\itshape before}\mbox{]}) \href{https://github.com/d3/d3-selection/blob/master/src/selection/insert.js}{\tt $<$$>$}

If the specified {\itshape type} is a string, inserts a new element of this type (tag name) before the first element matching the specified {\itshape before} selector for each selected element. For example, a {\itshape before} selector {\ttfamily \+:first-\/child} will prepend nodes before the first child. If {\itshape before} is not specified, it defaults to null. (To append elements in an order consistent with \href{#joining-data}{\tt bound data}, use \href{#selection_append}{\tt {\itshape selection}.append}.)

Both {\itshape type} and {\itshape before} may instead be specified as functions which are evaluated for each selected element, in order, being passed the current datum ({\itshape d}), the current index ({\itshape i}), and the current group ({\itshape nodes}), with {\itshape this} as the current D\+OM element ({\itshape nodes}\mbox{[}{\itshape i}\mbox{]}). The {\itshape type} function should return an element to be inserted; the {\itshape before} function should return the child element before which the element should be inserted. For example, to append a D\+IV element to each paragraph\+:


\begin{DoxyCode}
d3.selectAll("p").insert("div");
\end{DoxyCode}


This is equivalent to\+:


\begin{DoxyCode}
d3.selectAll("p").insert(function() \{
  return document.createElement("div");
\});
\end{DoxyCode}


Which is equivalent to\+:


\begin{DoxyCode}
d3.selectAll("p").select(function() \{
  return this.insertBefore(document.createElement("div"), null);
\});
\end{DoxyCode}


In both cases, this method returns a new selection containing the appended elements. Each new element inherits the data of the current elements, if any, in the same manner as \href{#selection_select}{\tt {\itshape selection}.select}.

The specified {\itshape name} may have a namespace prefix, such as {\ttfamily svg\+:text} to specify a {\ttfamily text} attribute in the S\+VG namespace. See \href{#namespaces}{\tt namespaces} for the map of supported namespaces; additional namespaces can be registered by adding to the map. If no namespace is specified, the namespace will be inherited from the parent element; or, if the name is one of the known prefixes, the corresponding namespace will be used (for example, {\ttfamily svg} implies {\ttfamily svg\+:svg}).

\label{_selection_remove}%
\# {\itshape selection}.{\bfseries remove}() \href{https://github.com/d3/d3-selection/blob/master/src/selection/remove.js}{\tt $<$$>$}

Removes the selected elements from the document. Returns this selection (the removed elements) which are now detached from the D\+OM. There is not currently a dedicated A\+PI to add removed elements back to the document; however, you can pass a function to \href{#selection_append}{\tt {\itshape selection}.append} or \href{#selection_insert}{\tt {\itshape selection}.insert} to re-\/add elements.

\label{_selection_clone}%
\# {\itshape selection}.{\bfseries clone}(\mbox{[}{\itshape deep}\mbox{]}) \href{https://github.com/d3/d3-selection/blob/master/src/selection/clone.js}{\tt $<$$>$}

Inserts clones the selected elements immediately following the selected elements. Equivalent to\+:


\begin{DoxyCode}
selection.select(function() \{
  return this.parentNode.insertBefore(this.cloneNode(deep), this.nextSibling);
\});
\end{DoxyCode}


\label{_selection_sort}%
\# {\itshape selection}.{\bfseries sort}({\itshape compare}) \href{https://github.com/d3/d3-selection/blob/master/src/selection/sort.js}{\tt $<$$>$}

Returns a new selection that contains a copy of each group in this selection sorted according to the {\itshape compare} function. After sorting, re-\/inserts elements to match the resulting order (per \href{#selection_order}{\tt {\itshape selection}.order}).

The compare function, which defaults to \href{https://github.com/d3/d3-array#ascending}{\tt ascending}, is passed two elements’ data {\itshape a} and {\itshape b} to compare. It should return either a negative, positive, or zero value. If negative, then {\itshape a} should be before {\itshape b}; if positive, then {\itshape a} should be after {\itshape b}; otherwise, {\itshape a} and {\itshape b} are considered equal and the order is arbitrary.

Note that sorting is not guaranteed to be stable; however, it is guaranteed to have the same behavior as your browser’s built-\/in \href{https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/sort}{\tt sort} method on arrays.

\label{_selection_order}%
\# {\itshape selection}.{\bfseries order}() \href{https://github.com/d3/d3-selection/blob/master/src/selection/order.js}{\tt $<$$>$}

Re-\/inserts elements into the document such that the document order of each group matches the selection order. This is equivalent to calling \href{#selection_sort}{\tt {\itshape selection}.sort} if the data is already sorted, but much faster.

\label{_selection_raise}%
\# {\itshape selection}.{\bfseries raise}() \href{https://github.com/d3/d3-selection/blob/master/src/selection/raise.js}{\tt $<$$>$}

Re-\/inserts each selected element, in order, as the last child of its parent. Equivalent to\+:


\begin{DoxyCode}
selection.each(function() \{
  this.parentNode.appendChild(this);
\});
\end{DoxyCode}


\label{_selection_lower}%
\# {\itshape selection}.{\bfseries lower}() \href{https://github.com/d3/d3-selection/blob/master/src/selection/lower.js}{\tt $<$$>$}

Re-\/inserts each selected element, in order, as the first child of its parent. Equivalent to\+:


\begin{DoxyCode}
selection.each(function() \{
  this.parentNode.insertBefore(this, this.parentNode.firstChild);
\});
\end{DoxyCode}


\label{_create}%
\# d3.{\bfseries create}({\itshape name}) \href{https://github.com/d3/d3-selection/blob/master/src/create.js}{\tt $<$$>$}

Given the specified element {\itshape name}, returns a single-\/element selection containing a detached element of the given name in the current document.

\label{_creator}%
\# d3.{\bfseries creator}({\itshape name}) \href{https://github.com/d3/d3-selection/blob/master/src/creator.js}{\tt $<$$>$}

Given the specified element {\itshape name}, returns a function which creates an element of the given name, assuming that {\ttfamily this} is the parent element. This method is used internally by \href{#selection_append}{\tt {\itshape selection}.append} and \href{#selection_insert}{\tt {\itshape selection}.insert} to create new elements. For example, this\+:


\begin{DoxyCode}
selection.append("div");
\end{DoxyCode}


Is equivalent to\+:


\begin{DoxyCode}
selection.append(d3.creator("div"));
\end{DoxyCode}


See \href{#namespace}{\tt namespace} for details on supported namespace prefixes, such as for S\+VG elements.

\subsubsection*{Joining Data}

For an introduction to D3’s data joins, see \href{http://bost.ocks.org/mike/join/}{\tt Thinking With Joins}. Also see the \href{http://bl.ocks.org/mbostock/3808218}{\tt General Update Pattern} examples.

\label{_selection_data}%
\# {\itshape selection}.{\bfseries data}(\mbox{[}{\itshape data}\mbox{[}, {\itshape key}\mbox{]}\mbox{]}) \href{https://github.com/d3/d3-selection/blob/master/src/selection/data.js}{\tt $<$$>$}

Joins the specified array of {\itshape data} with the selected elements, returning a new selection that represents the {\itshape update} selection\+: the elements successfully bound to data. Also defines the \href{#selection_enter}{\tt enter} and \href{#selection_exit}{\tt exit} selections on the returned selection, which can be used to add or remove elements to correspond to the new data. The specified {\itshape data} is an array of arbitrary values ({\itshape e.\+g.}, numbers or objects), or a function that returns an array of values for each group. When data is assigned to an element, it is stored in the property {\ttfamily \+\_\+\+\_\+data\+\_\+\+\_\+}, thus making the data “sticky” and available on re-\/selection.

The {\itshape data} is specified {\bfseries for each group} in the selection. If the selection has multiple groups (such as \href{#selectAll}{\tt d3.\+select\+All} followed by \href{#selection_selectAll}{\tt {\itshape selection}.select\+All}), then {\itshape data} should typically be specified as a function. This function will be evaluated for each group in order, being passed the group’s parent datum ({\itshape d}, which may be undefined), the group index ({\itshape i}), and the selection’s parent nodes ({\itshape nodes}), with {\itshape this} as the group’s parent element. For example, to create an H\+T\+ML table from a matrix of numbers\+:


\begin{DoxyCode}
var matrix = [
  [11975,  5871, 8916, 2868],
  [ 1951, 10048, 2060, 6171],
  [ 8010, 16145, 8090, 8045],
  [ 1013,   990,  940, 6907]
];

var tr = d3.select("body")
  .append("table")
  .selectAll("tr")
  .data(matrix)
  .enter().append("tr");

var td = tr.selectAll("td")
  .data(function(d) \{ return d; \})
  .enter().append("td")
    .text(function(d) \{ return d; \});
\end{DoxyCode}


In this example the {\itshape data} function is the identity function\+: for each table row, it returns the corresponding row from the data matrix.

If a {\itshape key} function is not specified, then the first datum in {\itshape data} is assigned to the first selected element, the second datum to the second selected element, and so on. A {\itshape key} function may be specified to control which datum is assigned to which element, replacing the default join-\/by-\/index, by computing a string identifier for each datum and element. This key function is evaluated for each selected element, in order, being passed the current datum ({\itshape d}), the current index ({\itshape i}), and the current group ({\itshape nodes}), with {\itshape this} as the current D\+OM element ({\itshape nodes}\mbox{[}{\itshape i}\mbox{]}); the returned string is the element’s key. The key function is then also evaluated for each new datum in {\itshape data}, being passed the current datum ({\itshape d}), the current index ({\itshape i}), and the group’s new {\itshape data}, with {\itshape this} as the group’s parent D\+OM element; the returned string is the datum’s key. The datum for a given key is assigned to the element with the matching key. If multiple elements have the same key, the duplicate elements are put into the exit selection; if multiple data have the same key, the duplicate data are put into the enter selection.

For example, given this document\+:


\begin{DoxyCode}
<div id="Ford"></div>
<div id="Jarrah"></div>
<div id="Kwon"></div>
<div id="Locke"></div>
<div id="Reyes"></div>
<div id="Shephard"></div>
\end{DoxyCode}


You could join data by key as follows\+:


\begin{DoxyCode}
var data = [
  \{name: "Locke", number: 4\},
  \{name: "Reyes", number: 8\},
  \{name: "Ford", number: 15\},
  \{name: "Jarrah", number: 16\},
  \{name: "Shephard", number: 31\},
  \{name: "Kwon", number: 34\}
];

d3.selectAll("div")
  .data(data, function(d) \{ return d ? d.name : this.id; \})
    .text(function(d) \{ return d.number; \});
\end{DoxyCode}


This example key function uses the datum {\itshape d} if present, and otherwise falls back to the element’s id property. Since these elements were not previously bound to data, the datum {\itshape d} is null when the key function is evaluated on selected elements, and non-\/null when the key function is evaluated on the new data.

The {\itshape update} and {\itshape enter} selections are returned in data order, while the {\itshape exit} selection preserves the selection order prior to the join. If a key function is specified, the order of elements in the selection may not match their order in the document; use \href{#order}{\tt {\itshape selection}.order} or \href{#sort}{\tt {\itshape selection}.sort} as needed. For more on how the key function affects the join, see \href{http://bost.ocks.org/mike/bar/2/}{\tt A Bar Chart, Part 2} and \href{http://bost.ocks.org/mike/constancy/}{\tt Object Constancy}.

Although the data-\/join can be used simply to create (to {\itshape enter}) a set of elements corresponding to data, more generally the data-\/join is designed to let you create, destroy or update elements as needed so that the resulting D\+OM corresponds to the new data. The data-\/join lets you do this efficiently by executing only the minimum necessary operations on each state of element (entering, updating, or exiting), and allows you to declare concise animated transitions between states as well. Here is a simple example of the \href{http://bl.ocks.org/mbostock/3808218}{\tt General Update Pattern}\+:


\begin{DoxyCode}
var circle = svg.selectAll("circle") // 1
  .data(data) // 2
    .style("fill", "blue"); // 3

circle.exit().remove(); // 4

circle = circle.enter().append("circle") // 5, 9
    .style("fill", "green") // 6
  .merge(circle) // 7
    .style("stroke", "black"); // 8
\end{DoxyCode}


Breaking this down into discrete steps\+:


\begin{DoxyEnumerate}
\item Any existing circles (that are descendants of the {\ttfamily svg} selection) are \href{#selection_selectAll}{\tt selected}.
\item These circles are \href{#selection_data}{\tt joined to new {\ttfamily data}}, returning the matching circles\+: the {\itshape update} selection.
\item These updating circles are given a blue fill.
\item Any existing circles that do {\itshape not} match new data—the {\itshape exit} selection—are removed.
\item New circles are \href{#selection_append}{\tt appended} for any new data that do {\itshape not} match any existing circle\+: the {\itshape enter} selection.
\item These entering circles are given a green fill.
\item A new selection representing the \href{#selection_merge}{\tt union} of entering and updating circles is created.
\item These entering and updating circles are given a black stroke.
\item These circles are stored in the variable {\ttfamily circle}.
\end{DoxyEnumerate}

As described in the preceding paragraphs, the “matching” logic is determined by the key function passed to {\itshape selection}.data; since no key function is used in the above code sample, the elements and data are joined by index.

If {\itshape data} is not specified, this method returns the array of data for the selected elements.

This method cannot be used to clear bound data; use \href{#selection_datum}{\tt {\itshape selection}.datum} instead.

\label{_selection_enter}%
\# {\itshape selection}.{\bfseries enter}() \href{https://github.com/d3/d3-selection/blob/master/src/selection/enter.js}{\tt $<$$>$}

Returns the enter selection\+: placeholder nodes for each datum that had no corresponding D\+OM element in the selection. (The enter selection is empty for selections not returned by \href{#selection_data}{\tt {\itshape selection}.data}.)

The enter selection is typically used to create “missing” elements corresponding to new data. For example, to create D\+IV elements from an array of numbers\+:


\begin{DoxyCode}
var div = d3.select("body")
  .selectAll("div")
  .data([4, 8, 15, 16, 23, 42])
  .enter().append("div")
    .text(function(d) \{ return d; \});
\end{DoxyCode}


If the body is initially empty, the above code will create six new D\+IV elements, append them to the body in-\/order, and assign their text content as the associated (string-\/coerced) number\+:


\begin{DoxyCode}
<div>4</div>
<div>8</div>
<div>15</div>
<div>16</div>
<div>23</div>
<div>42</div>
\end{DoxyCode}


Conceptually, the enter selection’s placeholders are pointers to the parent element (in this example, the document body). The enter selection is typically only used transiently to append elements, and is often \href{#selection_merge}{\tt merged} with the update selection after appending, such that modifications can be applied to both entering and updating elements.

\label{_selection_exit}%
\# {\itshape selection}.{\bfseries exit}() \href{https://github.com/d3/d3-selection/blob/master/src/selection/exit.js}{\tt $<$$>$}

Returns the exit selection\+: existing D\+OM elements in the selection for which no new datum was found. (The exit selection is empty for selections not returned by \href{#selection_data}{\tt {\itshape selection}.data}.)

The exit selection is typically used to remove “superfluous” elements corresponding to old data. For example, to update the D\+IV elements created previously with a new array of numbers\+:


\begin{DoxyCode}
div = div.data([1, 2, 4, 8, 16, 32], function(d) \{ return d; \});
\end{DoxyCode}


Since a key function was specified (as the identity function), and the new data contains the numbers \mbox{[}4, 8, 16\mbox{]} which match existing elements in the document, the update selection contains three D\+IV elements. Leaving those elements as-\/is, we can append new elements for \mbox{[}1, 2, 32\mbox{]} using the enter selection\+:


\begin{DoxyCode}
div.enter().append("div").text(function(d) \{ return d; \});
\end{DoxyCode}


Likewise, to remove the exiting elements \mbox{[}15, 23, 42\mbox{]}\+:


\begin{DoxyCode}
div.exit().remove();
\end{DoxyCode}


Now the document body looks like this\+:


\begin{DoxyCode}
<div>1</div>
<div>2</div>
<div>4</div>
<div>8</div>
<div>16</div>
<div>32</div>
\end{DoxyCode}


The order of the D\+OM elements matches the order of the data because the old data’s order and the new data’s order were consistent. If the new data’s order is different, use \href{#selection_order}{\tt {\itshape selection}.order} to reorder the elements in the D\+OM. See the \href{http://bl.ocks.org/mbostock/3808218}{\tt General Update Pattern} example thread for more on data joins.

\label{_selection_datum}%
\# {\itshape selection}.{\bfseries datum}(\mbox{[}{\itshape value}\mbox{]}) \href{https://github.com/d3/d3-selection/blob/master/src/selection/datum.js}{\tt $<$$>$}

Gets or sets the bound data for each selected element. Unlike \href{#selection_data}{\tt {\itshape selection}.data}, this method does not compute a join and does not affect indexes or the enter and exit selections.

If a {\itshape value} is specified, sets the element’s bound data to the specified value on all selected elements. If the {\itshape value} is a constant, all elements are given the same datum; otherwise, if the {\itshape value} is a function, it is evaluated for each selected element, in order, being passed the current datum ({\itshape d}), the current index ({\itshape i}), and the current group ({\itshape nodes}), with {\itshape this} as the current D\+OM element ({\itshape nodes}\mbox{[}{\itshape i}\mbox{]}). The function is then used to set each element’s new data. A null value will delete the bound data.

If a {\itshape value} is not specified, returns the bound datum for the first (non-\/null) element in the selection. This is generally useful only if you know the selection contains exactly one element.

This method is useful for accessing H\+T\+M\+L5 \href{http://www.w3.org/TR/html5/dom.html#custom-data-attribute}{\tt custom data attributes}. For example, given the following elements\+:


\begin{DoxyCode}
<ul id="list">
  <li data-username="shawnbot">Shawn Allen</li>
  <li data-username="mbostock">Mike Bostock</li>
</ul>
\end{DoxyCode}


You can expose the custom data attributes by setting each element’s data as the built-\/in \href{http://www.w3.org/TR/html5/dom.html#dom-dataset}{\tt dataset} property\+:


\begin{DoxyCode}
selection.datum(function() \{ return this.dataset; \})
\end{DoxyCode}


\subsubsection*{Handling Events}

For interaction, selections allow listening for and dispatching of events.

\label{_selection_on}%
\# {\itshape selection}.{\bfseries on}({\itshape typenames}\mbox{[}, {\itshape listener}\mbox{[}, {\itshape capture}\mbox{]}\mbox{]}) \href{https://github.com/d3/d3-selection/blob/master/src/selection/on.js}{\tt $<$$>$}

Adds or removes a {\itshape listener} to each selected element for the specified event {\itshape typenames}. The {\itshape typenames} is a string event type, such as {\ttfamily click}, {\ttfamily mouseover}, or {\ttfamily submit}; any \href{https://developer.mozilla.org/en-US/docs/Web/Events#Standard_events}{\tt D\+OM event type} supported by your browser may be used. The type may be optionally followed by a period ({\ttfamily .}) and a name; the optional name allows multiple callbacks to be registered to receive events of the same type, such as {\ttfamily click.\+foo} and {\ttfamily click.\+bar}. To specify multiple typenames, separate typenames with spaces, such as {\ttfamily input change} or {\ttfamily click.\+foo click.\+bar}.

When a specified event is dispatched on a selected element, the specified {\itshape listener} will be evaluated for the element, being passed the current datum ({\itshape d}), the current index ({\itshape i}), and the current group ({\itshape nodes}), with {\itshape this} as the current D\+OM element ({\itshape nodes}\mbox{[}{\itshape i}\mbox{]}). Listeners always see the latest datum for their element, but the index is a property of the selection and is fixed when the listener is assigned; to update the index, re-\/assign the listener. To access the current event within a listener, use \href{#event}{\tt d3.\+event}.

If an event listener was previously registered for the same {\itshape typename} on a selected element, the old listener is removed before the new listener is added. To remove a listener, pass null as the {\itshape listener}. To remove all listeners for a given name, pass null as the {\itshape listener} and {\ttfamily .foo} as the {\itshape typename}, where {\ttfamily foo} is the name; to remove all listeners with no name, specify {\ttfamily .} as the {\itshape typename}.

An optional {\itshape capture} flag may be specified which corresponds to the W3C \href{http://www.w3.org/TR/DOM-Level-2-Events/events.html#Events-registration}{\tt use\+Capture flag}\+: “\+After initiating capture, all events of the specified type will be dispatched to the registered Event\+Listener before being dispatched to any Event\+Targets beneath them in the tree. Events which are bubbling upward through the tree will not trigger an Event\+Listener designated to use capture.\+”

If a {\itshape listener} is not specified, returns the currently-\/assigned listener for the specified event {\itshape typename} on the first (non-\/null) selected element, if any. If multiple typenames are specified, the first matching listener is returned.

\label{_selection_dispatch}%
\# {\itshape selection}.{\bfseries dispatch}({\itshape type}\mbox{[}, {\itshape parameters}\mbox{]}) \href{https://github.com/d3/d3-selection/blob/master/src/selection/dispatch.js}{\tt $<$$>$}

Dispatches a \href{http://www.w3.org/TR/dom/#interface-customevent}{\tt custom event} of the specified {\itshape type} to each selected element, in order. An optional {\itshape parameters} map may be specified to set additional properties of the event. It may contain the following fields\+:


\begin{DoxyItemize}
\item \href{https://www.w3.org/TR/dom/#dom-event-bubbles}{\tt {\ttfamily bubbles}} -\/ if true, the event is dispatched to ancestors in reverse tree order.
\item \href{https://www.w3.org/TR/dom/#dom-event-cancelable}{\tt {\ttfamily cancelable}} -\/ if true, {\itshape event}.prevent\+Default is allowed.
\item \href{https://www.w3.org/TR/dom/#dom-customevent-detail}{\tt {\ttfamily detail}} -\/ any custom data associated with the event.
\end{DoxyItemize}

If {\itshape parameters} is a function, it is evaluated for each selected element, in order, being passed the current datum ({\itshape d}), the current index ({\itshape i}), and the current group ({\itshape nodes}), with {\itshape this} as the current D\+OM element ({\itshape nodes}\mbox{[}{\itshape i}\mbox{]}). It must return the parameters map for the current element.

\label{_event}%
\# d3.{\bfseries event}

The current \href{https://developer.mozilla.org/en-US/docs/DOM/event}{\tt event}, if any. This is set during the invocation of an event listener, and is reset after the listener terminates. Use this to access standard event fields such as \href{https://www.w3.org/TR/dom/#dom-event-timestamp}{\tt {\itshape event}.time\+Stamp} and methods such as \href{https://www.w3.org/TR/dom/#dom-event-preventdefault}{\tt {\itshape event}.prevent\+Default}. While you can use the native \href{https://developer.mozilla.org/en/DOM/event.pageX}{\tt {\itshape event}.pageX} and \href{https://developer.mozilla.org/en/DOM/event.pageY}{\tt {\itshape event}.pageY}, it is often more convenient to transform the event position to the local coordinate system of the container that received the event using \href{#mouse}{\tt d3.\+mouse}, \href{#touch}{\tt d3.\+touch} or \href{#touches}{\tt d3.\+touches}.

If you use Babel, Webpack, or another E\+S6-\/to-\/\+E\+S5 bundler, be aware that the value of d3.\+event changes during an event! An import of d3.\+event must be a \href{http://www.2ality.com/2015/07/es6-module-exports.html}{\tt live binding}, so you may need to configure the bundler to import from D3’s E\+S6 modules rather than from the generated U\+MD bundle; not all bundlers observe \href{https://github.com/rollup/rollup/wiki/jsnext:main}{\tt jsnext\+:main}. Also beware of conflicts with the \href{https://developer.mozilla.org/en-US/docs/Web/API/Window/event}{\tt {\itshape window}.event} global.

\label{_customEvent}%
\# d3.{\bfseries custom\+Event}({\itshape event}, {\itshape listener}\mbox{[}, {\itshape that}\mbox{[}, {\itshape arguments}\mbox{]}\mbox{]}) \href{https://github.com/d3/d3-selection/blob/master/src/selection/on.js#L98}{\tt $<$$>$}

Invokes the specified {\itshape listener}, using the specified {\itshape that} {\ttfamily this} context and passing the specified {\itshape arguments}, if any. During the invocation, \href{#event}{\tt d3.\+event} is set to the specified {\itshape event}; after the listener returns (or throws an error), d3.\+event is restored to its previous value. In addition, sets {\itshape event}.source\+Event to the prior value of d3.\+event, allowing custom events to retain a reference to the originating native event. Returns the value returned by the {\itshape listener}.

\label{_mouse}%
\# d3.{\bfseries mouse}({\itshape container}) \href{https://github.com/d3/d3-selection/blob/master/src/mouse.js}{\tt $<$$>$}

Returns the {\itshape x} and {\itshape y} coordinates of the \href{#event}{\tt current event} relative to the specified {\itshape container}. The container may be an H\+T\+ML or S\+VG container element, such as a \href{http://www.w3.org/TR/SVG/struct.html#Groups}{\tt G element} or an \href{http://www.w3.org/TR/SVG/struct.html#SVGElement}{\tt S\+VG element}. The coordinates are returned as a two-\/element array of numbers \mbox{[}{\itshape x}, {\itshape y}\mbox{]}.

\label{_touch}%
\# d3.{\bfseries touch}({\itshape container}\mbox{[}, {\itshape touches}\mbox{]}, {\itshape identifier}) \href{https://github.com/d3/d3-selection/blob/master/src/touch.js}{\tt $<$$>$}

Returns the {\itshape x} and {\itshape y} coordinates of the touch with the specified {\itshape identifier} associated with the \href{#event}{\tt current event} relative to the specified {\itshape container}. The container may be an H\+T\+ML or S\+VG container element, such as a \href{http://www.w3.org/TR/SVG/struct.html#Groups}{\tt G element} or an \href{http://www.w3.org/TR/SVG/struct.html#SVGElement}{\tt S\+VG element}. The coordinates are returned as a two-\/element array of numbers \mbox{[}{\itshape x}, {\itshape y}\mbox{]}. If there is no touch with the specified identifier in {\itshape touches}, returns null; this can be useful for ignoring touchmove events where the only some touches have moved. If {\itshape touches} is not specified, it defaults to the current event’s \href{http://developer.apple.com/library/safari/documentation/UserExperience/Reference/TouchEventClassReference/TouchEvent/TouchEvent.html#//apple_ref/javascript/instp/TouchEvent/changedTouches}{\tt changed\+Touches} property.

\label{_touches}%
\# d3.{\bfseries touches}({\itshape container}\mbox{[}, {\itshape touches}\mbox{]}) \href{https://github.com/d3/d3-selection/blob/master/src/touches.js}{\tt $<$$>$}

Returns the {\itshape x} and {\itshape y} coordinates of the touches associated with the \href{#event}{\tt current event} relative to the specified {\itshape container}. The container may be an H\+T\+ML or S\+VG container element, such as a \href{http://www.w3.org/TR/SVG/struct.html#Groups}{\tt G element} or an \href{http://www.w3.org/TR/SVG/struct.html#SVGElement}{\tt S\+VG element}. The coordinates are returned as an array of two-\/element arrays of numbers \mbox{[}\mbox{[}{\itshape x1}, {\itshape y1}\mbox{]}, \mbox{[}{\itshape x2}, {\itshape y2}\mbox{]}, …\mbox{]}. If {\itshape touches} is not specified, it defaults to the current event’s \href{http://developer.apple.com/library/safari/documentation/UserExperience/Reference/TouchEventClassReference/TouchEvent/TouchEvent.html#//apple_ref/javascript/instp/TouchEvent/touches}{\tt touches} property.

\label{_clientPoint}%
\# d3.{\bfseries client\+Point}({\itshape container}, {\itshape event}) \href{https://github.com/d3/d3-selection/blob/master/src/point.js}{\tt $<$$>$}

Returns the {\itshape x} and {\itshape y} coordinates of the specified {\itshape event} relative to the specified {\itshape container}. (The {\itshape event} may also be a \href{https://www.w3.org/TR/touch-events/#touch-interface}{\tt touch}.) The container may be an H\+T\+ML or S\+VG container element, such as a \href{http://www.w3.org/TR/SVG/struct.html#Groups}{\tt G element} or an \href{http://www.w3.org/TR/SVG/struct.html#SVGElement}{\tt S\+VG element}. The coordinates are returned as a two-\/element array of numbers \mbox{[}{\itshape x}, {\itshape y}\mbox{]}.

\subsubsection*{Control Flow}

For advanced usage, selections provide methods for custom control flow.

\label{_selection_each}%
\# {\itshape selection}.{\bfseries each}({\itshape function}) \href{https://github.com/d3/d3-selection/blob/master/src/selection/each.js}{\tt $<$$>$}

Invokes the specified {\itshape function} for each selected element, in order, being passed the current datum ({\itshape d}), the current index ({\itshape i}), and the current group ({\itshape nodes}), with {\itshape this} as the current D\+OM element ({\itshape nodes}\mbox{[}{\itshape i}\mbox{]}). This method can be used to invoke arbitrary code for each selected element, and is useful for creating a context to access parent and child data simultaneously, such as\+:


\begin{DoxyCode}
parent.each(function(p, j) \{
  d3.select(this)
    .selectAll(".child")
      .text(function(d, i) \{ return "child " + d.name + " of " + p.name; \});
\});
\end{DoxyCode}


See \href{http://bl.ocks.org/mbostock/4c5fad723c87d2fd8273}{\tt Sized Donut Multiples} for an example.

\label{_selection_call}%
\# {\itshape selection}.{\bfseries call}({\itshape function}\mbox{[}, {\itshape arguments…}\mbox{]}) \href{https://github.com/d3/d3-selection/blob/master/src/selection/call.js}{\tt $<$$>$}

Invokes the specified {\itshape function} exactly once, passing in this selection along with any optional {\itshape arguments}. Returns this selection. This is equivalent to invoking the function by hand but facilitates method chaining. For example, to set several styles in a reusable function\+:


\begin{DoxyCode}
function name(selection, first, last) \{
  selection
      .attr("first-name", first)
      .attr("last-name", last);
\}
\end{DoxyCode}


Now say\+:


\begin{DoxyCode}
d3.selectAll("div").call(name, "John", "Snow");
\end{DoxyCode}


This is roughly equivalent to\+:


\begin{DoxyCode}
name(d3.selectAll("div"), "John", "Snow");
\end{DoxyCode}


The only difference is that {\itshape selection}.call always returns the {\itshape selection} and not the return value of the called {\itshape function}, {\ttfamily name}.

\label{_selection_empty}%
\# {\itshape selection}.{\bfseries empty}() \href{https://github.com/d3/d3-selection/blob/master/src/selection/empty.js}{\tt $<$$>$}

Returns true if this selection contains no (non-\/null) elements.

\label{_selection_nodes}%
\# {\itshape selection}.{\bfseries nodes}() \href{https://github.com/d3/d3-selection/blob/master/src/selection/nodes.js}{\tt $<$$>$}

Returns an array of all (non-\/null) elements in this selection.

\label{_selection_node}%
\# {\itshape selection}.{\bfseries node}() \href{https://github.com/d3/d3-selection/blob/master/src/selection/node.js}{\tt $<$$>$}

Returns the first (non-\/null) element in this selection. If the selection is empty, returns null.

\label{_selection_size}%
\# {\itshape selection}.{\bfseries size}() \href{https://github.com/d3/d3-selection/blob/master/src/selection/size.js}{\tt $<$$>$}

Returns the total number of elements in this selection.

\subsubsection*{Local Variables}

D3 locals allow you to define local state independent of data. For instance, when rendering \href{http://bl.ocks.org/mbostock/e1192fe405703d8321a5187350910e08}{\tt small multiples} of time-\/series data, you might want the same {\itshape x}-\/scale for all charts but distinct {\itshape y}-\/scales to compare the relative performance of each metric. D3 locals are scoped by D\+OM elements\+: on set, the value is stored on the given element; on get, the value is retrieved from given element or the nearest ancestor that defines it.

\label{_local}%
\# d3.{\bfseries local}() \href{https://github.com/d3/d3-selection/blob/master/src/local.js}{\tt $<$$>$}

Declares a new local variable. For example\+:


\begin{DoxyCode}
var foo = d3.local();
\end{DoxyCode}


Like {\ttfamily var}, each local is a distinct symbolic reference; unlike {\ttfamily var}, the value of each local is also scoped by the D\+OM.

\label{_local_set}%
\# {\itshape local}.{\bfseries set}({\itshape node}, {\itshape value}) \href{https://github.com/d3/d3-selection/blob/master/src/local.js#L18}{\tt $<$$>$}

Sets the value of this local on the specified {\itshape node} to the {\itshape value}, and returns the specified {\itshape value}. This is often performed using \href{#selection_each}{\tt {\itshape selection}.each}\+:


\begin{DoxyCode}
selection.each(function(d) \{ foo.set(this, d.value); \});
\end{DoxyCode}


If you are just setting a single variable, consider using \href{#selection_property}{\tt {\itshape selection}.property}\+:


\begin{DoxyCode}
selection.property(foo, function(d) \{ return d.value; \});
\end{DoxyCode}


\label{_local_get}%
\# {\itshape local}.{\bfseries get}({\itshape node}) \href{https://github.com/d3/d3-selection/blob/master/src/local.js#L13}{\tt $<$$>$}

Returns the value of this local on the specified {\itshape node}. If the {\itshape node} does not define this local, returns the value from the nearest ancestor that defines it. Returns undefined if no ancestor defines this local.

\label{_local_remove}%
\# {\itshape local}.{\bfseries remove}({\itshape node}) \href{https://github.com/d3/d3-selection/blob/master/src/local.js#L21}{\tt $<$$>$}

Deletes this local’s value from the specified {\itshape node}. Returns true if the {\itshape node} defined this local prior to removal, and false otherwise. If ancestors also define this local, those definitions are unaffected, and thus \href{#local_get}{\tt {\itshape local}.get} will still return the inherited value.

\label{_local_toString}%
\# {\itshape local}.{\bfseries to\+String}() \href{https://github.com/d3/d3-selection/blob/master/src/local.js#L24}{\tt $<$$>$}

Returns the automatically-\/generated identifier for this local. This is the name of the property that is used to store the local’s value on elements, and thus you can also set or get the local’s value using {\itshape element}\mbox{[}{\itshape local}\mbox{]} or by using \href{#selection_property}{\tt {\itshape selection}.property}.

\subsubsection*{Namespaces}

X\+ML namespaces are fun! Right? Fortunately you can mostly ignore them.

\label{_namespace}%
\# d3.{\bfseries namespace}({\itshape name}) \href{https://github.com/d3/d3-selection/blob/master/src/namespace.js}{\tt $<$$>$}

Qualifies the specified {\itshape name}, which may or may not have a namespace prefix. If the name contains a colon ({\ttfamily \+:}), the substring before the colon is interpreted as the namespace prefix, which must be registered in \href{#namespaces}{\tt d3.\+namespaces}. Returns an object {\ttfamily space} and {\ttfamily local} attributes describing the full namespace U\+RL and the local name. For example\+:


\begin{DoxyCode}
d3.namespace("svg:text"); // \{space: "http://www.w3.org/2000/svg", local: "text"\}
\end{DoxyCode}


If the name does not contain a colon, this function merely returns the input name.

\label{_namespaces}%
\# d3.{\bfseries namespaces} \href{https://github.com/d3/d3-selection/blob/master/src/namespaces.js}{\tt $<$$>$}

The map of registered namespace prefixes. The initial value is\+:


\begin{DoxyCode}
\{
  svg: "http://www.w3.org/2000/svg",
  xhtml: "http://www.w3.org/1999/xhtml",
  xlink: "http://www.w3.org/1999/xlink",
  xml: "http://www.w3.org/XML/1998/namespace",
  xmlns: "http://www.w3.org/2000/xmlns/"
\}
\end{DoxyCode}


Additional prefixes may be assigned as needed to create elements or attributes in other namespaces. 