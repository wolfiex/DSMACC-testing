\href{https://travis-ci.org/ljharb/qs}{\tt } \href{https://david-dm.org/ljharb/qs}{\tt } \href{https://david-dm.org/ljharb/qs?type=dev}{\tt } \mbox{[}\mbox{]}\mbox{[}license-\/url\mbox{]} \href{http://npm-stat.com/charts.html?package=qs}{\tt }

\href{https://npmjs.org/package/qs}{\tt }

A querystring parsing and stringifying library with some added security.

Lead Maintainer\+: \href{https://github.com/ljharb}{\tt Jordan Harband}

The {\bfseries qs} module was originally created and maintained by \href{https://github.com/visionmedia/node-querystring}{\tt TJ Holowaychuk}.

\subsection*{Usage}


\begin{DoxyCode}
var qs = require('qs');
var assert = require('assert');

var obj = qs.parse('a=c');
assert.deepEqual(obj, \{ a: 'c' \});

var str = qs.stringify(obj);
assert.equal(str, 'a=c');
\end{DoxyCode}


\subsubsection*{Parsing Objects}

\mbox{[}\mbox{]}(\#prevent\+Eval) 
\begin{DoxyCode}
qs.parse(string, [options]);
\end{DoxyCode}


{\bfseries qs} allows you to create nested objects within your query strings, by surrounding the name of sub-\/keys with square brackets {\ttfamily \mbox{[}\mbox{]}}. For example, the string `\textquotesingle{}foo\mbox{[}bar\mbox{]}=baz'\`{} converts to\+:


\begin{DoxyCode}
assert.deepEqual(qs.parse('foo[bar]=baz'), \{
    foo: \{
        bar: 'baz'
    \}
\});
\end{DoxyCode}


When using the {\ttfamily plain\+Objects} option the parsed value is returned as a null object, created via {\ttfamily Object.\+create(null)} and as such you should be aware that prototype methods will not exist on it and a user may set those names to whatever value they like\+:


\begin{DoxyCode}
var nullObject = qs.parse('a[hasOwnProperty]=b', \{ plainObjects: true \});
assert.deepEqual(nullObject, \{ a: \{ hasOwnProperty: 'b' \} \});
\end{DoxyCode}


By default parameters that would overwrite properties on the object prototype are ignored, if you wish to keep the data from those fields either use {\ttfamily plain\+Objects} as mentioned above, or set {\ttfamily allow\+Prototypes} to {\ttfamily true} which will allow user input to overwrite those properties. {\itshape W\+A\+R\+N\+I\+NG} It is generally a bad idea to enable this option as it can cause problems when attempting to use the properties that have been overwritten. Always be careful with this option.


\begin{DoxyCode}
var protoObject = qs.parse('a[hasOwnProperty]=b', \{ allowPrototypes: true \});
assert.deepEqual(protoObject, \{ a: \{ hasOwnProperty: 'b' \} \});
\end{DoxyCode}


U\+RI encoded strings work too\+:


\begin{DoxyCode}
assert.deepEqual(qs.parse('a%5Bb%5D=c'), \{
    a: \{ b: 'c' \}
\});
\end{DoxyCode}


You can also nest your objects, like `\textquotesingle{}foo\mbox{[}bar\mbox{]}\mbox{[}baz\mbox{]}=foobarbaz'\`{}\+:


\begin{DoxyCode}
assert.deepEqual(qs.parse('foo[bar][baz]=foobarbaz'), \{
    foo: \{
        bar: \{
            baz: 'foobarbaz'
        \}
    \}
\});
\end{DoxyCode}


By default, when nesting objects {\bfseries qs} will only parse up to 5 children deep. This means if you attempt to parse a string like `\textquotesingle{}a\mbox{[}b\mbox{]}\mbox{[}c\mbox{]}\mbox{[}d\mbox{]}\mbox{[}e\mbox{]}\mbox{[}f\mbox{]}\mbox{[}g\mbox{]}\mbox{[}h\mbox{]}\mbox{[}i\mbox{]}=j'\`{} your resulting object will be\+:


\begin{DoxyCode}
var expected = \{
    a: \{
        b: \{
            c: \{
                d: \{
                    e: \{
                        f: \{
                            '[g][h][i]': 'j'
                        \}
                    \}
                \}
            \}
        \}
    \}
\};
var string = 'a[b][c][d][e][f][g][h][i]=j';
assert.deepEqual(qs.parse(string), expected);
\end{DoxyCode}


This depth can be overridden by passing a {\ttfamily depth} option to {\ttfamily qs.\+parse(string, \mbox{[}options\mbox{]})}\+:


\begin{DoxyCode}
var deep = qs.parse('a[b][c][d][e][f][g][h][i]=j', \{ depth: 1 \});
assert.deepEqual(deep, \{ a: \{ b: \{ '[c][d][e][f][g][h][i]': 'j' \} \} \});
\end{DoxyCode}


The depth limit helps mitigate abuse when {\bfseries qs} is used to parse user input, and it is recommended to keep it a reasonably small number.

For similar reasons, by default {\bfseries qs} will only parse up to 1000 parameters. This can be overridden by passing a {\ttfamily parameter\+Limit} option\+:


\begin{DoxyCode}
var limited = qs.parse('a=b&c=d', \{ parameterLimit: 1 \});
assert.deepEqual(limited, \{ a: 'b' \});
\end{DoxyCode}


To bypass the leading question mark, use {\ttfamily ignore\+Query\+Prefix}\+:


\begin{DoxyCode}
var prefixed = qs.parse('?a=b&c=d', \{ ignoreQueryPrefix: true \});
assert.deepEqual(prefixed, \{ a: 'b', c: 'd' \});
\end{DoxyCode}


An optional delimiter can also be passed\+:


\begin{DoxyCode}
var delimited = qs.parse('a=b;c=d', \{ delimiter: ';' \});
assert.deepEqual(delimited, \{ a: 'b', c: 'd' \});
\end{DoxyCode}


Delimiters can be a regular expression too\+:


\begin{DoxyCode}
var regexed = qs.parse('a=b;c=d,e=f', \{ delimiter: /[;,]/ \});
assert.deepEqual(regexed, \{ a: 'b', c: 'd', e: 'f' \});
\end{DoxyCode}


\mbox{\hyperlink{structOption}{Option}} {\ttfamily allow\+Dots} can be used to enable dot notation\+:


\begin{DoxyCode}
var withDots = qs.parse('a.b=c', \{ allowDots: true \});
assert.deepEqual(withDots, \{ a: \{ b: 'c' \} \});
\end{DoxyCode}


\subsubsection*{Parsing Arrays}

{\bfseries qs} can also parse arrays using a similar {\ttfamily \mbox{[}\mbox{]}} notation\+:


\begin{DoxyCode}
var withArray = qs.parse('a[]=b&a[]=c');
assert.deepEqual(withArray, \{ a: ['b', 'c'] \});
\end{DoxyCode}


You may specify an index as well\+:


\begin{DoxyCode}
var withIndexes = qs.parse('a[1]=c&a[0]=b');
assert.deepEqual(withIndexes, \{ a: ['b', 'c'] \});
\end{DoxyCode}


Note that the only difference between an index in an array and a key in an object is that the value between the brackets must be a number to create an array. When creating arrays with specific indices, {\bfseries qs} will compact a sparse array to only the existing values preserving their order\+:


\begin{DoxyCode}
var noSparse = qs.parse('a[1]=b&a[15]=c');
assert.deepEqual(noSparse, \{ a: ['b', 'c'] \});
\end{DoxyCode}


Note that an empty string is also a value, and will be preserved\+:


\begin{DoxyCode}
var withEmptyString = qs.parse('a[]=&a[]=b');
assert.deepEqual(withEmptyString, \{ a: ['', 'b'] \});

var withIndexedEmptyString = qs.parse('a[0]=b&a[1]=&a[2]=c');
assert.deepEqual(withIndexedEmptyString, \{ a: ['b', '', 'c'] \});
\end{DoxyCode}


{\bfseries qs} will also limit specifying indices in an array to a maximum index of {\ttfamily 20}. Any array members with an index of greater than {\ttfamily 20} will instead be converted to an object with the index as the key\+:


\begin{DoxyCode}
var withMaxIndex = qs.parse('a[100]=b');
assert.deepEqual(withMaxIndex, \{ a: \{ '100': 'b' \} \});
\end{DoxyCode}


This limit can be overridden by passing an {\ttfamily array\+Limit} option\+:


\begin{DoxyCode}
var withArrayLimit = qs.parse('a[1]=b', \{ arrayLimit: 0 \});
assert.deepEqual(withArrayLimit, \{ a: \{ '1': 'b' \} \});
\end{DoxyCode}


To disable array parsing entirely, set {\ttfamily parse\+Arrays} to {\ttfamily false}.


\begin{DoxyCode}
var noParsingArrays = qs.parse('a[]=b', \{ parseArrays: false \});
assert.deepEqual(noParsingArrays, \{ a: \{ '0': 'b' \} \});
\end{DoxyCode}


If you mix notations, {\bfseries qs} will merge the two items into an object\+:


\begin{DoxyCode}
var mixedNotation = qs.parse('a[0]=b&a[b]=c');
assert.deepEqual(mixedNotation, \{ a: \{ '0': 'b', b: 'c' \} \});
\end{DoxyCode}


You can also create arrays of objects\+:


\begin{DoxyCode}
var arraysOfObjects = qs.parse('a[][b]=c');
assert.deepEqual(arraysOfObjects, \{ a: [\{ b: 'c' \}] \});
\end{DoxyCode}


\subsubsection*{Stringifying}

\mbox{[}\mbox{]}(\#prevent\+Eval) 
\begin{DoxyCode}
qs.stringify(object, [options]);
\end{DoxyCode}


When stringifying, {\bfseries qs} by default U\+RI encodes output. Objects are stringified as you would expect\+:


\begin{DoxyCode}
assert.equal(qs.stringify(\{ a: 'b' \}), 'a=b');
assert.equal(qs.stringify(\{ a: \{ b: 'c' \} \}), 'a%5Bb%5D=c');
\end{DoxyCode}


This encoding can be disabled by setting the {\ttfamily encode} option to {\ttfamily false}\+:


\begin{DoxyCode}
var unencoded = qs.stringify(\{ a: \{ b: 'c' \} \}, \{ encode: false \});
assert.equal(unencoded, 'a[b]=c');
\end{DoxyCode}


Encoding can be disabled for keys by setting the {\ttfamily encode\+Values\+Only} option to {\ttfamily true}\+: 
\begin{DoxyCode}
var encodedValues = qs.stringify(
    \{ a: 'b', c: ['d', 'e=f'], f: [['g'], ['h']] \},
    \{ encodeValuesOnly: true \}
);
assert.equal(encodedValues,'a=b&c[0]=d&c[1]=e%3Df&f[0][0]=g&f[1][0]=h');
\end{DoxyCode}


This encoding can also be replaced by a custom encoding method set as {\ttfamily encoder} option\+:

\`{}\`{}`javascript var encoded = qs.\+stringify(\{ a\+: \{ b\+: \textquotesingle{}c' \} \}, \{ encoder\+: function (str) \{ // Passed in values {\ttfamily a}, {\ttfamily b}, {\ttfamily c} return // Return encoded string \}\}) \`{}\`{}\`{}

\+\_\+(Note\+: the {\ttfamily encoder} option does not apply if {\ttfamily encode} is {\ttfamily false})\+\_\+

Analogue to the {\ttfamily encoder} there is a {\ttfamily decoder} option for {\ttfamily parse} to override decoding of properties and values\+:

\`{}\`{}`javascript var decoded = qs.\+parse(\textquotesingle{}x=z', \{ decoder\+: function (str) \{ // Passed in values {\ttfamily x}, {\ttfamily z} return // Return decoded string \}\}) 
\begin{DoxyCode}
Examples beyond this point will be shown as though the output is not URI encoded for clarity. Please note
       that the return values in these cases *will* be URI encoded during real usage.

When arrays are stringified, by default they are given explicit indices:

```javascript
qs.stringify(\{ a: ['b', 'c', 'd'] \});
// 'a[0]=b&a[1]=c&a[2]=d'
\end{DoxyCode}


You may override this by setting the {\ttfamily indices} option to {\ttfamily false}\+:


\begin{DoxyCode}
qs.stringify(\{ a: ['b', 'c', 'd'] \}, \{ indices: false \});
// 'a=b&a=c&a=d'
\end{DoxyCode}


You may use the {\ttfamily array\+Format} option to specify the format of the output array\+:


\begin{DoxyCode}
qs.stringify(\{ a: ['b', 'c'] \}, \{ arrayFormat: 'indices' \})
// 'a[0]=b&a[1]=c'
qs.stringify(\{ a: ['b', 'c'] \}, \{ arrayFormat: 'brackets' \})
// 'a[]=b&a[]=c'
qs.stringify(\{ a: ['b', 'c'] \}, \{ arrayFormat: 'repeat' \})
// 'a=b&a=c'
\end{DoxyCode}


When objects are stringified, by default they use bracket notation\+:


\begin{DoxyCode}
qs.stringify(\{ a: \{ b: \{ c: 'd', e: 'f' \} \} \});
// 'a[b][c]=d&a[b][e]=f'
\end{DoxyCode}


You may override this to use dot notation by setting the {\ttfamily allow\+Dots} option to {\ttfamily true}\+:


\begin{DoxyCode}
qs.stringify(\{ a: \{ b: \{ c: 'd', e: 'f' \} \} \}, \{ allowDots: true \});
// 'a.b.c=d&a.b.e=f'
\end{DoxyCode}


Empty strings and null values will omit the value, but the equals sign (=) remains in place\+:


\begin{DoxyCode}
assert.equal(qs.stringify(\{ a: '' \}), 'a=');
\end{DoxyCode}


Key with no values (such as an empty object or array) will return nothing\+:


\begin{DoxyCode}
assert.equal(qs.stringify(\{ a: [] \}), '');
assert.equal(qs.stringify(\{ a: \{\} \}), '');
assert.equal(qs.stringify(\{ a: [\{\}] \}), '');
assert.equal(qs.stringify(\{ a: \{ b: []\} \}), '');
assert.equal(qs.stringify(\{ a: \{ b: \{\}\} \}), '');
\end{DoxyCode}


Properties that are set to {\ttfamily undefined} will be omitted entirely\+:


\begin{DoxyCode}
assert.equal(qs.stringify(\{ a: null, b: undefined \}), 'a=');
\end{DoxyCode}


The query string may optionally be prepended with a question mark\+:


\begin{DoxyCode}
assert.equal(qs.stringify(\{ a: 'b', c: 'd' \}, \{ addQueryPrefix: true \}), '?a=b&c=d');
\end{DoxyCode}


The delimiter may be overridden with stringify as well\+:


\begin{DoxyCode}
assert.equal(qs.stringify(\{ a: 'b', c: 'd' \}, \{ delimiter: ';' \}), 'a=b;c=d');
\end{DoxyCode}


If you only want to override the serialization of {\ttfamily \mbox{\hyperlink{classDate}{Date}}} objects, you can provide a {\ttfamily serialize\+Date} option\+:


\begin{DoxyCode}
var date = new Date(7);
assert.equal(qs.stringify(\{ a: date \}), 'a=1970-01-01T00:00:00.007Z'.replace(/:/g, '%3A'));
assert.equal(
    qs.stringify(\{ a: date \}, \{ serializeDate: function (d) \{ return d.getTime(); \} \}),
    'a=7'
);
\end{DoxyCode}


You may use the {\ttfamily sort} option to affect the order of parameter keys\+:


\begin{DoxyCode}
function alphabeticalSort(a, b) \{
    return a.localeCompare(b);
\}
assert.equal(qs.stringify(\{ a: 'c', z: 'y', b : 'f' \}, \{ sort: alphabeticalSort \}), 'a=c&b=f&z=y');
\end{DoxyCode}


Finally, you can use the {\ttfamily filter} option to restrict which keys will be included in the stringified output. If you pass a function, it will be called for each key to obtain the replacement value. Otherwise, if you pass an array, it will be used to select properties and array indices for stringification\+:


\begin{DoxyCode}
function filterFunc(prefix, value) \{
    if (prefix == 'b') \{
        // Return an `undefined` value to omit a property.
        return;
    \}
    if (prefix == 'e[f]') \{
        return value.getTime();
    \}
    if (prefix == 'e[g][0]') \{
        return value * 2;
    \}
    return value;
\}
qs.stringify(\{ a: 'b', c: 'd', e: \{ f: new Date(123), g: [2] \} \}, \{ filter: filterFunc \});
// 'a=b&c=d&e[f]=123&e[g][0]=4'
qs.stringify(\{ a: 'b', c: 'd', e: 'f' \}, \{ filter: ['a', 'e'] \});
// 'a=b&e=f'
qs.stringify(\{ a: ['b', 'c', 'd'], e: 'f' \}, \{ filter: ['a', 0, 2] \});
// 'a[0]=b&a[2]=d'
\end{DoxyCode}


\subsubsection*{Handling of {\ttfamily null} values}

By default, {\ttfamily null} values are treated like empty strings\+:


\begin{DoxyCode}
var withNull = qs.stringify(\{ a: null, b: '' \});
assert.equal(withNull, 'a=&b=');
\end{DoxyCode}


Parsing does not distinguish between parameters with and without equal signs. Both are converted to empty strings.


\begin{DoxyCode}
var equalsInsensitive = qs.parse('a&b=');
assert.deepEqual(equalsInsensitive, \{ a: '', b: '' \});
\end{DoxyCode}


To distinguish between {\ttfamily null} values and empty strings use the {\ttfamily strict\+Null\+Handling} flag. In the result string the {\ttfamily null} values have no {\ttfamily =} sign\+:


\begin{DoxyCode}
var strictNull = qs.stringify(\{ a: null, b: '' \}, \{ strictNullHandling: true \});
assert.equal(strictNull, 'a&b=');
\end{DoxyCode}


To parse values without {\ttfamily =} back to {\ttfamily null} use the {\ttfamily strict\+Null\+Handling} flag\+:


\begin{DoxyCode}
var parsedStrictNull = qs.parse('a&b=', \{ strictNullHandling: true \});
assert.deepEqual(parsedStrictNull, \{ a: null, b: '' \});
\end{DoxyCode}


To completely skip rendering keys with {\ttfamily null} values, use the {\ttfamily skip\+Nulls} flag\+:


\begin{DoxyCode}
var nullsSkipped = qs.stringify(\{ a: 'b', c: null\}, \{ skipNulls: true \});
assert.equal(nullsSkipped, 'a=b');
\end{DoxyCode}


\subsubsection*{Dealing with special character sets}

By default the encoding and decoding of characters is done in {\ttfamily utf-\/8}. If you wish to encode querystrings to a different character set (i.\+e. \href{https://en.wikipedia.org/wiki/Shift_JIS}{\tt Shift J\+IS}) you can use the \href{https://github.com/martinheidegger/qs-iconv}{\tt {\ttfamily qs-\/iconv}} library\+:


\begin{DoxyCode}
var encoder = require('qs-iconv/encoder')('shift\_jis');
var shiftJISEncoded = qs.stringify(\{ a: 'こんにちは！' \}, \{ encoder: encoder \});
assert.equal(shiftJISEncoded, 'a=%82%B1%82%F1%82%C9%82%BF%82%CD%81I');
\end{DoxyCode}


This also works for decoding of query strings\+:


\begin{DoxyCode}
var decoder = require('qs-iconv/decoder')('shift\_jis');
var obj = qs.parse('a=%82%B1%82%F1%82%C9%82%BF%82%CD%81I', \{ decoder: decoder \});
assert.deepEqual(obj, \{ a: 'こんにちは！' \});
\end{DoxyCode}


\subsubsection*{R\+FC 3986 and R\+FC 1738 space encoding}

R\+F\+C3986 used as default option and encodes \textquotesingle{} \textquotesingle{} to {\itshape \%20} which is backward compatible. In the same time, output can be stringified as per R\+F\+C1738 with \textquotesingle{} \textquotesingle{} equal to \textquotesingle{}+\textquotesingle{}.


\begin{DoxyCode}
assert.equal(qs.stringify(\{ a: 'b c' \}), 'a=b%20c');
assert.equal(qs.stringify(\{ a: 'b c' \}, \{ format : 'RFC3986' \}), 'a=b%20c');
assert.equal(qs.stringify(\{ a: 'b c' \}, \{ format : 'RFC1738' \}), 'a=b+c');
\end{DoxyCode}
 