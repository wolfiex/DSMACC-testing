streaming J\+S\+O\+N.\+parse and stringify



\#\# install 
\begin{DoxyCode}
## example

``` js

var request = require('request')
  , JSONStream = require('JSONStream')
  , es = require('event-stream')

request(\{url: 'http://isaacs.couchone.com/registry/\_all\_docs'\})
  .pipe(JSONStream.parse('rows.*'))
  .pipe(es.mapSync(function (data) \{
    console.error(data)
    return data
  \}))
\end{DoxyCode}


\subsection*{J\+S\+O\+N\+Stream.\+parse(path)}

parse stream of values that match a path


\begin{DoxyCode}
JSONStream.parse('rows.*.doc')
\end{DoxyCode}


The {\ttfamily ..} operator is the recursive descent operator from \href{http://goessner.net/articles/JsonPath/}{\tt J\+S\+O\+N\+Path}, which will match a child at any depth (see examples below).

If your keys have keys that include {\ttfamily .} or {\ttfamily $\ast$} etc, use an array instead. `\mbox{[}\textquotesingle{}row', true, /$^\wedge$doc/\mbox{]}\`{}.

If you use an array, {\ttfamily Reg\+Exp}s, booleans, and/or functions. The {\ttfamily ..} operator is also available in array representation, using {\ttfamily \{recurse\+: true\}}. any object that matches the path will be emitted as \textquotesingle{}data\textquotesingle{} (and {\ttfamily pipe}d down stream)

If {\ttfamily path} is empty or null, no \textquotesingle{}data\textquotesingle{} events are emitted.

If you want to have keys emitted, you can prefix your {\ttfamily $\ast$} operator with {\ttfamily \$}\+: {\ttfamily obj.\$$\ast$} -\/ in this case the data passed to the stream is an object with a {\ttfamily key} holding the key and a {\ttfamily value} property holding the data.

\subsubsection*{Examples}

query a couchdb view\+:


\begin{DoxyCode}
curl -sS localhost:5984/tests/\_all\_docs&include\_docs=true
\end{DoxyCode}
 you will get something like this\+:


\begin{DoxyCode}
\{"total\_rows":129,"offset":0,"rows":[
  \{ "id":"change1\_0.6995461115147918"
  , "key":"change1\_0.6995461115147918"
  , "value":\{"rev":"1-e240bae28c7bb3667f02760f6398d508"\}
  , "doc":\{
      "\_id":  "change1\_0.6995461115147918"
    , "\_rev": "1-e240bae28c7bb3667f02760f6398d508","hello":1\}
  \},
  \{ "id":"change2\_0.6995461115147918"
  , "key":"change2\_0.6995461115147918"
  , "value":\{"rev":"1-13677d36b98c0c075145bb8975105153"\}
  , "doc":\{
      "\_id":"change2\_0.6995461115147918"
    , "\_rev":"1-13677d36b98c0c075145bb8975105153"
    , "hello":2
    \}
  \},
]\}
\end{DoxyCode}


we are probably most interested in the {\ttfamily rows.$\ast$.doc}

create a {\ttfamily Stream} that parses the documents from the feed like this\+:


\begin{DoxyCode}
var stream = JSONStream.parse(['rows', true, 'doc']) //rows, ANYTHING, doc

stream.on('data', function(data) \{
  console.log('received:', data);
\});
//emits anything from \_before\_ the first match
stream.on('header', function (data) \{
  console.log('header:', data) // => \{"total\_rows":129,"offset":0\}
\})
\end{DoxyCode}
 awesome!

In case you wanted the contents the doc emitted\+:


\begin{DoxyCode}
var stream = JSONStream.parse(['rows', true, 'doc', \{emitKey: true\}]) //rows, ANYTHING, doc, items in docs
       with keys

stream.on('data', function(data) \{
  console.log('key:', data.key);
  console.log('value:', data.value);
\});
\end{DoxyCode}


You can also emit the path\+:


\begin{DoxyCode}
var stream = JSONStream.parse(['rows', true, 'doc', \{emitPath: true\}]) //rows, ANYTHING, doc, items in docs
       with keys

stream.on('data', function(data) \{
  console.log('path:', data.path);
  console.log('value:', data.value);
\});
\end{DoxyCode}


\subsubsection*{recursive patterns (..)}

`J\+S\+O\+N\+Stream.\+parse(\textquotesingle{}docs..value'){\ttfamily  (or}J\+S\+O\+N\+Stream.\+parse(\mbox{[}\textquotesingle{}docs\textquotesingle{}, \{recurse\+: true\}, \textquotesingle{}value\textquotesingle{}\mbox{]}){\ttfamily using an array) will emit every}value{\ttfamily object that is a child, grand-\/child, etc. of the }docs\`{} object. In this example, it will match exactly 5 times at various depth levels, emitting 0, 1, 2, 3 and 4 as results.


\begin{DoxyCode}
\{
  "total": 5,
  "docs": [
    \{
      "key": \{
        "value": 0,
        "some": "property"
      \}
    \},
    \{"value": 1\},
    \{"value": 2\},
    \{"blbl": [\{\}, \{"a":0, "b":1, "value":3\}, 10]\},
    \{"value": 4\}
  ]
\}
\end{DoxyCode}


\subsection*{J\+S\+O\+N\+Stream.\+parse(pattern, map)}

provide a function that can be used to map or filter the json output. {\ttfamily map} is passed the value at that node of the pattern, if {\ttfamily map} return non-\/nullish (anything but {\ttfamily null} or {\ttfamily undefined}) that value will be emitted in the stream. If it returns a nullish value, nothing will be emitted.

{\ttfamily J\+S\+O\+N\+Stream} also emits `\textquotesingle{}header'{\ttfamily and}\textquotesingle{}footer\textquotesingle{}{\ttfamily events, the}\textquotesingle{}header\textquotesingle{}{\ttfamily event contains anything in the output that was before the first match, and the}\textquotesingle{}footer\textquotesingle{}\`{}, is anything after the last match.

\subsection*{J\+S\+O\+N\+Stream.\+stringify(open, sep, close)}

Create a writable stream.

you may pass in custom {\ttfamily open}, {\ttfamily close}, and {\ttfamily seperator} strings. But, by default, {\ttfamily J\+S\+O\+N\+Stream.\+stringify()} will create an array, (with default options `open='\mbox{[}~\newline
\textquotesingle{}, sep=\textquotesingle{}~\newline
,~\newline
\textquotesingle{}, close=\textquotesingle{}~\newline
\mbox{]}~\newline
\textquotesingle{}\`{})

If you call {\ttfamily J\+S\+O\+N\+Stream.\+stringify(false)} the elements will only be seperated by a newline.

If you only write one item this will be valid J\+S\+ON.

If you write many items, you can use a {\ttfamily Reg\+Exp} to split it into valid chunks.

\subsection*{J\+S\+O\+N\+Stream.\+stringify\+Object(open, sep, close)}

Very much like {\ttfamily J\+S\+O\+N\+Stream.\+stringify}, but creates a writable stream for objects instead of arrays.

Accordingly, `open='\{~\newline
\textquotesingle{}, sep=\textquotesingle{}~\newline
,~\newline
\textquotesingle{}, close=\textquotesingle{}~\newline
\}~\newline
\textquotesingle{}\`{}.

When you {\ttfamily .write()} to the stream you must supply an array with {\ttfamily \mbox{[} key, data \mbox{]}} as the first argument.

\subsection*{unix tool}

query npm to see all the modules that browserify has ever depended on.


\begin{DoxyCode}
curl https://registry.npmjs.org/browserify | JSONStream 'versions.*.dependencies'
\end{DoxyCode}


\subsection*{numbers}

numbers will be emitted as numbers. huge numbers that cannot be represented in memory as javascript numbers will be emitted as strings. cf \href{https://github.com/creationix/jsonparse/commit/044b268f01c4b8f97fb936fc85d3bcfba179e5bb}{\tt https\+://github.\+com/creationix/jsonparse/commit/044b268f01c4b8f97fb936fc85d3bcfba179e5bb} for details.

\subsection*{Acknowlegements}

this module depends on \href{https://github.com/creationix/jsonparse}{\tt https\+://github.\+com/creationix/jsonparse} by Tim Caswell and also thanks to Florent Jaby for teaching me about parsing with\+: \href{https://github.com/Floby/node-json-streams}{\tt https\+://github.\+com/\+Floby/node-\/json-\/streams}

\subsection*{license}

Dual-\/licensed under the M\+IT License or the Apache License, version 2.\+0 