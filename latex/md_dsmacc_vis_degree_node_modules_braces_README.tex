{\bfseries More about brace expansion} (click to expand)

\begin{quote}
Bash-\/like brace expansion, implemented in Java\+Script. Safer than other brace expansion libs, with complete support for the Bash 4.\+3 braces specification, without sacrificing speed. \end{quote}


Please consider following this project\textquotesingle{}s author, \href{https://github.com/jonschlinkert}{\tt Jon Schlinkert}, and consider starring the project to show your \+:heart\+: and support.

\subsection*{Install}

Install with \href{https://www.npmjs.com/}{\tt npm}\+:


\begin{DoxyCode}
$ npm install --save braces
\end{DoxyCode}


\subsection*{Why use braces?}

Brace patterns are great for matching ranges. Users (and implementors) shouldn\textquotesingle{}t have to think about whether or not they will break their application (or yours) from accidentally defining an aggressive brace pattern. {\itshape Braces is the only library that offers a \href{#performance}{\tt solution to this problem}}.


\begin{DoxyItemize}
\item {\bfseries Safe(r)}\+: Braces isn\textquotesingle{}t vulnerable to DoS attacks like \href{https://github.com/juliangruber/brace-expansion}{\tt brace-\/expansion}, \href{https://github.com/isaacs/minimatch}{\tt minimatch} and \href{https://github.com/sindresorhus/multimatch}{\tt multimatch} (a different bug than the \href{https://medium.com/node-security/minimatch-redos-vulnerability-590da24e6d3c#.jew0b6mpc}{\tt other regex DoS bug}).
\item {\bfseries Accurate}\+: complete support for the \href{www.gnu.org/software/bash/}{\tt Bash 4.\+3 Brace Expansion} specification (passes all of the Bash braces tests)
\item {\bfseries \href{#benchmarks}{\tt fast and performant}}\+: Starts fast, runs fast and \href{#performance}{\tt scales well} as patterns increase in complexity.
\item {\bfseries Organized code base}\+: with parser and compiler that are eas(y$\vert$ier) to maintain and update when edge cases crop up.
\item {\bfseries Well-\/tested}\+: thousands of test assertions. Passes 100\% of the \href{https://github.com/isaacs/minimatch}{\tt minimatch} and \href{https://github.com/juliangruber/brace-expansion}{\tt brace-\/expansion} unit tests as well (as of the writing of this).
\end{DoxyItemize}

\subsection*{Usage}

The main export is a function that takes one or more brace {\ttfamily patterns} and {\ttfamily options}.


\begin{DoxyCode}
var braces = require('braces');
braces(pattern[, options]);
\end{DoxyCode}


By default, braces returns an optimized regex-\/source string. To get an array of brace patterns, use {\ttfamily brace.\+expand()}.

The following section explains the difference in more detail. \+\_\+(If you\textquotesingle{}re curious about \char`\"{}why\char`\"{} braces does this by default, see \href{#brace-matching-pitfalls}{\tt brace matching pitfalls}\+\_\+.

\subsubsection*{Optimized vs. expanded braces}

{\bfseries Optimized}

By default, patterns are optimized for regex and matching\+:


\begin{DoxyCode}
console.log(braces('a/\{x,y,z\}/b'));
//=> ['a/(x|y|z)/b']
\end{DoxyCode}


{\bfseries Expanded}

To expand patterns the same way as Bash or \href{https://github.com/isaacs/minimatch}{\tt minimatch}, use the \href{#expand}{\tt .expand} method\+:


\begin{DoxyCode}
console.log(braces.expand('a/\{x,y,z\}/b'));
//=> ['a/x/b', 'a/y/b', 'a/z/b']
\end{DoxyCode}


Or use \href{#optionsexpand}{\tt options.\+expand}\+:


\begin{DoxyCode}
console.log(braces('a/\{x,y,z\}/b', \{expand: true\}));
//=> ['a/x/b', 'a/y/b', 'a/z/b']
\end{DoxyCode}


\subsection*{Features}


\begin{DoxyItemize}
\item \href{#lists}{\tt lists}\+: Supports \char`\"{}lists\char`\"{}\+: {\ttfamily a/\{b,c\}/d} =$>$ `\mbox{[}\textquotesingle{}a/b/d', \textquotesingle{}a/c/d\textquotesingle{}\mbox{]}{\ttfamily }
\item {\ttfamily \mbox{[}sequences\mbox{]}(\#sequences)\+: Supports alphabetical or numerical \char`\"{}sequences\char`\"{} (ranges)\+:}\{1..3\}{\ttfamily =$>$}\mbox{[}\textquotesingle{}1\textquotesingle{}, \textquotesingle{}2\textquotesingle{}, \textquotesingle{}3\textquotesingle{}\mbox{]}{\ttfamily }
\item {\ttfamily \mbox{[}steps\mbox{]}(\#steps)\+: Supports \char`\"{}steps\char`\"{} or increments\+:}\{2..10..2\}{\ttfamily =$>$}\mbox{[}\textquotesingle{}2\textquotesingle{}, \textquotesingle{}4\textquotesingle{}, \textquotesingle{}6\textquotesingle{}, \textquotesingle{}8\textquotesingle{}, \textquotesingle{}10\textquotesingle{}\mbox{]}\`{}
\item \href{#escaping}{\tt escaping}
\item \href{#options}{\tt options}
\end{DoxyItemize}

\subsubsection*{Lists}

Uses \href{https://github.com/jonschlinkert/fill-range}{\tt fill-\/range} for expanding alphabetical or numeric lists\+:


\begin{DoxyCode}
console.log(braces('a/\{foo,bar,baz\}/*.js'));
//=> ['a/(foo|bar|baz)/*.js']

console.log(braces.expand('a/\{foo,bar,baz\}/*.js'));
//=> ['a/foo/*.js', 'a/bar/*.js', 'a/baz/*.js']
\end{DoxyCode}


\subsubsection*{Sequences}

Uses \href{https://github.com/jonschlinkert/fill-range}{\tt fill-\/range} for expanding alphabetical or numeric ranges (bash \char`\"{}sequences\char`\"{})\+:


\begin{DoxyCode}
console.log(braces.expand('\{1..3\}'));     // ['1', '2', '3']
console.log(braces.expand('a\{01..03\}b')); // ['a01b', 'a02b', 'a03b']
console.log(braces.expand('a\{1..3\}b'));   // ['a1b', 'a2b', 'a3b']
console.log(braces.expand('\{a..c\}'));     // ['a', 'b', 'c']
console.log(braces.expand('foo/\{a..c\}')); // ['foo/a', 'foo/b', 'foo/c']

// supports padded ranges
console.log(braces('a\{01..03\}b'));   //=> [ 'a(0[1-3])b' ]
console.log(braces('a\{001..300\}b')); //=> [ 'a(0\{2\}[1-9]|0[1-9][0-9]|[12][0-9]\{2\}|300)b' ]
\end{DoxyCode}


\subsubsection*{Steps}

Steps, or increments, may be used with ranges\+:


\begin{DoxyCode}
console.log(braces.expand('\{2..10..2\}'));
//=> ['2', '4', '6', '8', '10']

console.log(braces('\{2..10..2\}'));
//=> ['(2|4|6|8|10)']
\end{DoxyCode}


When the \href{#optimize}{\tt .optimize} method is used, or \href{#optionsoptimize}{\tt options.\+optimize} is set to true, sequences are passed to \href{https://github.com/jonschlinkert/to-regex-range}{\tt to-\/regex-\/range} for expansion.

\subsubsection*{Nesting}

Brace patterns may be nested. The results of each expanded string are not sorted, and left to right order is preserved.

$\ast$$\ast$\char`\"{}\+Expanded\char`\"{} braces$\ast$$\ast$


\begin{DoxyCode}
console.log(braces.expand('a\{b,c,/\{x,y\}\}/e'));
//=> ['ab/e', 'ac/e', 'a/x/e', 'a/y/e']

console.log(braces.expand('a/\{x,\{1..5\},y\}/c'));
//=> ['a/x/c', 'a/1/c', 'a/2/c', 'a/3/c', 'a/4/c', 'a/5/c', 'a/y/c']
\end{DoxyCode}


$\ast$$\ast$\char`\"{}\+Optimized\char`\"{} braces$\ast$$\ast$


\begin{DoxyCode}
console.log(braces('a\{b,c,/\{x,y\}\}/e'));
//=> ['a(b|c|/(x|y))/e']

console.log(braces('a/\{x,\{1..5\},y\}/c'));
//=> ['a/(x|([1-5])|y)/c']
\end{DoxyCode}


\subsubsection*{Escaping}

{\bfseries Escaping braces}

A brace pattern will not be expanded or evaluted if {\itshape either the opening or closing brace is escaped}\+:


\begin{DoxyCode}
console.log(braces.expand('a\(\backslash\)\(\backslash\)\{d,c,b\}e'));
//=> ['a\{d,c,b\}e']

console.log(braces.expand('a\{d,c,b\(\backslash\)\(\backslash\)\}e'));
//=> ['a\{d,c,b\}e']
\end{DoxyCode}


{\bfseries Escaping commas}

Commas inside braces may also be escaped\+:


\begin{DoxyCode}
console.log(braces.expand('a\{b\(\backslash\)\(\backslash\),c\}d'));
//=> ['a\{b,c\}d']

console.log(braces.expand('a\{d\(\backslash\)\(\backslash\),c,b\}e'));
//=> ['ad,ce', 'abe']
\end{DoxyCode}


{\bfseries Single items}

Following bash conventions, a brace pattern is also not expanded when it contains a single character\+:


\begin{DoxyCode}
console.log(braces.expand('a\{b\}c'));
//=> ['a\{b\}c']
\end{DoxyCode}


\subsection*{Options}

\subsubsection*{options.\+max\+Length}

{\bfseries Type}\+: {\ttfamily Number}

{\bfseries Default}\+: {\ttfamily 65,536}

{\bfseries Description}\+: Limit the length of the input string. Useful when the input string is generated or your application allows users to pass a string, et cetera.


\begin{DoxyCode}
console.log(braces('a/\{b,c\}/d', \{ maxLength: 3 \}));  //=> throws an error
\end{DoxyCode}


\subsubsection*{options.\+expand}

{\bfseries Type}\+: {\ttfamily Boolean}

{\bfseries Default}\+: {\ttfamily undefined}

{\bfseries Description}\+: Generate an \char`\"{}expanded\char`\"{} brace pattern (this option is unncessary with the {\ttfamily .expand} method, which does the same thing).


\begin{DoxyCode}
console.log(braces('a/\{b,c\}/d', \{expand: true\}));
//=> [ 'a/b/d', 'a/c/d' ]
\end{DoxyCode}


\subsubsection*{options.\+optimize}

{\bfseries Type}\+: {\ttfamily Boolean}

{\bfseries Default}\+: {\ttfamily true}

{\bfseries Description}\+: Enabled by default.


\begin{DoxyCode}
console.log(braces('a/\{b,c\}/d'));
//=> [ 'a/(b|c)/d' ]
\end{DoxyCode}


\subsubsection*{options.\+nodupes}

{\bfseries Type}\+: {\ttfamily Boolean}

{\bfseries Default}\+: {\ttfamily true}

{\bfseries Description}\+: Duplicates are removed by default. To keep duplicates, pass {\ttfamily \{nodupes\+: false\}} on the options

\subsubsection*{options.\+range\+Limit}

{\bfseries Type}\+: {\ttfamily Number}

{\bfseries Default}\+: {\ttfamily 250}

{\bfseries Description}\+: When {\ttfamily braces.\+expand()} is used, or {\ttfamily options.\+expand} is true, brace patterns will automatically be \href{#optionsoptimize}{\tt optimized} when the difference between the range minimum and range maximum exceeds the {\ttfamily range\+Limit}. This is to prevent huge ranges from freezing your application.

You can set this to any number, or change {\ttfamily options.\+range\+Limit} to {\ttfamily Inifinity} to disable this altogether.

{\bfseries Examples}


\begin{DoxyCode}
// pattern exceeds the "rangeLimit", so it's optimized automatically
console.log(braces.expand('\{1..1000\}'));
//=> ['([1-9]|[1-9][0-9]\{1,2\}|1000)']

// pattern does not exceed "rangeLimit", so it's NOT optimized
console.log(braces.expand('\{1..100\}'));
//=> ['1', '2', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12', '13', '14', '15', '16', '17', '18',
       '19', '20', '21', '22', '23', '24', '25', '26', '27', '28', '29', '30', '31', '32', '33', '34', '35', '36',
       '37', '38', '39', '40', '41', '42', '43', '44', '45', '46', '47', '48', '49', '50', '51', '52', '53', '54',
       '55', '56', '57', '58', '59', '60', '61', '62', '63', '64', '65', '66', '67', '68', '69', '70', '71', '72',
       '73', '74', '75', '76', '77', '78', '79', '80', '81', '82', '83', '84', '85', '86', '87', '88', '89', '90',
       '91', '92', '93', '94', '95', '96', '97', '98', '99', '100']
\end{DoxyCode}


\subsubsection*{options.\+transform}

{\bfseries Type}\+: {\ttfamily Function}

{\bfseries Default}\+: {\ttfamily undefined}

{\bfseries Description}\+: Customize range expansion.


\begin{DoxyCode}
var range = braces.expand('x\{a..e\}y', \{
  transform: function(str) \{
    return 'foo' + str;
  \}
\});

console.log(range);
//=> [ 'xfooay', 'xfooby', 'xfoocy', 'xfoody', 'xfooey' ]
\end{DoxyCode}


\subsubsection*{options.\+quantifiers}

{\bfseries Type}\+: {\ttfamily Boolean}

{\bfseries Default}\+: {\ttfamily undefined}

{\bfseries Description}\+: In regular expressions, quanitifiers can be used to specify how many times a token can be repeated. For example, {\ttfamily a\{1,3\}} will match the letter {\ttfamily a} one to three times.

Unfortunately, regex quantifiers happen to share the same syntax as \href{#lists}{\tt Bash lists}

The {\ttfamily quantifiers} option tells braces to detect when \href{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp#quantifiers}{\tt regex quantifiers} are defined in the given pattern, and not to try to expand them as lists.

{\bfseries Examples}


\begin{DoxyCode}
var braces = require('braces');
console.log(braces('a/b\{1,3\}/\{x,y,z\}'));
//=> [ 'a/b(1|3)/(x|y|z)' ]
console.log(braces('a/b\{1,3\}/\{x,y,z\}', \{quantifiers: true\}));
//=> [ 'a/b\{1,3\}/(x|y|z)' ]
console.log(braces('a/b\{1,3\}/\{x,y,z\}', \{quantifiers: true, expand: true\}));
//=> [ 'a/b\{1,3\}/x', 'a/b\{1,3\}/y', 'a/b\{1,3\}/z' ]
\end{DoxyCode}


\subsubsection*{options.\+unescape}

{\bfseries Type}\+: {\ttfamily Boolean}

{\bfseries Default}\+: {\ttfamily undefined}

{\bfseries Description}\+: Strip backslashes that were used for escaping from the result.

\subsection*{What is \char`\"{}brace expansion\char`\"{}?}

Brace expansion is a type of parameter expansion that was made popular by unix shells for generating lists of strings, as well as regex-\/like matching when used alongside wildcards (globs).

In addition to \char`\"{}expansion\char`\"{}, braces are also used for matching. In other words\+:


\begin{DoxyItemize}
\item \href{#brace-expansion}{\tt brace expansion} is for generating new lists
\item \href{#brace-matching}{\tt brace matching} is for filtering existing lists
\end{DoxyItemize}

$<$details$>$

There are two main types of brace expansion\+:


\begin{DoxyEnumerate}
\item {\bfseries lists}\+: which are defined using comma-\/separated values inside curly braces\+: {\ttfamily \{a,b,c\}}
\item {\bfseries sequences}\+: which are defined using a starting value and an ending value, separated by two dots\+: {\ttfamily a\{1..3\}b}. Optionally, a third argument may be passed to define a \char`\"{}step\char`\"{} or increment to use\+: {\ttfamily a\{1..100..10\}b}. These are also sometimes referred to as \char`\"{}ranges\char`\"{}.
\end{DoxyEnumerate}

Here are some example brace patterns to illustrate how they work\+:

{\bfseries Sets}


\begin{DoxyCode}
\{a,b,c\}       => a b c
\{a,b,c\}\{1,2\}  => a1 a2 b1 b2 c1 c2
\end{DoxyCode}


{\bfseries Sequences}


\begin{DoxyCode}
\{1..9\}        => 1 2 3 4 5 6 7 8 9
\{4..-4\}       => 4 3 2 1 0 -1 -2 -3 -4
\{1..20..3\}    => 1 4 7 10 13 16 19
\{a..j\}        => a b c d e f g h i j
\{j..a\}        => j i h g f e d c b a
\{a..z..3\}     => a d g j m p s v y
\end{DoxyCode}


{\bfseries Combination}

Sets and sequences can be mixed together or used along with any other strings.


\begin{DoxyCode}
\{a,b,c\}\{1..3\}   => a1 a2 a3 b1 b2 b3 c1 c2 c3
foo/\{a,b,c\}/bar => foo/a/bar foo/b/bar foo/c/bar
\end{DoxyCode}


The fact that braces can be \char`\"{}expanded\char`\"{} from relatively simple patterns makes them ideal for quickly generating test fixtures, file paths, and similar use cases.

\subsection*{Brace matching}

In addition to {\itshape expansion}, brace patterns are also useful for performing regular-\/expression-\/like matching.

For example, the pattern {\ttfamily foo/\{1..3\}/bar} would match any of following strings\+:


\begin{DoxyCode}
foo/1/bar
foo/2/bar
foo/3/bar
\end{DoxyCode}


But not\+:


\begin{DoxyCode}
baz/1/qux
baz/2/qux
baz/3/qux
\end{DoxyCode}


Braces can also be combined with \href{https://github.com/jonschlinkert/micromatch}{\tt glob patterns} to perform more advanced wildcard matching. For example, the pattern {\ttfamily $\ast$/\{1..3\}/$\ast$} would match any of following strings\+:


\begin{DoxyCode}
foo/1/bar
foo/2/bar
foo/3/bar
baz/1/qux
baz/2/qux
baz/3/qux
\end{DoxyCode}


\subsection*{Brace matching pitfalls}

Although brace patterns offer a user-\/friendly way of matching ranges or sets of strings, there are also some major disadvantages and potential risks you should be aware of.

\subsubsection*{tldr}

$\ast$$\ast$\char`\"{}brace bombs\char`\"{}$\ast$$\ast$


\begin{DoxyItemize}
\item brace expansion can eat up a huge amount of processing resources
\item as brace patterns increase {\itshape linearly in size}, the system resources required to expand the pattern increase exponentially
\item users can accidentally (or intentially) exhaust your system\textquotesingle{}s resources resulting in the equivalent of a DoS attack (bonus\+: no programming knowledge is required!)
\end{DoxyItemize}

For a more detailed explanation with examples, see the \href{#geometric-complexity}{\tt geometric complexity} section.

\subsubsection*{The solution}

Jump to the \href{#performance}{\tt performance section} to see how Braces solves this problem in comparison to other libraries.

\subsubsection*{Geometric complexity}

At minimum, brace patterns with sets limited to two elements have quadradic or {\ttfamily O(n$^\wedge$2)} complexity. But the complexity of the algorithm increases exponentially as the number of sets, {\itshape and elements per set}, increases, which is {\ttfamily O(n$^\wedge$c)}.

For example, the following sets demonstrate quadratic ({\ttfamily O(n$^\wedge$2)}) complexity\+:


\begin{DoxyCode}
\{1,2\}\{3,4\}      => (2X2)    => 13 14 23 24
\{1,2\}\{3,4\}\{5,6\} => (2X2X2)  => 135 136 145 146 235 236 245 246
\end{DoxyCode}


But add an element to a set, and we get a n-\/fold Cartesian product with {\ttfamily O(n$^\wedge$c)} complexity\+:


\begin{DoxyCode}
\{1,2,3\}\{4,5,6\}\{7,8,9\} => (3X3X3) => 147 148 149 157 158 159 167 168 169 247 248 
                                    249 257 258 259 267 268 269 347 348 349 357 
                                    358 359 367 368 369
\end{DoxyCode}


Now, imagine how this complexity grows given that each element is a n-\/tuple\+:


\begin{DoxyCode}
\{1..100\}\{1..100\}         => (100X100)     => 10,000 elements (38.4 kB)
\{1..100\}\{1..100\}\{1..100\} => (100X100X100) => 1,000,000 elements (5.76 MB)
\end{DoxyCode}


Although these examples are clearly contrived, they demonstrate how brace patterns can quickly grow out of control.

{\bfseries More information}

Interested in learning more about brace expansion?


\begin{DoxyItemize}
\item \href{http://www.linuxjournal.com/content/bash-brace-expansion}{\tt linuxjournal/bash-\/brace-\/expansion}
\item \href{https://rosettacode.org/wiki/Brace_expansion}{\tt rosettacode/\+Brace\+\_\+expansion}
\item \href{https://en.wikipedia.org/wiki/Cartesian_product}{\tt cartesian product}
\end{DoxyItemize}

$<$/details$>$

\subsection*{Performance}

Braces is not only screaming fast, it\textquotesingle{}s also more accurate the other brace expansion libraries.

\subsubsection*{Better algorithms}

Fortunately there is a solution to the \href{#brace-matching-pitfalls}{\tt \char`\"{}brace bomb\char`\"{} problem}\+: {\itshape don\textquotesingle{}t expand brace patterns into an array when they\textquotesingle{}re used for matching}.

Instead, convert the pattern into an optimized regular expression. This is easier said than done, and braces is the only library that does this currently.

{\bfseries The proof is in the numbers}

Minimatch gets exponentially slower as patterns increase in complexity, braces does not. The following results were generated using {\ttfamily braces()} and {\ttfamily minimatch.\+brace\+Expand()}, respectively.

\tabulinesep=1mm
\begin{longtabu} spread 0pt [c]{*{3}{|X[-1]}|}
\hline
\rowcolor{\tableheadbgcolor}\textbf{ {\bfseries Pattern}  }&\multicolumn{2}{p{(\linewidth-\tabcolsep*3-\arrayrulewidth*2)*2/3}|}{\cellcolor{\tableheadbgcolor}\textbf{ $\ast$$\ast$   }}\\\cline{1-3}
\endfirsthead
\hline
\endfoot
\hline
\rowcolor{\tableheadbgcolor}\textbf{ {\bfseries Pattern}  }&\multicolumn{2}{p{(\linewidth-\tabcolsep*3-\arrayrulewidth*2)*2/3}|}{\cellcolor{\tableheadbgcolor}\textbf{ $\ast$$\ast$   }}\\\cline{1-3}
\endhead
{\ttfamily \{1..9007199254740991\}}\textsuperscript{\href{#fn1}{\tt \mbox{[}1\mbox{]}}}  &{\ttfamily 298 B} (5ms 459μs)  &N/A (freezes)   \\\cline{1-3}
{\ttfamily \{1..1000000000000000\}}  &{\ttfamily 41 B} (1ms 15μs)  &N/A (freezes)   \\\cline{1-3}
{\ttfamily \{1..100000000000000\}}  &{\ttfamily 40 B} (890μs)  &N/A (freezes)   \\\cline{1-3}
{\ttfamily \{1..10000000000000\}}  &{\ttfamily 39 B} (2ms 49μs)  &N/A (freezes)   \\\cline{1-3}
{\ttfamily \{1..1000000000000\}}  &{\ttfamily 38 B} (608μs)  &N/A (freezes)   \\\cline{1-3}
{\ttfamily \{1..100000000000\}}  &{\ttfamily 37 B} (397μs)  &N/A (freezes)   \\\cline{1-3}
{\ttfamily \{1..10000000000\}}  &{\ttfamily 35 B} (983μs)  &N/A (freezes)   \\\cline{1-3}
{\ttfamily \{1..1000000000\}}  &{\ttfamily 34 B} (798μs)  &N/A (freezes)   \\\cline{1-3}
{\ttfamily \{1..100000000\}}  &{\ttfamily 33 B} (733μs)  &N/A (freezes)   \\\cline{1-3}
{\ttfamily \{1..10000000\}}  &{\ttfamily 32 B} (5ms 632μs)  &{\ttfamily 78.\+89 MB} (16s 388ms 569μs)   \\\cline{1-3}
{\ttfamily \{1..1000000\}}  &{\ttfamily 31 B} (1ms 381μs)  &{\ttfamily 6.\+89 MB} (1s 496ms 887μs)   \\\cline{1-3}
{\ttfamily \{1..100000\}}  &{\ttfamily 30 B} (950μs)  &{\ttfamily 588.\+89 kB} (146ms 921μs)   \\\cline{1-3}
{\ttfamily \{1..10000\}}  &{\ttfamily 29 B} (1ms 114μs)  &{\ttfamily 48.\+89 kB} (14ms 187μs)   \\\cline{1-3}
{\ttfamily \{1..1000\}}  &{\ttfamily 28 B} (760μs)  &{\ttfamily 3.\+89 kB} (1ms 453μs)   \\\cline{1-3}
{\ttfamily \{1..100\}}  &{\ttfamily 22 B} (345μs)  &{\ttfamily 291 B} (196μs)   \\\cline{1-3}
{\ttfamily \{1..10\}}  &{\ttfamily 10 B} (533μs)  &{\ttfamily 20 B} (37μs)   \\\cline{1-3}
{\ttfamily \{1..3\}}  &{\ttfamily 7 B} (190μs)  &{\ttfamily 5 B} (27μs)   \\\cline{1-3}
\end{longtabu}


\subsubsection*{Faster algorithms}

When you need expansion, braces is still much faster.

\+\_\+(the following results were generated using {\ttfamily braces.\+expand()} and {\ttfamily minimatch.\+brace\+Expand()}, respectively)\+\_\+

\tabulinesep=1mm
\begin{longtabu} spread 0pt [c]{*{3}{|X[-1]}|}
\hline
\rowcolor{\tableheadbgcolor}\textbf{ {\bfseries Pattern}  }&\multicolumn{2}{p{(\linewidth-\tabcolsep*3-\arrayrulewidth*2)*2/3}|}{\cellcolor{\tableheadbgcolor}\textbf{ $\ast$$\ast$   }}\\\cline{1-3}
\endfirsthead
\hline
\endfoot
\hline
\rowcolor{\tableheadbgcolor}\textbf{ {\bfseries Pattern}  }&\multicolumn{2}{p{(\linewidth-\tabcolsep*3-\arrayrulewidth*2)*2/3}|}{\cellcolor{\tableheadbgcolor}\textbf{ $\ast$$\ast$   }}\\\cline{1-3}
\endhead
{\ttfamily \{1..10000000\}}  &{\ttfamily 78.\+89 MB} (2s 698ms 642μs)  &{\ttfamily 78.\+89 MB} (18s 601ms 974μs)   \\\cline{1-3}
{\ttfamily \{1..1000000\}}  &{\ttfamily 6.\+89 MB} (458ms 576μs)  &{\ttfamily 6.\+89 MB} (1s 491ms 621μs)   \\\cline{1-3}
{\ttfamily \{1..100000\}}  &{\ttfamily 588.\+89 kB} (20ms 728μs)  &{\ttfamily 588.\+89 kB} (156ms 919μs)   \\\cline{1-3}
{\ttfamily \{1..10000\}}  &{\ttfamily 48.\+89 kB} (2ms 202μs)  &{\ttfamily 48.\+89 kB} (13ms 641μs)   \\\cline{1-3}
{\ttfamily \{1..1000\}}  &{\ttfamily 3.\+89 kB} (1ms 796μs)  &{\ttfamily 3.\+89 kB} (1ms 958μs)   \\\cline{1-3}
{\ttfamily \{1..100\}}  &{\ttfamily 291 B} (424μs)  &{\ttfamily 291 B} (211μs)   \\\cline{1-3}
{\ttfamily \{1..10\}}  &{\ttfamily 20 B} (487μs)  &{\ttfamily 20 B} (72μs)   \\\cline{1-3}
{\ttfamily \{1..3\}}  &{\ttfamily 5 B} (166μs)  &{\ttfamily 5 B} (27μs)   \\\cline{1-3}
\end{longtabu}


If you\textquotesingle{}d like to run these comparisons yourself, see \href{test/support/generate.js}{\tt test/support/generate.\+js}.

\subsection*{Benchmarks}

\subsubsection*{Running benchmarks}

Install dev dependencies\+:


\begin{DoxyCode}
npm i -d && npm benchmark
\end{DoxyCode}


\subsubsection*{Latest results}


\begin{DoxyCode}
Benchmarking: (8 of 8)
 · combination-nested
 · combination
 · escaped
 · list-basic
 · list-multiple
 · no-braces
 · sequence-basic
 · sequence-multiple

# benchmark/fixtures/combination-nested.js (52 bytes)
  brace-expansion x 4,756 ops/sec ±1.09% (86 runs sampled)
  braces x 11,202,303 ops/sec ±1.06% (88 runs sampled)
  minimatch x 4,816 ops/sec ±0.99% (87 runs sampled)

  fastest is braces

# benchmark/fixtures/combination.js (51 bytes)
  brace-expansion x 625 ops/sec ±0.87% (87 runs sampled)
  braces x 11,031,884 ops/sec ±0.72% (90 runs sampled)
  minimatch x 637 ops/sec ±0.84% (88 runs sampled)

  fastest is braces

# benchmark/fixtures/escaped.js (44 bytes)
  brace-expansion x 163,325 ops/sec ±1.05% (87 runs sampled)
  braces x 10,655,071 ops/sec ±1.22% (88 runs sampled)
  minimatch x 147,495 ops/sec ±0.96% (88 runs sampled)

  fastest is braces

# benchmark/fixtures/list-basic.js (40 bytes)
  brace-expansion x 99,726 ops/sec ±1.07% (83 runs sampled)
  braces x 10,596,584 ops/sec ±0.98% (88 runs sampled)
  minimatch x 100,069 ops/sec ±1.17% (86 runs sampled)

  fastest is braces

# benchmark/fixtures/list-multiple.js (52 bytes)
  brace-expansion x 34,348 ops/sec ±1.08% (88 runs sampled)
  braces x 9,264,131 ops/sec ±1.12% (88 runs sampled)
  minimatch x 34,893 ops/sec ±0.87% (87 runs sampled)

  fastest is braces

# benchmark/fixtures/no-braces.js (48 bytes)
  brace-expansion x 275,368 ops/sec ±1.18% (89 runs sampled)
  braces x 9,134,677 ops/sec ±0.95% (88 runs sampled)
  minimatch x 3,755,954 ops/sec ±1.13% (89 runs sampled)

  fastest is braces

# benchmark/fixtures/sequence-basic.js (41 bytes)
  brace-expansion x 5,492 ops/sec ±1.35% (87 runs sampled)
  braces x 8,485,034 ops/sec ±1.28% (89 runs sampled)
  minimatch x 5,341 ops/sec ±1.17% (87 runs sampled)

  fastest is braces

# benchmark/fixtures/sequence-multiple.js (51 bytes)
  brace-expansion x 116 ops/sec ±0.77% (77 runs sampled)
  braces x 9,445,118 ops/sec ±1.32% (84 runs sampled)
  minimatch x 109 ops/sec ±1.16% (76 runs sampled)

  fastest is braces
\end{DoxyCode}


\subsection*{About}

$<$details$>$ 

{\bfseries Contributing}

Pull requests and stars are always welcome. For bugs and feature requests, \href{../../issues/new}{\tt please create an issue}.

$<$/details$>$

$<$details$>$ 

{\bfseries Running Tests}

Running and reviewing unit tests is a great way to get familiarized with a library and its A\+PI. You can install dependencies and run tests with the following command\+:


\begin{DoxyCode}
$ npm install && npm test
\end{DoxyCode}


$<$/details$>$

$<$details$>$ 

{\bfseries Building docs}

\+\_\+(This project\textquotesingle{}s readme.\+md is generated by \href{https://github.com/verbose/verb-generate-readme}{\tt verb}, please don\textquotesingle{}t edit the readme directly. Any changes to the readme must be made in the .verb.\+md \char`\"{}.\+verb.\+md\char`\"{} readme template.)\+\_\+

To generate the readme, run the following command\+:


\begin{DoxyCode}
$ npm install -g verbose/verb#dev verb-generate-readme && verb
\end{DoxyCode}


$<$/details$>$

\subsubsection*{Related projects}

You might also be interested in these projects\+:


\begin{DoxyItemize}
\item \href{https://www.npmjs.com/package/expand-brackets}{\tt expand-\/brackets}\+: Expand P\+O\+S\+IX bracket expressions (character classes) in glob patterns. $\vert$ \mbox{[}homepage\mbox{]}(\href{https://github.com/jonschlinkert/expand-brackets}{\tt https\+://github.\+com/jonschlinkert/expand-\/brackets} \char`\"{}\+Expand P\+O\+S\+I\+X bracket expressions (character classes) in glob patterns.\char`\"{})
\item \href{https://www.npmjs.com/package/extglob}{\tt extglob}\+: Extended glob support for Java\+Script. Adds (almost) the expressive power of regular expressions to glob… \href{https://github.com/micromatch/extglob}{\tt more} $\vert$ \mbox{[}homepage\mbox{]}(\href{https://github.com/micromatch/extglob}{\tt https\+://github.\+com/micromatch/extglob} \char`\"{}\+Extended glob support for Java\+Script. Adds (almost) the expressive power of regular expressions to glob patterns.\char`\"{})
\item \href{https://www.npmjs.com/package/fill-range}{\tt fill-\/range}\+: Fill in a range of numbers or letters, optionally passing an increment or {\ttfamily step} to… \href{https://github.com/jonschlinkert/fill-range}{\tt more} $\vert$ \href{https://github.com/jonschlinkert/fill-range}{\tt homepage}
\item \href{https://www.npmjs.com/package/micromatch}{\tt micromatch}\+: Glob matching for javascript/node.\+js. A drop-\/in replacement and faster alternative to minimatch and multimatch. $\vert$ \href{https://github.com/micromatch/micromatch}{\tt homepage}
\item \href{https://www.npmjs.com/package/nanomatch}{\tt nanomatch}\+: Fast, minimal glob matcher for node.\+js. Similar to micromatch, minimatch and multimatch, but complete Bash… \href{https://github.com/micromatch/nanomatch}{\tt more} $\vert$ \mbox{[}homepage\mbox{]}(\href{https://github.com/micromatch/nanomatch}{\tt https\+://github.\+com/micromatch/nanomatch} \char`\"{}\+Fast, minimal glob matcher for node.\+js. Similar to micromatch, minimatch and multimatch, but complete Bash 4.\+3 wildcard support only (no support for exglobs, posix brackets or braces)\char`\"{})
\end{DoxyItemize}

\subsubsection*{Contributors}

\tabulinesep=1mm
\begin{longtabu} spread 0pt [c]{*{2}{|X[-1]}|}
\hline
\rowcolor{\tableheadbgcolor}\multicolumn{2}{|p{(\linewidth-\tabcolsep*2-\arrayrulewidth*1)*2/2}|}{\cellcolor{\tableheadbgcolor}\textbf{ $\ast$$\ast$\+Commits$\ast$   }}\\\cline{1-2}
\endfirsthead
\hline
\endfoot
\hline
\rowcolor{\tableheadbgcolor}\multicolumn{2}{|p{(\linewidth-\tabcolsep*2-\arrayrulewidth*1)*2/2}|}{\cellcolor{\tableheadbgcolor}\textbf{ $\ast$$\ast$\+Commits$\ast$   }}\\\cline{1-2}
\endhead
188  &\href{https://github.com/jonschlinkert}{\tt jonschlinkert}   \\\cline{1-2}
4  &\href{https://github.com/doowb}{\tt doowb}   \\\cline{1-2}
1  &\href{https://github.com/es128}{\tt es128}   \\\cline{1-2}
1  &\href{https://github.com/eush77}{\tt eush77}   \\\cline{1-2}
1  &\href{https://github.com/hemanth}{\tt hemanth}   \\\cline{1-2}
\end{longtabu}


\subsubsection*{Author}

{\bfseries Jon Schlinkert}


\begin{DoxyItemize}
\item \href{https://linkedin.com/in/jonschlinkert}{\tt linkedin/in/jonschlinkert}
\item \href{https://github.com/jonschlinkert}{\tt github/jonschlinkert}
\item \href{https://twitter.com/jonschlinkert}{\tt twitter/jonschlinkert}
\end{DoxyItemize}

\subsubsection*{License}

Copyright © 2018, \href{https://github.com/jonschlinkert}{\tt Jon Schlinkert}. Released under the \mbox{[}M\+IT License\mbox{]}(L\+I\+C\+E\+N\+SE).





{\itshape This file was generated by \href{https://github.com/verbose/verb-generate-readme}{\tt verb-\/generate-\/readme}, v0.\+6.\+0, on February 17, 2018.}



 $<$section class=\char`\"{}footnotes\char`\"{}$>$ 
\begin{DoxyEnumerate}
\item this is the largest safe integer allowed in Java\+Script. \href{#fnref1}{\tt ↩}


\end{DoxyEnumerate}$<$/section$>$ 