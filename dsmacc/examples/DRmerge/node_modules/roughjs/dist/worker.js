!function(){"use strict";function t(t,s){return t.type===s}const s={A:7,a:7,C:6,c:6,H:1,h:1,L:2,l:2,M:2,m:2,Q:4,q:4,S:4,s:4,T:4,t:2,V:1,v:1,Z:0,z:0};class e{constructor(t){this.COMMAND=0,this.NUMBER=1,this.EOD=2,this.segments=[],this.parseData(t),this.processPoints()}tokenize(t){const s=new Array;for(;""!==t;)if(t.match(/^([ \t\r\n,]+)/))t=t.substr(RegExp.$1.length);else if(t.match(/^([aAcChHlLmMqQsStTvVzZ])/))s[s.length]={type:this.COMMAND,text:RegExp.$1},t=t.substr(RegExp.$1.length);else{if(!t.match(/^(([-+]?[0-9]+(\.[0-9]*)?|[-+]?\.[0-9]+)([eE][-+]?[0-9]+)?)/))return console.error("Unrecognized segment command: "+t),[];s[s.length]={type:this.NUMBER,text:`${parseFloat(RegExp.$1)}`},t=t.substr(RegExp.$1.length)}return s[s.length]={type:this.EOD,text:""},s}parseData(e){const i=this.tokenize(e);let h=0,a=i[h],n="BOD";for(this.segments=new Array;!t(a,this.EOD);){let o;const r=new Array;if("BOD"===n){if("M"!==a.text&&"m"!==a.text)return void this.parseData("M0,0"+e);h++,o=s[a.text],n=a.text}else t(a,this.NUMBER)?o=s[n]:(h++,o=s[a.text],n=a.text);if(h+o<i.length){for(let s=h;s<h+o;s++){const e=i[s];if(!t(e,this.NUMBER))return void console.error("Parameter type is not a number: "+n+","+e.text);r[r.length]=+e.text}if("number"!=typeof s[n])return void console.error("Unsupported segment type: "+n);{const t={key:n,data:r};this.segments.push(t),a=i[h+=o],"M"===n&&(n="L"),"m"===n&&(n="l")}}else console.error("Path data ended before all parameters were found")}}get closed(){if(void 0===this._closed){this._closed=!1;for(const t of this.segments)"z"===t.key.toLowerCase()&&(this._closed=!0)}return this._closed}processPoints(){let t=null,s=[0,0];for(let e=0;e<this.segments.length;e++){const i=this.segments[e];switch(i.key){case"M":case"L":case"T":i.point=[i.data[0],i.data[1]];break;case"m":case"l":case"t":i.point=[i.data[0]+s[0],i.data[1]+s[1]];break;case"H":i.point=[i.data[0],s[1]];break;case"h":i.point=[i.data[0]+s[0],s[1]];break;case"V":i.point=[s[0],i.data[0]];break;case"v":i.point=[s[0],i.data[0]+s[1]];break;case"z":case"Z":t&&(i.point=[t[0],t[1]]);break;case"C":i.point=[i.data[4],i.data[5]];break;case"c":i.point=[i.data[4]+s[0],i.data[5]+s[1]];break;case"S":i.point=[i.data[2],i.data[3]];break;case"s":i.point=[i.data[2]+s[0],i.data[3]+s[1]];break;case"Q":i.point=[i.data[2],i.data[3]];break;case"q":i.point=[i.data[2]+s[0],i.data[3]+s[1]];break;case"A":i.point=[i.data[5],i.data[6]];break;case"a":i.point=[i.data[5]+s[0],i.data[6]+s[1]]}"m"!==i.key&&"M"!==i.key||(t=null),i.point&&(s=i.point,t||(t=i.point)),"z"!==i.key&&"Z"!==i.key||(t=null)}}}class i{constructor(t){this._position=[0,0],this._first=null,this.bezierReflectionPoint=null,this.quadReflectionPoint=null,this.parsed=new e(t)}get segments(){return this.parsed.segments}get closed(){return this.parsed.closed}get linearPoints(){if(!this._linearPoints){const t=[];let s=[];for(const e of this.parsed.segments){const i=e.key.toLowerCase();("m"!==i&&"z"!==i||(s.length&&(t.push(s),s=[]),"z"!==i))&&(e.point&&s.push(e.point))}s.length&&(t.push(s),s=[]),this._linearPoints=t}return this._linearPoints}get first(){return this._first}set first(t){this._first=t}setPosition(t,s){this._position=[t,s],this._first||(this._first=[t,s])}get position(){return this._position}get x(){return this._position[0]}get y(){return this._position[1]}}class h{constructor(t,s,e,i,h,a){if(this._segIndex=0,this._numSegs=0,this._rx=0,this._ry=0,this._sinPhi=0,this._cosPhi=0,this._C=[0,0],this._theta=0,this._delta=0,this._T=0,this._from=t,t[0]===s[0]&&t[1]===s[1])return;const n=Math.PI/180;this._rx=Math.abs(e[0]),this._ry=Math.abs(e[1]),this._sinPhi=Math.sin(i*n),this._cosPhi=Math.cos(i*n);const o=this._cosPhi*(t[0]-s[0])/2+this._sinPhi*(t[1]-s[1])/2,r=-this._sinPhi*(t[0]-s[0])/2+this._cosPhi*(t[1]-s[1])/2;let c=0;const l=this._rx*this._rx*this._ry*this._ry-this._rx*this._rx*r*r-this._ry*this._ry*o*o;if(l<0){const t=Math.sqrt(1-l/(this._rx*this._rx*this._ry*this._ry));this._rx=this._rx*t,this._ry=this._ry*t,c=0}else c=(h===a?-1:1)*Math.sqrt(l/(this._rx*this._rx*r*r+this._ry*this._ry*o*o));const p=c*this._rx*r/this._ry,u=-c*this._ry*o/this._rx;this._C=[0,0],this._C[0]=this._cosPhi*p-this._sinPhi*u+(t[0]+s[0])/2,this._C[1]=this._sinPhi*p+this._cosPhi*u+(t[1]+s[1])/2,this._theta=this.calculateVectorAngle(1,0,(o-p)/this._rx,(r-u)/this._ry);let f=this.calculateVectorAngle((o-p)/this._rx,(r-u)/this._ry,(-o-p)/this._rx,(-r-u)/this._ry);!a&&f>0?f-=2*Math.PI:a&&f<0&&(f+=2*Math.PI),this._numSegs=Math.ceil(Math.abs(f/(Math.PI/2))),this._delta=f/this._numSegs,this._T=8/3*Math.sin(this._delta/4)*Math.sin(this._delta/4)/Math.sin(this._delta/2)}getNextSegment(){if(this._segIndex===this._numSegs)return null;const t=Math.cos(this._theta),s=Math.sin(this._theta),e=this._theta+this._delta,i=Math.cos(e),h=Math.sin(e),a=[this._cosPhi*this._rx*i-this._sinPhi*this._ry*h+this._C[0],this._sinPhi*this._rx*i+this._cosPhi*this._ry*h+this._C[1]],n=[this._from[0]+this._T*(-this._cosPhi*this._rx*s-this._sinPhi*this._ry*t),this._from[1]+this._T*(-this._sinPhi*this._rx*s+this._cosPhi*this._ry*t)],o=[a[0]+this._T*(this._cosPhi*this._rx*h+this._sinPhi*this._ry*i),a[1]+this._T*(this._sinPhi*this._rx*h-this._cosPhi*this._ry*i)];return this._theta=e,this._from=[a[0],a[1]],this._segIndex++,{cp1:n,cp2:o,to:a}}calculateVectorAngle(t,s,e,i){const h=Math.atan2(s,t),a=Math.atan2(i,e);return a>=h?a-h:2*Math.PI-(h-a)}}class a{constructor(t,s){this.sets=t,this.closed=s}fit(t){const s=[];for(const e of this.sets){const i=e.length;let h=Math.floor(t*i);if(h<5){if(i<=5)continue;h=5}s.push(this.reduce(e,h))}let e="";for(const t of s){for(let s=0;s<t.length;s++){const i=t[s];e+=0===s?"M"+i[0]+","+i[1]:"L"+i[0]+","+i[1]}this.closed&&(e+="z ")}return e}distance(t,s){return Math.sqrt(Math.pow(t[0]-s[0],2)+Math.pow(t[1]-s[1],2))}reduce(t,s){if(t.length<=s)return t;const e=t.slice(0);for(;e.length>s;){let t=-1,s=-1;for(let i=1;i<e.length-1;i++){const h=this.distance(e[i-1],e[i]),a=this.distance(e[i],e[i+1]),n=this.distance(e[i-1],e[i+1]),o=(h+a+n)/2,r=Math.sqrt(o*(o-h)*(o-a)*(o-n));(t<0||r<t)&&(t=r,s=i)}if(!(s>0))break;e.splice(s,1)}return e}}class n{constructor(t,s){this.xi=Number.MAX_VALUE,this.yi=Number.MAX_VALUE,this.px1=t[0],this.py1=t[1],this.px2=s[0],this.py2=s[1],this.a=this.py2-this.py1,this.b=this.px1-this.px2,this.c=this.px2*this.py1-this.px1*this.py2,this._undefined=0===this.a&&0===this.b&&0===this.c}isUndefined(){return this._undefined}intersects(t){if(this.isUndefined()||t.isUndefined())return!1;let s=Number.MAX_VALUE,e=Number.MAX_VALUE,i=0,h=0;const a=this.a,n=this.b,o=this.c;return Math.abs(n)>1e-5&&(s=-a/n,i=-o/n),Math.abs(t.b)>1e-5&&(e=-t.a/t.b,h=-t.c/t.b),s===Number.MAX_VALUE?e===Number.MAX_VALUE?-o/a==-t.c/t.a&&(this.py1>=Math.min(t.py1,t.py2)&&this.py1<=Math.max(t.py1,t.py2)?(this.xi=this.px1,this.yi=this.py1,!0):this.py2>=Math.min(t.py1,t.py2)&&this.py2<=Math.max(t.py1,t.py2)&&(this.xi=this.px2,this.yi=this.py2,!0)):(this.xi=this.px1,this.yi=e*this.xi+h,!((this.py1-this.yi)*(this.yi-this.py2)<-1e-5||(t.py1-this.yi)*(this.yi-t.py2)<-1e-5)&&(!(Math.abs(t.a)<1e-5)||!((t.px1-this.xi)*(this.xi-t.px2)<-1e-5))):e===Number.MAX_VALUE?(this.xi=t.px1,this.yi=s*this.xi+i,!((t.py1-this.yi)*(this.yi-t.py2)<-1e-5||(this.py1-this.yi)*(this.yi-this.py2)<-1e-5)&&(!(Math.abs(a)<1e-5)||!((this.px1-this.xi)*(this.xi-this.px2)<-1e-5))):s===e?i===h&&(this.px1>=Math.min(t.px1,t.px2)&&this.px1<=Math.max(t.py1,t.py2)?(this.xi=this.px1,this.yi=this.py1,!0):this.px2>=Math.min(t.px1,t.px2)&&this.px2<=Math.max(t.px1,t.px2)&&(this.xi=this.px2,this.yi=this.py2,!0)):(this.xi=(h-i)/(s-e),this.yi=s*this.xi+i,!((this.px1-this.xi)*(this.xi-this.px2)<-1e-5||(t.px1-this.xi)*(this.xi-t.px2)<-1e-5))}}function o(t,s){const e=t[1][1]-t[0][1],i=t[0][0]-t[1][0],h=e*t[0][0]+i*t[0][1],a=s[1][1]-s[0][1],n=s[0][0]-s[1][0],o=a*s[0][0]+n*s[0][1],r=e*n-a*i;return r?[Math.round((n*h-i*o)/r),Math.round((e*o-a*h)/r)]:null}class r{constructor(t,s,e,i,h,a,o,r){this.deltaX=0,this.hGap=0,this.top=t,this.bottom=s,this.left=e,this.right=i,this.gap=h,this.sinAngle=a,this.tanAngle=r,Math.abs(a)<1e-4?this.pos=e+h:Math.abs(a)>.9999?this.pos=t+h:(this.deltaX=(s-t)*Math.abs(r),this.pos=e-Math.abs(this.deltaX),this.hGap=Math.abs(h/o),this.sLeft=new n([e,s],[e,t]),this.sRight=new n([i,s],[i,t]))}nextLine(){if(Math.abs(this.sinAngle)<1e-4){if(this.pos<this.right){const t=[this.pos,this.top,this.pos,this.bottom];return this.pos+=this.gap,t}}else if(Math.abs(this.sinAngle)>.9999){if(this.pos<this.bottom){const t=[this.left,this.pos,this.right,this.pos];return this.pos+=this.gap,t}}else{let t=this.pos-this.deltaX/2,s=this.pos+this.deltaX/2,e=this.bottom,i=this.top;if(this.pos<this.right+this.deltaX){for(;t<this.left&&s<this.left||t>this.right&&s>this.right;)if(this.pos+=this.hGap,t=this.pos-this.deltaX/2,s=this.pos+this.deltaX/2,this.pos>this.right+this.deltaX)return null;const h=new n([t,e],[s,i]);this.sLeft&&h.intersects(this.sLeft)&&(t=h.xi,e=h.yi),this.sRight&&h.intersects(this.sRight)&&(s=h.xi,i=h.yi),this.tanAngle>0&&(t=this.right-(t-this.left),s=this.right-(s-this.left));const a=[t,e,s,i];return this.pos+=this.hGap,a}}return null}}function c(t){const s=t[0],e=t[1];return Math.sqrt(Math.pow(s[0]-e[0],2)+Math.pow(s[1]-e[1],2))}function l(t,s){const e=[],i=new n([t[0],t[1]],[t[2],t[3]]);for(let t=0;t<s.length;t++){const h=new n(s[t],s[(t+1)%s.length]);i.intersects(h)&&e.push([i.xi,i.yi])}return e}function p(t,s,e,i,h,a,n){return[-e*a-i*h+e+a*t+h*s,n*(e*h-i*a)+i+-n*h*t+n*a*s]}function u(t,s){const e=[];if(t&&t.length){let i=t[0][0],h=t[0][0],a=t[0][1],n=t[0][1];for(let s=1;s<t.length;s++)i=Math.min(i,t[s][0]),h=Math.max(h,t[s][0]),a=Math.min(a,t[s][1]),n=Math.max(n,t[s][1]);const o=s.hachureAngle;let c=s.hachureGap;c<0&&(c=4*s.strokeWidth),c=Math.max(c,.1);const p=o%180*(Math.PI/180),u=Math.cos(p),f=Math.sin(p),d=Math.tan(p),M=new r(a-1,n+1,i-1,h+1,c,f,u,d);let g;for(;null!=(g=M.nextLine());){const s=l(g,t);for(let t=0;t<s.length;t++)if(t<s.length-1){const i=s[t],h=s[t+1];e.push([i,h])}}}return e}function f(t,s,e,i,h,a){const n=[];let o=Math.abs(i/2),r=Math.abs(h/2);o+=t.randOffset(.05*o,a),r+=t.randOffset(.05*r,a);const c=a.hachureAngle;let l=a.hachureGap;l<=0&&(l=4*a.strokeWidth);let u=a.fillWeight;u<0&&(u=a.strokeWidth/2);const f=c%180*(Math.PI/180),d=Math.tan(f),M=r/o,g=Math.sqrt(M*d*M*d+1),y=M*d/g,x=1/g,_=l/(o*r/Math.sqrt(r*x*(r*x)+o*y*(o*y))/o);let m=Math.sqrt(o*o-(s-o+_)*(s-o+_));for(let t=s-o+_;t<s+o;t+=_){const i=p(t,e-(m=Math.sqrt(o*o-(s-t)*(s-t))),s,e,y,x,M),h=p(t,e+m,s,e,y,x,M);n.push([i,h])}return n}class d{constructor(t){this.helper=t}fillPolygon(t,s){return this._fillPolygon(t,s)}fillEllipse(t,s,e,i,h){return this._fillEllipse(t,s,e,i,h)}fillArc(t,s,e,i,h,a,n){return null}_fillPolygon(t,s,e=!1){const i=u(t,s);return{type:"fillSketch",ops:this.renderLines(i,s,e)}}_fillEllipse(t,s,e,i,h,a=!1){const n=f(this.helper,t,s,e,i,h);return{type:"fillSketch",ops:this.renderLines(n,h,a)}}renderLines(t,s,e){let i=[],h=null;for(const a of t)i=i.concat(this.helper.doubleLineOps(a[0][0],a[0][1],a[1][0],a[1][1],s)),e&&h&&(i=i.concat(this.helper.doubleLineOps(h[0],h[1],a[0][0],a[0][1],s))),h=a[1];return i}}class M extends d{fillPolygon(t,s){return this._fillPolygon(t,s,!0)}fillEllipse(t,s,e,i,h){return this._fillEllipse(t,s,e,i,h,!0)}}class g extends d{fillPolygon(t,s){const e=this._fillPolygon(t,s),i=Object.assign({},s,{hachureAngle:s.hachureAngle+90}),h=this._fillPolygon(t,i);return e.ops=e.ops.concat(h.ops),e}fillEllipse(t,s,e,i,h){const a=this._fillEllipse(t,s,e,i,h),n=Object.assign({},h,{hachureAngle:h.hachureAngle+90}),o=this._fillEllipse(t,s,e,i,n);return a.ops=a.ops.concat(o.ops),a}}class y{constructor(t){this.helper=t}fillPolygon(t,s){const e=u(t,s=Object.assign({},s,{curveStepCount:4,hachureAngle:0}));return this.dotsOnLines(e,s)}fillEllipse(t,s,e,i,h){h=Object.assign({},h,{curveStepCount:4,hachureAngle:0});const a=f(this.helper,t,s,e,i,h);return this.dotsOnLines(a,h)}fillArc(t,s,e,i,h,a,n){return null}dotsOnLines(t,s){let e=[],i=s.hachureGap;i<0&&(i=4*s.strokeWidth),i=Math.max(i,.1);let h=s.fillWeight;h<0&&(h=s.strokeWidth/2);for(const a of t){const t=c(a)/i,n=Math.ceil(t)-1,o=Math.atan((a[1][1]-a[0][1])/(a[1][0]-a[0][0]));for(let t=0;t<n;t++){const n=i*(t+1),r=n*Math.sin(o),c=n*Math.cos(o),l=[a[0][0]-c,a[0][1]+r],p=this.helper.randOffsetWithRange(l[0]-i/4,l[0]+i/4,s),u=this.helper.randOffsetWithRange(l[1]-i/4,l[1]+i/4,s),f=this.helper.ellipse(p,u,h,h,s);e=e.concat(f.ops)}}return{type:"fillSketch",ops:e}}}class x{constructor(t){this.helper=t}fillPolygon(t,s){const e=[Number.MAX_SAFE_INTEGER,Number.MIN_SAFE_INTEGER],i=[Number.MAX_SAFE_INTEGER,Number.MIN_SAFE_INTEGER];t.forEach(t=>{e[0]=Math.min(e[0],t[0]),e[1]=Math.max(e[1],t[0]),i[0]=Math.min(i[0],t[1]),i[1]=Math.max(i[1],t[1])});const h=function(t){let s=0,e=0,i=0;for(let e=0;e<t.length;e++){const i=t[e],h=e===t.length-1?t[0]:t[e+1];s+=i[0]*h[1]-h[0]*i[1]}s/=2;for(let s=0;s<t.length;s++){const h=t[s],a=s===t.length-1?t[0]:t[s+1];e+=(h[0]+a[0])*(h[0]*a[1]-a[0]*h[1]),i+=(h[1]+a[1])*(h[0]*a[1]-a[0]*h[1])}return[e/(6*s),i/(6*s)]}(t),a=Math.max(Math.sqrt(Math.pow(h[0]-e[0],2)+Math.pow(h[1]-i[0],2)),Math.sqrt(Math.pow(h[0]-e[1],2)+Math.pow(h[1]-i[1],2))),n=s.hachureGap>0?s.hachureGap:4*s.strokeWidth,r=[];if(t.length>2)for(let s=0;s<t.length;s++)s===t.length-1?r.push([t[s],t[0]]):r.push([t[s],t[s+1]]);let c=[];const l=Math.max(1,Math.PI*a/n);for(let t=0;t<l;t++){const s=t*Math.PI/l,n=[h,[h[0]+a*Math.cos(s),h[1]+a*Math.sin(s)]];r.forEach(t=>{const s=o(t,n);s&&s[0]>=e[0]&&s[0]<=e[1]&&s[1]>=i[0]&&s[1]<=i[1]&&c.push(s)})}c=this.removeDuplocatePoints(c);const p=this.createLinesFromCenter(h,c);return{type:"fillSketch",ops:this.drawLines(p,s)}}fillEllipse(t,s,e,i,h){return this.fillArcSegment(t,s,e,i,0,2*Math.PI,h)}fillArc(t,s,e,i,h,a,n){return this.fillArcSegment(t,s,e,i,h,a,n)}fillArcSegment(t,s,e,i,h,a,n){const o=[t,s],r=e/2,c=i/2,l=Math.max(e/2,i/2);let p=n.hachureGap;p<0&&(p=4*n.strokeWidth);const u=Math.max(1,Math.abs(a-h)*l/p);let f=[];for(let t=0;t<u;t++){const s=t*((a-h)/u)+h,e=l*Math.cos(s),i=l*Math.sin(s),n=Math.sqrt(r*r*i*i+c*c*e*e),p=r*c*e/n,d=r*c*i/n;f.push([o[0]+p,o[1]+d])}f=this.removeDuplocatePoints(f);const d=this.createLinesFromCenter(o,f);return{type:"fillSketch",ops:this.drawLines(d,n)}}drawLines(t,s){let e=[];return t.forEach(t=>{const i=t[0],h=t[1];e=e.concat(this.helper.doubleLineOps(i[0],i[1],h[0],h[1],s))}),e}createLinesFromCenter(t,s){return s.map(s=>[t,s])}removeDuplocatePoints(t){const s=new Set;return t.filter(t=>{const e=t.join(",");return!s.has(e)&&(s.add(e),!0)})}}class _{constructor(t){this.helper=t}fillPolygon(t,s){const e=u(t,s);return{type:"fillSketch",ops:this.dashedLine(e,s)}}fillEllipse(t,s,e,i,h){const a=f(this.helper,t,s,e,i,h);return{type:"fillSketch",ops:this.dashedLine(a,h)}}fillArc(t,s,e,i,h,a,n){return null}dashedLine(t,s){const e=s.dashOffset<0?s.hachureGap<0?4*s.strokeWidth:s.hachureGap:s.dashOffset,i=s.dashGap<0?s.hachureGap<0?4*s.strokeWidth:s.hachureGap:s.dashGap;let h=[];return t.forEach(t=>{const a=c(t),n=Math.floor(a/(e+i)),o=(a+i-n*(e+i))/2;let r=t[0],l=t[1];r[0]>l[0]&&(r=t[1],l=t[0]);const p=Math.atan((l[1]-r[1])/(l[0]-r[0]));for(let t=0;t<n;t++){const a=t*(e+i),n=a+e,c=[r[0]+a*Math.cos(p)+o*Math.cos(p),r[1]+a*Math.sin(p)+o*Math.sin(p)],l=[r[0]+n*Math.cos(p)+o*Math.cos(p),r[1]+n*Math.sin(p)+o*Math.sin(p)];h=h.concat(this.helper.doubleLineOps(c[0],c[1],l[0],l[1],s))}}),h}}class m{constructor(t){this.helper=t}fillPolygon(t,s){const e=s.hachureGap<0?4*s.strokeWidth:s.hachureGap,i=s.zigzagOffset<0?e:s.zigzagOffset,h=u(t,s=Object.assign({},s,{hachureGap:e+i}));return{type:"fillSketch",ops:this.zigzagLines(h,i,s)}}fillEllipse(t,s,e,i,h){const a=h.hachureGap<0?4*h.strokeWidth:h.hachureGap,n=h.zigzagOffset<0?a:h.zigzagOffset;h=Object.assign({},h,{hachureGap:a+n});const o=f(this.helper,t,s,e,i,h);return{type:"fillSketch",ops:this.zigzagLines(o,n,h)}}fillArc(t,s,e,i,h,a,n){return null}zigzagLines(t,s,e){let i=[];return t.forEach(t=>{const h=c(t),a=Math.round(h/(2*s));let n=t[0],o=t[1];n[0]>o[0]&&(n=t[1],o=t[0]);const r=Math.atan((o[1]-n[1])/(o[0]-n[0]));for(let t=0;t<a;t++){const h=2*t*s,a=2*(t+1)*s,o=Math.sqrt(2*Math.pow(s,2)),c=[n[0]+h*Math.cos(r),n[1]+h*Math.sin(r)],l=[n[0]+a*Math.cos(r),n[1]+a*Math.sin(r)],p=[c[0]+o*Math.cos(r+Math.PI/4),c[1]+o*Math.sin(r+Math.PI/4)];i=(i=i.concat(this.helper.doubleLineOps(c[0],c[1],p[0],p[1],e))).concat(this.helper.doubleLineOps(p[0],p[1],l[0],l[1],e))}}),i}}const b={};function P(t,s){let e=t.fillStyle||"hachure";if(!b[e])switch(e){case"zigzag":b[e]||(b[e]=new M(s));break;case"cross-hatch":b[e]||(b[e]=new g(s));break;case"dots":b[e]||(b[e]=new y(s));break;case"starburst":b[e]||(b[e]=new x(s));break;case"dashed":b[e]||(b[e]=new _(s));break;case"zigzag-line":b[e]||(b[e]=new m(s));break;case"hachure":default:b[e="hachure"]||(b[e]=new d(s))}return b[e]}const k={randOffset:O,randOffsetWithRange:S,ellipse:w,doubleLineOps:R};function A(t,s,e,i,h){return{type:"path",ops:T(t,s,e,i,h)}}function E(t,s,e){const i=(t||[]).length;if(i>2){let h=[];for(let s=0;s<i-1;s++)h=h.concat(T(t[s][0],t[s][1],t[s+1][0],t[s+1][1],e));return s&&(h=h.concat(T(t[i-1][0],t[i-1][1],t[0][0],t[0][1],e))),{type:"path",ops:h}}return 2===i?A(t[0][0],t[0][1],t[1][0],t[1][1],e):{type:"path",ops:[]}}function v(t,s){return E(t,!0,s)}function w(t,s,e,i,h){const a=2*Math.PI/h.curveStepCount;let n=Math.abs(e/2),o=Math.abs(i/2);const r=C(a,t,s,n+=z(.05*n,h),o+=z(.05*o,h),1,a*I(.1,I(.4,1,h),h),h),c=C(a,t,s,n,o,1.5,0,h);return{type:"path",ops:r.concat(c)}}function L(t,s){return P(s,k).fillPolygon(t,s)}function O(t,s){return z(t,s)}function S(t,s,e){return I(t,s,e)}function R(t,s,e,i,h){return T(t,s,e,i,h)}function I(t,s,e){return e.roughness*(Math.random()*(s-t)+t)}function z(t,s){return I(-t,t,s)}function T(t,s,e,i,h){const a=N(t,s,e,i,h,!0,!1),n=N(t,s,e,i,h,!0,!0);return a.concat(n)}function N(t,s,e,i,h,a,n){const o=Math.pow(t-e,2)+Math.pow(s-i,2);let r=h.maxRandomnessOffset||0;r*r*100>o&&(r=Math.sqrt(o)/10);const c=r/2,l=.2+.2*Math.random();let p=h.bowing*h.maxRandomnessOffset*(i-s)/200,u=h.bowing*h.maxRandomnessOffset*(t-e)/200;p=z(p,h),u=z(u,h);const f=[],d=()=>z(c,h),M=()=>z(r,h);return a&&(n?f.push({op:"move",data:[t+d(),s+d()]}):f.push({op:"move",data:[t+z(r,h),s+z(r,h)]})),n?f.push({op:"bcurveTo",data:[p+t+(e-t)*l+d(),u+s+(i-s)*l+d(),p+t+2*(e-t)*l+d(),u+s+2*(i-s)*l+d(),e+d(),i+d()]}):f.push({op:"bcurveTo",data:[p+t+(e-t)*l+M(),u+s+(i-s)*l+M(),p+t+2*(e-t)*l+M(),u+s+2*(i-s)*l+M(),e+M(),i+M()]}),f}function q(t,s,e){const i=[];i.push([t[0][0]+z(s,e),t[0][1]+z(s,e)]),i.push([t[0][0]+z(s,e),t[0][1]+z(s,e)]);for(let h=1;h<t.length;h++)i.push([t[h][0]+z(s,e),t[h][1]+z(s,e)]),h===t.length-1&&i.push([t[h][0]+z(s,e),t[h][1]+z(s,e)]);return G(i,null,e)}function G(t,s,e){const i=t.length;let h=[];if(i>3){const a=[],n=1-e.curveTightness;h.push({op:"move",data:[t[1][0],t[1][1]]});for(let s=1;s+2<i;s++){const e=t[s];a[0]=[e[0],e[1]],a[1]=[e[0]+(n*t[s+1][0]-n*t[s-1][0])/6,e[1]+(n*t[s+1][1]-n*t[s-1][1])/6],a[2]=[t[s+1][0]+(n*t[s][0]-n*t[s+2][0])/6,t[s+1][1]+(n*t[s][1]-n*t[s+2][1])/6],a[3]=[t[s+1][0],t[s+1][1]],h.push({op:"bcurveTo",data:[a[1][0],a[1][1],a[2][0],a[2][1],a[3][0],a[3][1]]})}if(s&&2===s.length){const t=e.maxRandomnessOffset;h.push({op:"lineTo",data:[s[0]+z(t,e),s[1]+z(t,e)]})}}else 3===i?(h.push({op:"move",data:[t[1][0],t[1][1]]}),h.push({op:"bcurveTo",data:[t[1][0],t[1][1],t[2][0],t[2][1],t[2][0],t[2][1]]})):2===i&&(h=h.concat(T(t[0][0],t[0][1],t[1][0],t[1][1],e)));return h}function C(t,s,e,i,h,a,n,o){const r=z(.5,o)-Math.PI/2,c=[];c.push([z(a,o)+s+.9*i*Math.cos(r-t),z(a,o)+e+.9*h*Math.sin(r-t)]);for(let n=r;n<2*Math.PI+r-.01;n+=t)c.push([z(a,o)+s+i*Math.cos(n),z(a,o)+e+h*Math.sin(n)]);return c.push([z(a,o)+s+i*Math.cos(r+2*Math.PI+.5*n),z(a,o)+e+h*Math.sin(r+2*Math.PI+.5*n)]),c.push([z(a,o)+s+.98*i*Math.cos(r+n),z(a,o)+e+.98*h*Math.sin(r+n)]),c.push([z(a,o)+s+.9*i*Math.cos(r+.5*n),z(a,o)+e+.9*h*Math.sin(r+.5*n)]),G(c,null,o)}function X(t,s,e,i,h,a,n,o,r){const c=a+z(.1,r),l=[];l.push([z(o,r)+s+.9*i*Math.cos(c-t),z(o,r)+e+.9*h*Math.sin(c-t)]);for(let a=c;a<=n;a+=t)l.push([z(o,r)+s+i*Math.cos(a),z(o,r)+e+h*Math.sin(a)]);return l.push([s+i*Math.cos(n),e+h*Math.sin(n)]),l.push([s+i*Math.cos(n),e+h*Math.sin(n)]),G(l,null,r)}function U(t,s,e,i,h,a,n,o){const r=[],c=[o.maxRandomnessOffset||1,(o.maxRandomnessOffset||1)+.5];let l=[0,0];for(let p=0;p<2;p++)0===p?r.push({op:"move",data:[n.x,n.y]}):r.push({op:"move",data:[n.x+z(c[0],o),n.y+z(c[0],o)]}),l=[h+z(c[p],o),a+z(c[p],o)],r.push({op:"bcurveTo",data:[t+z(c[p],o),s+z(c[p],o),e+z(c[p],o),i+z(c[p],o),l[0],l[1]]});return n.setPosition(l[0],l[1]),r}function W(t,s,e,i){let a=[];switch(s.key){case"M":case"m":{const e="m"===s.key;if(s.data.length>=2){let h=+s.data[0],n=+s.data[1];e&&(h+=t.x,n+=t.y);const o=1*(i.maxRandomnessOffset||0);h+=z(o,i),n+=z(o,i),t.setPosition(h,n),a.push({op:"move",data:[h,n]})}break}case"L":case"l":{const e="l"===s.key;if(s.data.length>=2){let h=+s.data[0],n=+s.data[1];e&&(h+=t.x,n+=t.y),a=a.concat(T(t.x,t.y,h,n,i)),t.setPosition(h,n)}break}case"H":case"h":{const e="h"===s.key;if(s.data.length){let h=+s.data[0];e&&(h+=t.x),a=a.concat(T(t.x,t.y,h,t.y,i)),t.setPosition(h,t.y)}break}case"V":case"v":{const e="v"===s.key;if(s.data.length){let h=+s.data[0];e&&(h+=t.y),a=a.concat(T(t.x,t.y,t.x,h,i)),t.setPosition(t.x,h)}break}case"Z":case"z":t.first&&(a=a.concat(T(t.x,t.y,t.first[0],t.first[1],i)),t.setPosition(t.first[0],t.first[1]),t.first=null);break;case"C":case"c":{const e="c"===s.key;if(s.data.length>=6){let h=+s.data[0],n=+s.data[1],o=+s.data[2],r=+s.data[3],c=+s.data[4],l=+s.data[5];e&&(h+=t.x,o+=t.x,c+=t.x,n+=t.y,r+=t.y,l+=t.y);const p=U(h,n,o,r,c,l,t,i);a=a.concat(p),t.bezierReflectionPoint=[c+(c-o),l+(l-r)]}break}case"S":case"s":{const h="s"===s.key;if(s.data.length>=4){let n=+s.data[0],o=+s.data[1],r=+s.data[2],c=+s.data[3];h&&(n+=t.x,r+=t.x,o+=t.y,c+=t.y);let l=n,p=o;const u=e?e.key:"";let f=null;"c"!==u&&"C"!==u&&"s"!==u&&"S"!==u||(f=t.bezierReflectionPoint),f&&(l=f[0],p=f[1]);const d=U(l,p,n,o,r,c,t,i);a=a.concat(d),t.bezierReflectionPoint=[r+(r-n),c+(c-o)]}break}case"Q":case"q":{const e="q"===s.key;if(s.data.length>=4){let h=+s.data[0],n=+s.data[1],o=+s.data[2],r=+s.data[3];e&&(h+=t.x,o+=t.x,n+=t.y,r+=t.y);const c=1*(1+.2*i.roughness),l=1.5*(1+.22*i.roughness);a.push({op:"move",data:[t.x+z(c,i),t.y+z(c,i)]});let p=[o+z(c,i),r+z(c,i)];a.push({op:"qcurveTo",data:[h+z(c,i),n+z(c,i),p[0],p[1]]}),a.push({op:"move",data:[t.x+z(l,i),t.y+z(l,i)]}),p=[o+z(l,i),r+z(l,i)],a.push({op:"qcurveTo",data:[h+z(l,i),n+z(l,i),p[0],p[1]]}),t.setPosition(p[0],p[1]),t.quadReflectionPoint=[o+(o-h),r+(r-n)]}break}case"T":case"t":{const h="t"===s.key;if(s.data.length>=2){let n=+s.data[0],o=+s.data[1];h&&(n+=t.x,o+=t.y);let r=n,c=o;const l=e?e.key:"";let p=null;"q"!==l&&"Q"!==l&&"t"!==l&&"T"!==l||(p=t.quadReflectionPoint),p&&(r=p[0],c=p[1]);const u=1*(1+.2*i.roughness),f=1.5*(1+.22*i.roughness);a.push({op:"move",data:[t.x+z(u,i),t.y+z(u,i)]});let d=[n+z(u,i),o+z(u,i)];a.push({op:"qcurveTo",data:[r+z(u,i),c+z(u,i),d[0],d[1]]}),a.push({op:"move",data:[t.x+z(f,i),t.y+z(f,i)]}),d=[n+z(f,i),o+z(f,i)],a.push({op:"qcurveTo",data:[r+z(f,i),c+z(f,i),d[0],d[1]]}),t.setPosition(d[0],d[1]),t.quadReflectionPoint=[n+(n-r),o+(o-c)]}break}case"A":case"a":{const e="a"===s.key;if(s.data.length>=7){const n=+s.data[0],o=+s.data[1],r=+s.data[2],c=+s.data[3],l=+s.data[4];let p=+s.data[5],u=+s.data[6];if(e&&(p+=t.x,u+=t.y),p===t.x&&u===t.y)break;if(0===n||0===o)a=a.concat(T(t.x,t.y,p,u,i)),t.setPosition(p,u);else for(let s=0;s<1;s++){const s=new h([t.x,t.y],[p,u],[n,o],r,!!c,!!l);let e=s.getNextSegment();for(;e;){const h=U(e.cp1[0],e.cp1[1],e.cp2[0],e.cp2[1],e.to[0],e.to[1],t,i);a=a.concat(h),e=s.getNextSegment()}}}break}}return a}!function(t){const s=t,e={};self.addEventListener("message",async t=>{let i=t.data||{};i.path=i.path||[];let h=i.target&&e[i.target]||s;const a=t=>t.reduce((t,s)=>t?t[s]:t,h),n=i&&i.id;if(n&&i.type){const t={id:n},s=a(i.path),h=a(i.path.slice(0,-1));switch(i.type){case"GET":t.value=s;break;case"SET":let a=i.path.length&&i.path[i.path.length-1];a&&(h[a]=i.value),t.value=!!a;break;case"APPLY":try{t.value=await s.apply(h,i.args||[])}catch(s){t.error=s.toString()}break;case"CONSTRUCT":try{t.value=new s(...i.args),t.targetId=(t=>{const s=`${Date.now()}-${Math.floor(Math.random()*Number.MAX_SAFE_INTEGER)}`;return e[s]=t,s})(t.value)}catch(s){t.error=s.toString()}}self.postMessage(t)}})}(Object.freeze({line:A,linearPath:E,polygon:v,rectangle:function(t,s,e,i,h){return v([[t,s],[t+e,s],[t+e,s+i],[t,s+i]],h)},curve:function(t,s){const e=q(t,1*(1+.2*s.roughness),s),i=q(t,1.5*(1+.22*s.roughness),s);return{type:"path",ops:e.concat(i)}},ellipse:w,arc:function(t,s,e,i,h,a,n,o,r){const c=t,l=s;let p=Math.abs(e/2),u=Math.abs(i/2);p+=z(.01*p,r),u+=z(.01*u,r);let f=h,d=a;for(;f<0;)f+=2*Math.PI,d+=2*Math.PI;d-f>2*Math.PI&&(f=0,d=2*Math.PI);const M=2*Math.PI/r.curveStepCount,g=Math.min(M/2,(d-f)/2),y=X(g,c,l,p,u,f,d,1,r),x=X(g,c,l,p,u,f,d,1.5,r);let _=y.concat(x);return n&&(o?_=(_=_.concat(T(c,l,c+p*Math.cos(f),l+u*Math.sin(f),r))).concat(T(c,l,c+p*Math.cos(d),l+u*Math.sin(d),r)):(_.push({op:"lineTo",data:[c,l]}),_.push({op:"lineTo",data:[c+p*Math.cos(f),l+u*Math.sin(f)]}))),{type:"path",ops:_}},svgPath:function(t,s){t=(t||"").replace(/\n/g," ").replace(/(-\s)/g,"-").replace("/(ss)/g"," ");let e=new i(t);if(s.simplification){const t=new a(e.linearPoints,e.closed).fit(s.simplification);e=new i(t)}let h=[];const n=e.segments||[];for(let t=0;t<n.length;t++){const i=W(e,n[t],t>0?n[t-1]:null,s);i&&i.length&&(h=h.concat(i))}return{type:"path",ops:h}},solidFillPolygon:function(t,s){const e=[];if(t.length){const i=s.maxRandomnessOffset||0,h=t.length;if(h>2){e.push({op:"move",data:[t[0][0]+z(i,s),t[0][1]+z(i,s)]});for(let a=1;a<h;a++)e.push({op:"lineTo",data:[t[a][0]+z(i,s),t[a][1]+z(i,s)]})}}return{type:"fillPath",ops:e}},patternFillPolygon:L,patternFillEllipse:function(t,s,e,i,h){return P(h,k).fillEllipse(t,s,e,i,h)},patternFillArc:function(t,s,e,i,h,a,n){const o=P(n,k).fillArc(t,s,e,i,h,a,n);if(o)return o;const r=t,c=s;let l=Math.abs(e/2),p=Math.abs(i/2);l+=z(.01*l,n),p+=z(.01*p,n);let u=h,f=a;for(;u<0;)u+=2*Math.PI,f+=2*Math.PI;f-u>2*Math.PI&&(u=0,f=2*Math.PI);const d=(f-u)/n.curveStepCount,M=[];for(let t=u;t<=f;t+=d)M.push([r+l*Math.cos(t),c+p*Math.sin(t)]);return M.push([r+l*Math.cos(f),c+p*Math.sin(f)]),M.push([r,c]),L(M,n)},randOffset:O,randOffsetWithRange:S,doubleLineOps:R}))}();
